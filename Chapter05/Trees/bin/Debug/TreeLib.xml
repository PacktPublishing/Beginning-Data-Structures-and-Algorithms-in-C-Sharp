<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TreeLib</name>
    </assembly>
    <members>
        <member name="T:TreeLib.AVLTreeList`1">
            <summary>
            Implements a map, list or range collection using an AVL tree. 
            </summary>
            <summary>
            Represents an ordered key collection.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.#ctor(System.Collections.Generic.IComparer{`0},System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on an AVL tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on an AVL tree, with the specified capacity and allocation mode and using
            the default comparer.
            </summary>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a new collection based on an AVL tree, with default allocation options and using the specified comparer.
            </summary>
            <param name="comparer">The comparer to use for sorting keys</param>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.#ctor">
            <summary>
            Create a new collection based on an AVL tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.#ctor(TreeLib.AVLTreeList{`0})">
            <summary>
            Create a new collection based on an AVL tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.AVLTreeList`1.Count">
            <summary>
            Returns the number of keys in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue keys.</exception>
        </member>
        <member name="P:TreeLib.AVLTreeList`1.LongCount">
            <summary>
            Returns the number of keys in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.Clear">
            <summary>
            Removes all keys from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.TryAdd(`0)">
            <summary>
            Attempts to add a key to the collection. If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <returns>true if the key was added; false if the key was already present</returns>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.TryRemove(`0)">
            <summary>
            Attempts to remove a key from the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key was found and removed</returns>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.TryGetKey(`0,`0@)">
            <summary>
            Attempts to get the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">the actual key contained in the collection</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.TrySetKey(`0)">
            <summary>
            Attempts to update the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.Add(`0)">
            <summary>
            Adds a key to the collection.
            </summary>
            <param name="key">key to insert</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.Remove(`0)">
            <summary>
            Removes a key from the collection.
            </summary>
            <param name="key">key to remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.GetKey(`0)">
            <summary>
            Retrieves the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <returns>the value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.SetKey(`0)">
            <summary>
            Updates the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.ConditionalSetOrAdd(`0,TreeLib.UpdatePredicate{`0})">
            <summary>
            Conditionally update or add a key, based on the return value from the predicate.
            ConditionalSetOrAdd is more efficient when the decision to add or update depends on the value of the item.
            </summary>
            <param name="key">The key to update or add</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the key will be added to the
            collection if it is not already in the collection. Whether true or false, if the key is in the collection, the
            ref key upon return will be used to update the key data.</param>
            <exception cref="T:System.ArgumentException">The sort order of the key was changed by the predicate</exception>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.ConditionalSetOrRemove(`0,TreeLib.UpdatePredicate{`0})">
            <summary>
            Conditionally update or add a key, based on the return value from the predicate.
            ConditionalSetOrRemove is more efficient when the decision to remove or update depends on the value of the item.
            </summary>
            <param name="key">The key to update or remove</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the key will be removed from the
            collection if it is in the collection. If the key remains in the collection, the ref key upon return will be used
            to update the key data.</param>
            <exception cref="T:System.ArgumentException">The sort order of the key was changed by the predicate</exception>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key)</returns>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key)</returns>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="P:TreeLib.AVLTreeList`1.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.GetEnumerator">
            <summary>
            Get the default enumerator, which is the fast enumerator for AVL trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator’s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator’s current key (i.e. in the portion of the
            collection the enumerator hasn’t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it’s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. The complexity of the fast enumerator
            is O(1) per element, or O(N) to enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.GetEnumerable(`0)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.GetEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.GetFastEnumerable(`0)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.GetFastEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.GetRobustEnumerable(`0)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeList`1.GetRobustEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.AVLTreeList`1.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. However, since it uses queries it
            is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.AVLTreeList`1.FastEnumeratorThreaded">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any Add or Remove to the tree invalidates it.
            </summary>
        </member>
        <member name="T:TreeLib.AVLTreeMap`2">
            <summary>
            Implements a map, list or range collection using an AVL tree. 
            </summary>
            <summary>
            Represents an ordered key-value mapping.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
            <typeparam name="ValueType">Type of value associated with each entry.</typeparam>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.#ctor(System.Collections.Generic.IComparer{`0},System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on an AVL tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on an AVL tree, with the specified capacity and allocation mode and using
            the default comparer.
            </summary>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a new collection based on an AVL tree, with default allocation options and using the specified comparer.
            </summary>
            <param name="comparer">The comparer to use for sorting keys</param>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.#ctor">
            <summary>
            Create a new collection based on an AVL tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.#ctor(TreeLib.AVLTreeMap{`0,`1})">
            <summary>
            Create a new collection based on an AVL tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.AVLTreeMap`2.Count">
            <summary>
            Returns the number of key-value pairs in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue key-value pairs.</exception>
        </member>
        <member name="P:TreeLib.AVLTreeMap`2.LongCount">
            <summary>
            Returns the number of key-value pairs in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.Clear">
            <summary>
            Removes all key-value pairs from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.SetOrAddValue(`0,`1)">
            <summary>
            Either set the value associated with a key (if the key is already present in the collection)
            or insert a new key-value pair into the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="value">value to associate with the key</param>
            <returns>true if key was not present and key-value pair was added; false if key-value pair was already present and value was updated</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.TryAdd(`0,`1)">
            <summary>
            Attempts to add a key-value pair to the collection. If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="value">value to associate with the key</param>
            <returns>true if the key-value pair was added; false if the key was already present</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.TryRemove(`0)">
            <summary>
            Attempts to remove a key-value pair from the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key-value pair was found and removed</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to get the value associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.TrySetValue(`0,`1)">
            <summary>
            Attempts to set the value associated with a key in the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <returns>true if the key-value pair was found and the value was updated</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.Add(`0,`1)">
            <summary>
            Adds a key-value pair to the collection.
            </summary>
            <param name="key">key to insert</param>
            <param name="value">value to associate with the key</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.Remove(`0)">
            <summary>
            Removes a key-value pair from the collection.
            </summary>
            <param name="key">key of the key-value pair to remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.GetValue(`0)">
            <summary>
            Retrieves the value associated with a key in the collection
            </summary>
            <param name="key">key to search for</param>
            <returns>the value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.SetValue(`0,`1)">
            <summary>
            Updates the value associated with a key in the collection
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.ConditionalSetOrAdd(`0,TreeLib.UpdatePredicate{`0,`1})">
            <summary>
            Conditionally update or add an item, based on the return value from the predicate.
            ConditionalSetOrAdd is more efficient when the decision to add or update depends on the value of the item.
            </summary>
            <param name="key">The key of the item to update or add</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the item will be added to the
            collection if it is not already in the collection. Whether true or false, if the item is in the collection, the
            ref value upon return will be used to update the item.</param>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.ConditionalSetOrRemove(`0,TreeLib.UpdatePredicate{`0,`1})">
            <summary>
            Conditionally update or add an item, based on the return value from the predicate.
            ConditionalSetOrRemove is more efficient when the decision to remove or update depends on the value of the item.
            </summary>
            <param name="key">The key of the item to update or remove</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the item will be removed from the
            collection if it is in the collection. If the item remains in the collection, the ref value upon return will be used
            to update the item.</param>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.Least(`0@,`1@)">
            <summary>
            Retrieves the lowest key-value pair in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.Greatest(`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.NearestLessOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.NearestLess(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.NearestGreaterOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.NearestGreater(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="P:TreeLib.AVLTreeMap`2.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.GetEnumerator">
            <summary>
            Get the default enumerator, which is the fast enumerator for AVL trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator’s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator’s current key (i.e. in the portion of the
            collection the enumerator hasn’t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it’s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. The complexity of the fast enumerator
            is O(1) per element, or O(N) to enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.GetEnumerable(`0)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.GetEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.GetFastEnumerable(`0)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.GetFastEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.GetRobustEnumerable(`0)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMap`2.GetRobustEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.AVLTreeMap`2.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. However, since it uses queries it
            is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.AVLTreeMap`2.FastEnumeratorThreaded">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any Add or Remove to the tree invalidates it.
            </summary>
        </member>
        <member name="T:TreeLib.AVLTreeMultiRankList`1">
            <summary>
            Implements a map, list or range collection using an AVL tree. 
            </summary>
            <summary>
            Represents an ordered key collection, augmented with multi-rank information. The rank of a key is the index it would
            be located in if all the keys in the tree were placed into a sorted array. Each key also has a count
            associated with it, which models sorted arrays containing multiple instances of a key. It is equivalent to the number of times
            the key appears in the array. Rank index values account for such multiple occurrences. In this case, the rank
            index is the index at which the first instance of a particular key would occur in a sorted array containing all keys.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.#ctor(System.Collections.Generic.IComparer{`0},System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on an AVL tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on an AVL tree, with the specified capacity and allocation mode and using
            the default comparer.
            </summary>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a new collection based on an AVL tree, with default allocation options and using the specified comparer.
            </summary>
            <param name="comparer">The comparer to use for sorting keys</param>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.#ctor">
            <summary>
            Create a new collection based on an AVL tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.#ctor(TreeLib.AVLTreeMultiRankList{`0})">
            <summary>
            Create a new collection based on an AVL tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.AVLTreeMultiRankList`1.Count">
            <summary>
            Returns the number of keys in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue keys.</exception>
        </member>
        <member name="P:TreeLib.AVLTreeMultiRankList`1.LongCount">
            <summary>
            Returns the number of keys in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.Clear">
            <summary>
            Removes all keys from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.TryRemove(`0)">
            <summary>
            Attempts to remove a key from the collection. If the key is not present, no change is made to the collection.
            The entire key is removed, regardless of the rank count for it.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key was found and removed</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.TryGetKey(`0,`0@)">
            <summary>
            Attempts to get the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">the actual key contained in the collection</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.TrySetKey(`0)">
            <summary>
            Attempts to update the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.Remove(`0)">
            <summary>
            Removes a key from the collection. If the key is not present, no change is made to the collection.
            The entire key is removed, regardless of the rank count for it.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.GetKey(`0)">
            <summary>
            Retrieves the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <returns>the value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.SetKey(`0)">
            <summary>
            Updates the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.NearestLessOrEqual(`0,`0@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.NearestLess(`0,`0@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.NearestGreaterOrEqual(`0,`0@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.NearestGreater(`0,`0@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.NearestLessOrEqualByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a key's range into the start index of a key's range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the specified index is greater than or equal to the extent it will return the last key's start index.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <returns>true if a key was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.NearestLessOrEqualByRank(System.Int32,`0@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a key's range into the start index of a key's range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the specified index is greater than or equal to the extent it will return the last key's start index.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <returns>true if a key was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.NearestLessByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a key's range, the start of the previous key's range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.NearestLessByRank(System.Int32,`0@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a key's range, the start of the previous key's range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.NearestGreaterOrEqualByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range, that index will be returned.
            If the index refers to the interior index for a key's range, the start of the next key's range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than the start of the last key's range, no index will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.NearestGreaterOrEqualByRank(System.Int32,`0@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range, that index will be returned.
            If the index refers to the interior index for a key's range, the start of the next key's range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than the start of the last key's range, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.NearestGreaterByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range or is an interior index for a range, the next key's range will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than or equal to the start of the last key's range, no index will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.NearestGreaterByRank(System.Int32,`0@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest key's range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range or is an interior index for a range, the next key's range will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than or equal to the start of the last key's range, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="P:TreeLib.AVLTreeMultiRankList`1.RankCount">
            <summary>
            Returns the total size of an array containing all keys, where each key occurs one or more times, determined by
            the 'count' associated with each key.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.TryAdd(`0,System.Int32)">
            <summary>
            Attempts to add a key to the collection.
            If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="count">number of instances to repeat this key if the collection were converted to a sorted array</param>
            <returns>true if key was not present and key was added; false if key was already present</returns>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.TryGet(`0,`0@,System.Int32@,System.Int32@)">
            <summary>
            Attempts to get the actual key, rank index, and count associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">out parameter that returns the actual key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key</param>
            <param name="count">out parameter that returns the count, where count is the number of instances to repeat
            this key if the collection were converted to a sorted array</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.TrySet(`0,System.Int32)">
            <summary>
            Attempts to update the key data and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for and also update</param>
            <param name="rank">the new rank count</param>
            <returns>true if they key was found and the rank was a valid value or false if the rank count was not at least 1
            or the sum of counts would have exceeded Int32.MaxValue</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.TryGetKeyByRank(System.Int32,`0@)">
            <summary>
            Attempts to return the key at the specified rank index. If all keys in the collection were
            converted to a sorted array of keys, this would be the equivalent of array[rank]s, subject to the
            constraint that only the first occurrence of each key can be indexed.
            </summary>
            <param name="rank">the rank index to query; the rank must be of the first occurrence of the key in a virtual
            sorted array where each key occurs 'count' times.</param>
            <param name="key">the key located at that index</param>
            <returns>true if there is an element at the the specified index and it corresponds to the first in the virtual
            ordered sequence of multiple instances in an equivalent sorted array</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.Add(`0,System.Int32)">
            <summary>
            Adds a key to the collection with an associated count.
            If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="count">number of instances to repeat this key if the collection were converted to a sorted array</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.Get(`0,`0@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the actual key, rank index, and count associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">out parameter that returns the actual key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key</param>
            <param name="count">out parameter that returns the count, where count is the number of instances to repeat
            this key if the collection were converted to a sorted array</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.Set(`0,System.Int32)">
            <summary>
            Updates the key and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for and also update</param>
            <param name="rank">the new rank count</param>
            <exception cref="T:System.ArgumentException">the rank count was not at least 1</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.GetKeyByRank(System.Int32)">
            <summary>
            Retrieves the key at the specified rank index. If all keys in the collection were
            converted to a sorted array of keys, this would be the equivalent of array[rank], subject to the
            constraint that only the first occurrence of each key can be indexed.
            </summary>
            <param name="rank">the rank index to query; the rank must be of the first occurrence of the key in a virtual
            sorted array where each key occurs 'count' times.</param>
            <returns>the key located at that index</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.AdjustCount(`0,System.Int32)">
            <summary>
            Adjusts the rank count associated with the key. The countAdjust added to the existing count.
            If the countAdjust is equal to the negative value of the current count, the key will be removed.
            </summary>
            <param name="key">key identifying the key to update</param>
            <param name="countAdjust">adjustment that is added to the count</param>
            <returns>The adjusted count</returns>
            <exception cref="T:System.ArgumentException">if the count is an invalid value or the key does not exist in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="P:TreeLib.AVLTreeMultiRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.TreeLib#Internal#INonInvasiveMultiRankMapInspection#GetRanks">
            <summary>
            INonInvasiveMultiRankMapInspection.GetRanks() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.TreeLib#Internal#INonInvasiveMultiRankMapInspection#Validate">
            <summary>
            INonInvasiveMultiRankMapInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.GetEnumerator">
            <summary>
            Get the default enumerator, which is the fast enumerator for AVL trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator’s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator’s current key (i.e. in the portion of the
            collection the enumerator hasn’t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it’s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. The complexity of the fast enumerator
            is O(1) per element, or O(N) to enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.GetEnumerable(`0)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.GetEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.GetFastEnumerable(`0)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.GetFastEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.GetRobustEnumerable(`0)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankList`1.GetRobustEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.AVLTreeMultiRankList`1.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. However, since it uses queries it
            is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.AVLTreeMultiRankList`1.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any Add or Remove to the tree invalidates it.
            </summary>
        </member>
        <member name="T:TreeLib.AVLTreeMultiRankMap`2">
            <summary>
            Implements a map, list or range collection using an AVL tree. 
            </summary>
            <summary>
            Represents an ordered key-value mapping, augmented with multi-rank information. The rank of a key-value pair is the index it would
            be located in if all the key-value pairs in the tree were placed into a sorted array. Each key-value pair also has a count
            associated with it, which models sorted arrays containing multiple instances of a key. It is equivalent to the number of times
            the key-value pair appears in the array. Rank index values account for such multiple occurrences. In this case, the rank
            index is the index at which the first instance of a particular key would occur in a sorted array containing all keys.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
            <typeparam name="ValueType">Type of value associated with each entry.</typeparam>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.#ctor(System.Collections.Generic.IComparer{`0},System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on an AVL tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on an AVL tree, with the specified capacity and allocation mode and using
            the default comparer.
            </summary>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a new collection based on an AVL tree, with default allocation options and using the specified comparer.
            </summary>
            <param name="comparer">The comparer to use for sorting keys</param>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.#ctor">
            <summary>
            Create a new collection based on an AVL tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.#ctor(TreeLib.AVLTreeMultiRankMap{`0,`1})">
            <summary>
            Create a new collection based on an AVL tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.AVLTreeMultiRankMap`2.Count">
            <summary>
            Returns the number of key-value pairs in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue key-value pairs.</exception>
        </member>
        <member name="P:TreeLib.AVLTreeMultiRankMap`2.LongCount">
            <summary>
            Returns the number of key-value pairs in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.Clear">
            <summary>
            Removes all key-value pairs from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.TryRemove(`0)">
            <summary>
            Attempts to remove a key-value pair from the collection. If the key is not present, no change is made to the collection.
            The entire key-value pair is removed, regardless of the rank count for it.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key-value pair was found and removed</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to get the value associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.TrySetValue(`0,`1)">
            <summary>
            Attempts to set the value associated with a key in the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <returns>true if the key-value pair was found and the value was updated</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.Remove(`0)">
            <summary>
            Removes a key-value pair from the collection. If the key is not present, no change is made to the collection.
            The entire key-value pair is removed, regardless of the rank count for it.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.GetValue(`0)">
            <summary>
            Retrieves the value associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <returns>value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.SetValue(`0,`1)">
            <summary>
            Updates the value associated with a key in the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.Least(`0@,`1@)">
            <summary>
            Retrieves the lowest key-value pair in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.Greatest(`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.NearestLessOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.NearestLessOrEqual(`0,`0@,`1@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key and
            the value, rank and count associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.NearestLess(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.NearestLess(`0,`0@,`1@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key and
            the value, rank and count  associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.NearestGreaterOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.NearestGreaterOrEqual(`0,`0@,`1@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key and
            the value, rank and count  associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.NearestGreater(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.NearestGreater(`0,`0@,`1@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key and
            the value, rank and count  associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.NearestLessOrEqualByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a key's range into the start index of a key's range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the specified index is greater than or equal to the extent it will return the last key's start index.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <returns>true if a key was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.NearestLessOrEqualByRank(System.Int32,`0@,System.Int32@,System.Int32@,`1@)">
            <summary>
            Search for the nearest key's index that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a key's range into the start index of a key's range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the specified index is greater than or equal to the extent it will return the last key's start index.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <param name="value">the value associated with the key</param>
            <returns>true if a key was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.NearestLessByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a key's range, the start of the previous key's range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.NearestLessByRank(System.Int32,`0@,System.Int32@,System.Int32@,`1@)">
            <summary>
            Search for the nearest key's index that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a key's range, the start of the previous key's range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <param name="value">the value associated with the key</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.NearestGreaterOrEqualByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range, that index will be returned.
            If the index refers to the interior index for a key's range, the start of the next key's range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than the start of the last key's range, no index will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.NearestGreaterOrEqualByRank(System.Int32,`0@,System.Int32@,System.Int32@,`1@)">
            <summary>
            Search for the nearest key's index that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range, that index will be returned.
            If the index refers to the interior index for a key's range, the start of the next key's range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than the start of the last key's range, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <param name="value">the value associated with the key</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.NearestGreaterByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range or is an interior index for a range, the next key's range will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than or equal to the start of the last key's range, no index will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.NearestGreaterByRank(System.Int32,`0@,System.Int32@,System.Int32@,`1@)">
            <summary>
            Search for the nearest key's range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range or is an interior index for a range, the next key's range will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than or equal to the start of the last key's range, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <param name="value">the value associated with the key</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="P:TreeLib.AVLTreeMultiRankMap`2.RankCount">
            <summary>
            Returns the total size of an array containing all key-value pairs, where each key occurs one or more times, determined by
            the 'count' associated with each key-value pair.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.TryAdd(`0,`1,System.Int32)">
            <summary>
            Attempts to add a key to the collection with an associated value and count.
            If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="value">value to associate with the key</param>
            <param name="count">number of instances to repeat this key-value pair if the collection were converted to a sorted array</param>
            <returns>true if key was not present and key-value pair was added; false if key-value pair was already present and value was updated</returns>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.TryGet(`0,`1@,System.Int32@,System.Int32@)">
            <summary>
            Attempts to get the value, rank index, and count associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <param name="count">out parameter that returns the count, where count is the number of instances to repeat
            this key-value pair if the collection were converted to a sorted array</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.TrySet(`0,`1,System.Int32)">
            <summary>
            Attempts to update the value and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">the new value to set</param>
            <param name="rank">the new rank count</param>
            <returns>true if they key was found and the rank was a valid value or false if the rank count was not at least 1
            or the sum of counts would have exceeded Int32.MaxValue</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.TryGetKeyByRank(System.Int32,`0@)">
            <summary>
            Attempts to return the key of a key-value pair at the specified rank index. If all key-value pairs in the collection were
            converted to a sorted array of key-value pairs, this would be the equivalent of array[rank].Key, subject to the
            constraint that only the first occurrence of each key can be indexed.
            </summary>
            <param name="rank">the rank index to query; the rank must be of the first occurrence of the key in a virtual
            sorted array where each key occurs 'count' times.</param>
            <param name="key">the key located at that index</param>
            <returns>true if there is an element at the the specified index and it corresponds to the first in the virtual
            ordered sequence of multiple instances in an equivalent sorted array</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.Add(`0,`1,System.Int32)">
            <summary>
            Adds a key to the collection with an associated value and count.
            If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="value">value to associate with the key</param>
            <param name="count">number of instances to repeat this key-value pair if the collection were converted to a sorted array</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.Get(`0,`1@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the value, rank index, and count associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <param name="count">out parameter that returns the count, where count is the number of instances to repeat
            this key-value pair if the collection were converted to a sorted array</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.Set(`0,`1,System.Int32)">
            <summary>
            Updates the value and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">the new value to set</param>
            <param name="rank">the new rank count</param>
            <exception cref="T:System.ArgumentException">the rank count was not at least 1</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.GetKeyByRank(System.Int32)">
            <summary>
            Retrieves the key of a key-value pair at the specified rank index. If all key-value pairs in the collection were
            converted to a sorted array of key-value pairs, this would be the equivalent of array[rank].Key, subject to the
            constraint that only the first occurrence of each key can be indexed.
            </summary>
            <param name="rank">the rank index to query; the rank must be of the first occurrence of the key in a virtual
            sorted array where each key occurs 'count' times.</param>
            <returns>the key located at that index</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.AdjustCount(`0,System.Int32)">
            <summary>
            Adjusts the rank count associated with the key-value pair. The countAdjust added to the existing count.
            If the countAdjust is equal to the negative value of the current count, the key-value pair will be removed.
            </summary>
            <param name="key">key identifying the key-value pair to update</param>
            <param name="countAdjust">adjustment that is added to the count</param>
            <returns>The adjusted count</returns>
            <exception cref="T:System.ArgumentException">if the count is an invalid value or the key does not exist in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="P:TreeLib.AVLTreeMultiRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.TreeLib#Internal#INonInvasiveMultiRankMapInspection#GetRanks">
            <summary>
            INonInvasiveMultiRankMapInspection.GetRanks() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.TreeLib#Internal#INonInvasiveMultiRankMapInspection#Validate">
            <summary>
            INonInvasiveMultiRankMapInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.GetEnumerator">
            <summary>
            Get the default enumerator, which is the fast enumerator for AVL trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator’s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator’s current key (i.e. in the portion of the
            collection the enumerator hasn’t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it’s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. The complexity of the fast enumerator
            is O(1) per element, or O(N) to enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.GetEnumerable(`0)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.GetEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.GetFastEnumerable(`0)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.GetFastEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.GetRobustEnumerable(`0)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeMultiRankMap`2.GetRobustEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.AVLTreeMultiRankMap`2.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. However, since it uses queries it
            is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.AVLTreeMultiRankMap`2.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any Add or Remove to the tree invalidates it.
            </summary>
        </member>
        <member name="T:TreeLib.AVLTreeRange2List">
            <summary>
            Implements a map, list or range collection using an AVL tree. 
            </summary>
            <summary>
            Represents an sequenced collection of range-to-range pairs (without associated values). Each range pair is defined by two lengths,
            one for the X sequence and one for the Y sequence.
            With regard to a particular sequence, each range occupies a particular position in the sequence, determined by the location
            where it was inserted (and any insertions/deletions that have occurred before or after it in the sequence).
            Within the sequence, the start indices of each range are determined as follows:
            The first range in the sequence starts at 0 and each subsequent range starts at the starting index of the previous range
            plus the length of the previous range. The 'extent' of the range collection is the sum of all lengths.
            The above applies separately to both the X side sequence and the Y side sequence.
            All ranges must have a lengths of at least 1, on both sides.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on an AVL tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.#ctor">
            <summary>
            Create a new collection based on an AVL tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.#ctor(TreeLib.AVLTreeRange2List)">
            <summary>
            Create a new collection based on an AVL tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.AVLTreeRange2List.Count">
            <summary>
            Returns the number of range pairs in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue range pairs.</exception>
        </member>
        <member name="P:TreeLib.AVLTreeRange2List.LongCount">
            <summary>
            Returns the number of ranges in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.Clear">
            <summary>
            Removes all range pairs from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.Contains(System.Int32,TreeLib.Side)">
            <summary>
            Determines if there is a range pair in the collection starting at the index specified, with respect to the side specified.
            </summary>
            <param name="start">index to look for the start of a range at</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <returns>true if there is a range starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.TryInsert(System.Int32,TreeLib.Side,System.Int32,System.Int32)">
            <summary>
            Attempt to insert a range pair defined by the given pair of lengths at the specified start index with respect to
            the specified side.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            The sequence of the non-specified side is also updated, by inserting the other length of the pair at the same
            rank in the sequence as on the specified side.
            </summary>
            <param name="start">the specified start index to insert before</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <param name="xLength">the length of the X side of the range pair. the length must be at least 1.</param>
            <param name="yLength">the length of the Y side of the range pair. the length must be at least 1.</param>
            <returns>true if the range was successfully inserted</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue on either side</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.TryDelete(System.Int32,TreeLib.Side)">
            <summary>
            Attempt to delete the range pair starting at the specified index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to delete</param>
            <param name="side">the side (X or Y) to which the start index applies</param>
            <returns>true if a range pair was successfully deleted</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.TryGetLength(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Attempt to query the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies. The side also determines which length is returned</param>
            <param name="length">the length of the range from the specified side (X or Y)</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.TrySetLength(System.Int32,TreeLib.Side,System.Int32)">
            <summary>
            Attempt to change the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to modify</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="length">the new length to apply on the specified side (X or Y) of the range pair. The new length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.OverflowException">the sum of lengths on the specified side would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.TryGet(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Attempt to get the lengths associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="otherStart">out parameter receiving the start index of the range from the opposite side of that specified</param>
            <param name="xLength">out parameter receiving the length of the range on the X side</param>
            <param name="yLength">out parameter receiving the length f the range on the Y side</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.TrySet(System.Int32,TreeLib.Side,System.Int32,System.Int32)">
            <summary>
            Attempt to change the lengths associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="side">the side with which the start parameter applies</param>
            <param name="xLength">new X-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="yLength">new Y-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <returns>true if a range was found starting at the specified index and updated; false if the
            start was not found or the sum of lengths would have exceeded Int32.MaxValue</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.Insert(System.Int32,TreeLib.Side,System.Int32,System.Int32)">
            <summary>
            Insert a range pair defined by the given pair of lengths at the specified start index with respect to
            the specified side.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            The sequence of the non-specified side is also updated, by inserting the other length of the pair at the same
            rank in the sequence as on the specified side.
            </summary>
            <param name="start">the specified start index to insert before</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <param name="xLength">the length of the X side of the range pair. the length must be at least 1.</param>
            <param name="yLength">the length of the Y side of the range pair. the length must be at least 1.</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue on either side</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.Delete(System.Int32,TreeLib.Side)">
            <summary>
            Deletes the range pair starting at the specified index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to delete</param>
            <param name="side">the side (X or Y) to which the start index applies</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.GetLength(System.Int32,TreeLib.Side)">
            <summary>
            Retrieves the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies. The side also determines which length is returned</param>
            <returns>the length of the range from the specified side (X or Y)</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.SetLength(System.Int32,TreeLib.Side,System.Int32)">
            <summary>
            Changes the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to modify</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="length">the new length to apply on the specified side (X or Y) of the range pair. The new length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
            <exception cref="T:System.OverflowException">the sum of lengths on the specified side would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.Get(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Attempt to get the lengths associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="otherStart">out parameter receiving the start index of the range from the opposite side of that specified</param>
            <param name="xLength">out parameter receiving the length of the range on the X side</param>
            <param name="yLength">out parameter receiving the length f the range on the Y side</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.Set(System.Int32,TreeLib.Side,System.Int32,System.Int32)">
            <summary>
            Changes the lengths associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="side">the side with which the start parameter applies</param>
            <param name="xLength">new X-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="yLength">new Y-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <returns>true if a range was found starting at the specified index and updated; false if the
            start was not found or the sum of lengths would have exceeded Int32.MaxValue</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.GetExtent(TreeLib.Side)">
            <summary>
            Retrieves the extent of the sequence of ranges on the specified side. The extent is the sum of the lengths of all the ranges.
            </summary>
            <param name="side">the side (X or Y) to which the query applies.</param>
            <returns>the extent of the ranges on the specified side</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.NearestLessOrEqual(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index with respect to the specified side.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.NearestLessOrEqual(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index with respect to the specified side.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.NearestLess(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.NearestLess(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.NearestGreaterOrEqual(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.NearestGreaterOrEqual(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.NearestGreater(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.NearestGreater(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.AdjustLength(System.Int32,TreeLib.Side,System.Int32,System.Int32)">
            <summary>
            Adjust the lengths of the range starting at 'start' by adding xAdjust and yAdjust to the current lengths of the
            range. If the lengths would become 0, the range is removed.
            </summary>
            <param name="start">the start index of the range to adjust</param>
            <param name="side">which side (X or Y) the start parameter applies</param>
            <param name="xAdjust">the amount to adjust the X length by. Value may be negative to shrink the length</param>
            <param name="yAdjust">the amount to adjust the Y length by. Value may be negative to shrink the length</param>
            <returns>The adjusted length</returns>
            <exception cref="T:System.ArgumentException">There is no range starting at the index specified by 'start', or the length on
            one side would become 0 while the length on the other side would not be 0.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">one or both of the lengths would become negative</exception>
            <exception cref="T:System.OverflowException">the X or Y extent would become larger than Int32.MaxValue</exception>
        </member>
        <member name="P:TreeLib.AVLTreeRange2List.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.TreeLib#Internal#INonInvasiveRange2MapInspection#GetRanges">
            <summary>
            INonInvasiveRange2MapInspection.GetRanges() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.TreeLib#Internal#INonInvasiveRange2MapInspection#Validate">
            <summary>
            INonInvasiveRange2MapInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.GetEnumerator">
            <summary>
            Get the default enumerator, which is the fast enumerator for AVL trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator’s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator’s current key (i.e. in the portion of the
            collection the enumerator hasn’t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it’s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. The complexity of the fast enumerator
            is O(1) per element, or O(N) to enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.GetEnumerable(System.Int32,TreeLib.Side)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.GetEnumerable(System.Int32,TreeLib.Side,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.GetFastEnumerable(System.Int32,TreeLib.Side)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.GetFastEnumerable(System.Int32,TreeLib.Side,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.GetRobustEnumerable(System.Int32,TreeLib.Side)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2List.GetRobustEnumerable(System.Int32,TreeLib.Side,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.AVLTreeRange2List.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. However, since it uses queries it
            is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.AVLTreeRange2List.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any Add or Remove to the tree invalidates it.
            </summary>
        </member>
        <member name="T:TreeLib.AVLTreeRange2Map`1">
            <summary>
            Implements a map, list or range collection using an AVL tree. 
            </summary>
            <summary>
            Represents an sequenced collection of range-to-range pairs with associated values. Each range pair is defined by two lengths,
            one for the X sequence and one for the Y sequence.
            With regard to a particular sequence, each range occupies a particular position in the sequence, determined by the location
            where it was inserted (and any insertions/deletions that have occurred before or after it in the sequence).
            Within the sequence, the start indices of each range are determined as follows:
            The first range in the sequence starts at 0 and each subsequent range starts at the starting index of the previous range
            plus the length of the previous range. The 'extent' of the range collection is the sum of all lengths.
            The above applies separately to both the X side sequence and the Y side sequence.
            All ranges must have a lengths of at least 1, on both sides.
            </summary>
            <typeparam name="ValueType">type of the value associated with each range pair</typeparam>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on an AVL tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.#ctor">
            <summary>
            Create a new collection based on an AVL tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.#ctor(TreeLib.AVLTreeRange2Map{`0})">
            <summary>
            Create a new collection based on an AVL tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.AVLTreeRange2Map`1.Count">
            <summary>
            Returns the number of range pairs in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue range pairs.</exception>
        </member>
        <member name="P:TreeLib.AVLTreeRange2Map`1.LongCount">
            <summary>
            Returns the number of ranges in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.Clear">
            <summary>
            Removes all range pairs from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.Contains(System.Int32,TreeLib.Side)">
            <summary>
            Determines if there is a range pair in the collection starting at the index specified, with respect to the side specified.
            </summary>
            <param name="start">index to look for the start of a range at</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <returns>true if there is a range starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.TryInsert(System.Int32,TreeLib.Side,System.Int32,System.Int32,`0)">
            <summary>
            Attempt to insert a range pair defined by the given pair of lengths at the specified start index with respect to
            the specified side and with an associated value.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            The sequence of the non-specified side is also updated, by inserting the other length of the pair at the same
            rank in the sequence as on the specified side.
            </summary>
            <param name="start">the specified start index to insert before</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <param name="xLength">the length of the X side of the range pair. the length must be at least 1.</param>
            <param name="yLength">the length of the Y side of the range pair. the length must be at least 1.</param>
            <param name="value">the value to associate with the range pair</param>
            <returns>true if the range was successfully inserted</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue on either side</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.TryDelete(System.Int32,TreeLib.Side)">
            <summary>
            Attempt to delete the range pair starting at the specified index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to delete</param>
            <param name="side">the side (X or Y) to which the start index applies</param>
            <returns>true if a range pair was successfully deleted</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.TryGetLength(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Attempt to query the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies. The side also determines which length is returned</param>
            <param name="length">the length of the range from the specified side (X or Y)</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.TrySetLength(System.Int32,TreeLib.Side,System.Int32)">
            <summary>
            Attempt to change the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to modify</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="length">the new length to apply on the specified side (X or Y) of the range pair. The new length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.OverflowException">the sum of lengths on the specified side would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.TryGetValue(System.Int32,TreeLib.Side,`0@)">
            <summary>
            Attempt to query the value associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="value">value associated with the range</param>
            <returns>true if a range was found starting at the specified index on the specified side</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.TrySetValue(System.Int32,TreeLib.Side,`0)">
            <summary>
            Attempt to update the value associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to update</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="value">new value that replaces the old value associated with the range</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.TryGet(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,`0@)">
            <summary>
            Attempt to get the value and lengths associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="otherStart">out parameter receiving the start index of the range from the opposite side of that specified</param>
            <param name="xLength">out parameter receiving the length of the range on the X side</param>
            <param name="yLength">out parameter receiving the length f the range on the Y side</param>
            <param name="value">out parameter receiving the value associated with the range</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.TrySet(System.Int32,TreeLib.Side,System.Int32,System.Int32,`0)">
            <summary>
            Attempt to change the lengths and value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="side">the side with which the start parameter applies</param>
            <param name="xLength">new X-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="yLength">new Y-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="value">the value to replace the old value associated with the range</param>
            <returns>true if a range was found starting at the specified index and updated; false if the
            start was not found or the sum of lengths would have exceeded Int32.MaxValue</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.Insert(System.Int32,TreeLib.Side,System.Int32,System.Int32,`0)">
            <summary>
            Insert a range pair defined by the given pair of lengths at the specified start index with respect to
            the specified side and with an associated value.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            The sequence of the non-specified side is also updated, by inserting the other length of the pair at the same
            rank in the sequence as on the specified side.
            </summary>
            <param name="start">the specified start index to insert before</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <param name="xLength">the length of the X side of the range pair. the length must be at least 1.</param>
            <param name="yLength">the length of the Y side of the range pair. the length must be at least 1.</param>
            <param name="value">the value to associate with the range pair</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue on either side</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.Delete(System.Int32,TreeLib.Side)">
            <summary>
            Deletes the range pair starting at the specified index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to delete</param>
            <param name="side">the side (X or Y) to which the start index applies</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.GetLength(System.Int32,TreeLib.Side)">
            <summary>
            Retrieves the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies. The side also determines which length is returned</param>
            <returns>the length of the range from the specified side (X or Y)</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.SetLength(System.Int32,TreeLib.Side,System.Int32)">
            <summary>
            Changes the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to modify</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="length">the new length to apply on the specified side (X or Y) of the range pair. The new length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
            <exception cref="T:System.OverflowException">the sum of lengths on the specified side would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.GetValue(System.Int32,TreeLib.Side)">
            <summary>
            Retrieves the value associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <returns>the value associated with the range</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.SetValue(System.Int32,TreeLib.Side,`0)">
            <summary>
            Updates the value associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to update</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="value">new value that replaces the old value associated with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.Get(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,`0@)">
            <summary>
            Attempt to get the value and lengths associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="otherStart">out parameter receiving the start index of the range from the opposite side of that specified</param>
            <param name="xLength">out parameter receiving the length of the range on the X side</param>
            <param name="yLength">out parameter receiving the length f the range on the Y side</param>
            <param name="value">out parameter receiving the value associated with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.Set(System.Int32,TreeLib.Side,System.Int32,System.Int32,`0)">
            <summary>
            Changes the lengths and value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="side">the side with which the start parameter applies</param>
            <param name="xLength">new X-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="yLength">new Y-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="value">the value to replace the old value associated with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
            <exception cref="T:System.OverflowException">sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.GetExtent(TreeLib.Side)">
            <summary>
            Retrieves the extent of the sequence of ranges on the specified side. The extent is the sum of the lengths of all the ranges.
            </summary>
            <param name="side">the side (X or Y) to which the query applies.</param>
            <returns>the extent of the ranges on the specified side</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.NearestLessOrEqual(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index with respect to the specified side.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.NearestLessOrEqual(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index with respect to the specified side.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.NearestLess(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.NearestLess(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.NearestGreaterOrEqual(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.NearestGreaterOrEqual(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.NearestGreater(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.NearestGreater(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.AdjustLength(System.Int32,TreeLib.Side,System.Int32,System.Int32)">
            <summary>
            Adjust the lengths of the range starting at 'start' by adding xAdjust and yAdjust to the current lengths of the
            range. If the lengths would become 0, the range is removed.
            </summary>
            <param name="start">the start index of the range to adjust</param>
            <param name="side">which side (X or Y) the start parameter applies</param>
            <param name="xAdjust">the amount to adjust the X length by. Value may be negative to shrink the length</param>
            <param name="yAdjust">the amount to adjust the Y length by. Value may be negative to shrink the length</param>
            <returns>The adjusted length</returns>
            <exception cref="T:System.ArgumentException">There is no range starting at the index specified by 'start', or the length on
            one side would become 0 while the length on the other side would not be 0.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">one or both of the lengths would become negative</exception>
            <exception cref="T:System.OverflowException">the X or Y extent would become larger than Int32.MaxValue</exception>
        </member>
        <member name="P:TreeLib.AVLTreeRange2Map`1.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.TreeLib#Internal#INonInvasiveRange2MapInspection#GetRanges">
            <summary>
            INonInvasiveRange2MapInspection.GetRanges() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.TreeLib#Internal#INonInvasiveRange2MapInspection#Validate">
            <summary>
            INonInvasiveRange2MapInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.GetEnumerator">
            <summary>
            Get the default enumerator, which is the fast enumerator for AVL trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator’s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator’s current key (i.e. in the portion of the
            collection the enumerator hasn’t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it’s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. The complexity of the fast enumerator
            is O(1) per element, or O(N) to enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.GetEnumerable(System.Int32,TreeLib.Side)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.GetEnumerable(System.Int32,TreeLib.Side,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.GetFastEnumerable(System.Int32,TreeLib.Side)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.GetFastEnumerable(System.Int32,TreeLib.Side,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.GetRobustEnumerable(System.Int32,TreeLib.Side)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRange2Map`1.GetRobustEnumerable(System.Int32,TreeLib.Side,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.AVLTreeRange2Map`1.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. However, since it uses queries it
            is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.AVLTreeRange2Map`1.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any Add or Remove to the tree invalidates it.
            </summary>
        </member>
        <member name="T:TreeLib.AVLTreeRangeList">
            <summary>
            Implements a map, list or range collection using an AVL tree. 
            </summary>
            <summary>
            Represents an sequenced collection of ranges (without associated values). Each range is defined by it's length, and occupies
            a particular position in the sequence, determined by the location where it was inserted (and any insertions/deletions that
            have occurred before or after it in the sequence). The start indices of each range are determined as follows:
            The first range in the sequence starts at 0 and each subsequent range starts at the starting index of the previous range
            plus the length of the previous range. The 'extent' of the range collection is the sum of all lengths.
            All ranges must have a length of at least 1.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on an AVL tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.#ctor">
            <summary>
            Create a new collection based on an AVL tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.#ctor(TreeLib.AVLTreeRangeList)">
            <summary>
            Create a new collection based on an AVL tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.AVLTreeRangeList.Count">
            <summary>
            Returns the number of ranges in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue ranges.</exception>
        </member>
        <member name="P:TreeLib.AVLTreeRangeList.LongCount">
            <summary>
            Returns the number of ranges in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.Clear">
            <summary>
            Removes all ranges from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.Contains(System.Int32)">
            <summary>
            Determines if there is a range in the collection starting at the specified index.
            </summary>
            <param name="start">index to look for the start of a range at</param>
            <returns>true if there is a range starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.TryInsert(System.Int32,System.Int32)">
            <summary>
            Attempt to insert a range of a given length at the specified start index.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            </summary>
            <param name="start">starting index to attempt to insert the new range at</param>
            <param name="length">length of the new range. The length must be at least 1.</param>
            <returns>true if the range was successfully inserted</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.TryDelete(System.Int32)">
            <summary>
            Attempt to delete the range starting at the specified index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of a range to attempt to delete</param>
            <returns>true if a range was successfully deleted</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.TryGetLength(System.Int32,System.Int32@)">
            <summary>
            Attempt to query the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">out parameter receiving the length of the range</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.TrySetLength(System.Int32,System.Int32)">
            <summary>
            Attempt to change the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.Insert(System.Int32,System.Int32)">
            <summary>
            Inserts a range of a given length at the specified start index.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            </summary>
            <param name="start">starting index to attempt to insert the new range at</param>
            <param name="length">length of the new range. The length must be at least 1.</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.Delete(System.Int32)">
            <summary>
            Attempt to delete the range starting at the specified index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of a range to attempt to delete</param>
            <returns>true if a range was successfully deleted</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.GetLength(System.Int32)">
            <summary>
            Retrieves the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <returns>the length of the range found at the specified start index</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.SetLength(System.Int32,System.Int32)">
            <summary>
            Changes the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.GetExtent">
            <summary>
            Retrieves the extent of the sequence of ranges. The extent is the sum of the lengths of all the ranges.
            </summary>
            <returns>the extent of the ranges</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.NearestLessOrEqual(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.NearestLessOrEqual(System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.NearestLess(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.NearestLess(System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.NearestGreaterOrEqual(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.NearestGreaterOrEqual(System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.NearestGreater(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.NearestGreater(System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.AdjustLength(System.Int32,System.Int32)">
            <summary>
            Adjust the length of the range starting at 'start' by adding 'adjust' to the current length of the
            range. If the length would become 0, the range is removed.
            </summary>
            <param name="start">the start index of the range to adjust</param>
            <param name="adjust">the amount to adjust the length by. Value may be negative to shrink the length</param>
            <returns>The adjusted length</returns>
            <exception cref="T:System.ArgumentException">There is no range starting at the index specified by 'start'.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">the length would become negative</exception>
            <exception cref="T:System.OverflowException">the extent would become larger than Int32.MaxValue</exception>
        </member>
        <member name="P:TreeLib.AVLTreeRangeList.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.TreeLib#Internal#INonInvasiveRange2MapInspection#GetRanges">
            <summary>
            INonInvasiveRange2MapInspection.GetRanges() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.TreeLib#Internal#INonInvasiveRange2MapInspection#Validate">
            <summary>
            INonInvasiveRange2MapInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.GetEnumerator">
            <summary>
            Get the default enumerator, which is the fast enumerator for AVL trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator’s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator’s current key (i.e. in the portion of the
            collection the enumerator hasn’t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it’s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. The complexity of the fast enumerator
            is O(1) per element, or O(N) to enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.GetEnumerable(System.Int32)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.GetEnumerable(System.Int32,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.GetFastEnumerable(System.Int32)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.GetFastEnumerable(System.Int32,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.GetRobustEnumerable(System.Int32)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeList.GetRobustEnumerable(System.Int32,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.AVLTreeRangeList.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. However, since it uses queries it
            is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.AVLTreeRangeList.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any Add or Remove to the tree invalidates it.
            </summary>
        </member>
        <member name="T:TreeLib.AVLTreeRangeMap`1">
            <summary>
            Implements a map, list or range collection using an AVL tree. 
            </summary>
            <summary>
            Represents an sequenced collection of ranges with associated values. Each range is defined by it's length, and occupies
            a particular position in the sequence, determined by the location where it was inserted (and any insertions/deletions that
            have occurred before or after it in the sequence). The start indices of each range are determined as follows:
            The first range in the sequence starts at 0 and each subsequent range starts at the starting index of the previous range
            plus the length of the previous range. The 'extent' of the range collection is the sum of all lengths.
            All ranges must have a length of at least 1.
            </summary>
            <typeparam name="ValueType">type of the value associated with each range</typeparam>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on an AVL tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.#ctor">
            <summary>
            Create a new collection based on an AVL tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.#ctor(TreeLib.AVLTreeRangeMap{`0})">
            <summary>
            Create a new collection based on an AVL tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.AVLTreeRangeMap`1.Count">
            <summary>
            Returns the number of ranges in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue ranges.</exception>
        </member>
        <member name="P:TreeLib.AVLTreeRangeMap`1.LongCount">
            <summary>
            Returns the number of ranges in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.Clear">
            <summary>
            Removes all ranges from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.Contains(System.Int32)">
            <summary>
            Determines if there is a range in the collection starting at the specified index.
            </summary>
            <param name="start">index to look for the start of a range at</param>
            <returns>true if there is a range starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.TryInsert(System.Int32,System.Int32,`0)">
            <summary>
            Attempt to insert a range of a given length at the specified start index and with an associated value.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            </summary>
            <param name="start">starting index to attempt to insert the new range at</param>
            <param name="length">length of the new range. The length must be at least 1.</param>
            <param name="value">value to associate with the range</param>
            <returns>true if the range was successfully inserted</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.TryDelete(System.Int32)">
            <summary>
            Attempt to delete the range starting at the specified index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of a range to attempt to delete</param>
            <returns>true if a range was successfully deleted</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.TryGetLength(System.Int32,System.Int32@)">
            <summary>
            Attempt to query the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">out parameter receiving the length of the range</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.TrySetLength(System.Int32,System.Int32)">
            <summary>
            Attempt to change the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.TryGetValue(System.Int32,`0@)">
            <summary>
            Attempt to query the value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="value">value associated with the range</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.TrySetValue(System.Int32,`0)">
            <summary>
            Attempt to update the value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="value">new value that replaces the old value associated with the range</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.TryGet(System.Int32,System.Int32@,`0@)">
            <summary>
            Attempt to get the value and length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">out parameter receiving the length of the range</param>
            <param name="value">out parameter receiving the value associated with the range</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.TrySet(System.Int32,System.Int32,`0)">
            <summary>
            Attempt to change the length and value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <param name="value">the value to replace the old value associated with the range</param>
            <returns>true if a range was found starting at the specified index and updated; false if the
            start was not found or the sum of lengths would have exceeded Int32.MaxValue</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.Insert(System.Int32,System.Int32,`0)">
            <summary>
            Inserts a range of a given length at the specified start index and with an associated value.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            </summary>
            <param name="start">starting index to attempt to insert the new range at</param>
            <param name="length">length of the new range. The length must be at least 1.</param>
            <param name="value">value to associate with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.Delete(System.Int32)">
            <summary>
            Attempt to delete the range starting at the specified index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of a range to attempt to delete</param>
            <returns>true if a range was successfully deleted</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.GetLength(System.Int32)">
            <summary>
            Retrieves the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <returns>the length of the range found at the specified start index</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.SetLength(System.Int32,System.Int32)">
            <summary>
            Changes the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.GetValue(System.Int32)">
            <summary>
            Retrieves the value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <returns>the value associated with the range</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.SetValue(System.Int32,`0)">
            <summary>
            Updates the value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="value">new value that replaces the old value associated with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.Get(System.Int32,System.Int32@,`0@)">
            <summary>
            Retrieves the value and length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">out parameter receiving the length of the range</param>
            <param name="value">out parameter receiving the value associated with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.Set(System.Int32,System.Int32,`0)">
            <summary>
            Changes the length and value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <param name="value">the value to replace the old value associated with the range</param>
            <exception cref="T:System.ArgumentException">the start was not the beginning of a range</exception>
            <exception cref="T:System.OverflowException">sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.GetExtent">
            <summary>
            Retrieves the extent of the sequence of ranges. The extent is the sum of the lengths of all the ranges.
            </summary>
            <returns>the extent of the ranges</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.NearestLessOrEqual(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.NearestLessOrEqual(System.Int32,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.NearestLess(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.NearestLess(System.Int32,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.NearestGreaterOrEqual(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.NearestGreaterOrEqual(System.Int32,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.NearestGreater(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.NearestGreater(System.Int32,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.AdjustLength(System.Int32,System.Int32)">
            <summary>
            Adjust the length of the range starting at 'start' by adding 'adjust' to the current length of the
            range. If the length would become 0, the range is removed.
            </summary>
            <param name="start">the start index of the range to adjust</param>
            <param name="adjust">the amount to adjust the length by. Value may be negative to shrink the length</param>
            <returns>The adjusted length</returns>
            <exception cref="T:System.ArgumentException">There is no range starting at the index specified by 'start'.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">the length would become negative</exception>
            <exception cref="T:System.OverflowException">the extent would become larger than Int32.MaxValue</exception>
        </member>
        <member name="P:TreeLib.AVLTreeRangeMap`1.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.TreeLib#Internal#INonInvasiveRange2MapInspection#GetRanges">
            <summary>
            INonInvasiveRange2MapInspection.GetRanges() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.TreeLib#Internal#INonInvasiveRange2MapInspection#Validate">
            <summary>
            INonInvasiveRange2MapInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.GetEnumerator">
            <summary>
            Get the default enumerator, which is the fast enumerator for AVL trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator’s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator’s current key (i.e. in the portion of the
            collection the enumerator hasn’t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it’s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. The complexity of the fast enumerator
            is O(1) per element, or O(N) to enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.GetEnumerable(System.Int32)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.GetEnumerable(System.Int32,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.GetFastEnumerable(System.Int32)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.GetFastEnumerable(System.Int32,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.GetRobustEnumerable(System.Int32)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRangeMap`1.GetRobustEnumerable(System.Int32,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.AVLTreeRangeMap`1.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. However, since it uses queries it
            is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.AVLTreeRangeMap`1.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any Add or Remove to the tree invalidates it.
            </summary>
        </member>
        <member name="T:TreeLib.AVLTreeRankList`1">
            <summary>
            Implements a map, list or range collection using an AVL tree. 
            </summary>
            <summary>
            Represents an ordered key collection, augmented with rank information. The rank of a key is the index it would
            be located in if all the keys in the tree were placed into a sorted array.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.#ctor(System.Collections.Generic.IComparer{`0},System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on an AVL tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on an AVL tree, with the specified capacity and allocation mode and using
            the default comparer.
            </summary>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a new collection based on an AVL tree, with default allocation options and using the specified comparer.
            </summary>
            <param name="comparer">The comparer to use for sorting keys</param>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.#ctor">
            <summary>
            Create a new collection based on an AVL tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.#ctor(TreeLib.AVLTreeRankList{`0})">
            <summary>
            Create a new collection based on an AVL tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.AVLTreeRankList`1.Count">
            <summary>
            Returns the number of keys in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue keys.</exception>
        </member>
        <member name="P:TreeLib.AVLTreeRankList`1.LongCount">
            <summary>
            Returns the number of keys in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.Clear">
            <summary>
            Removes all keys from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.TryRemove(`0)">
            <summary>
            Attempts to remove a key from the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key was found and removed</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.TryGetKey(`0,`0@)">
            <summary>
            Attempts to get the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">the actual key contained in the collection</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.TrySetKey(`0)">
            <summary>
            Attempts to update the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.Remove(`0)">
            <summary>
            Removes a key from the collection.
            </summary>
            <param name="key">key to remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.GetKey(`0)">
            <summary>
            Retrieves the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <returns>the value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.SetKey(`0)">
            <summary>
            Updates the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.ConditionalSetOrAdd(`0,TreeLib.UpdatePredicate{`0})">
            <summary>
            Conditionally update or add a key, based on the return value from the predicate.
            ConditionalSetOrAdd is more efficient when the decision to add or update depends on the value of the item.
            </summary>
            <param name="key">The key to update or add</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the key will be added to the
            collection if it is not already in the collection. Whether true or false, if the key is in the collection, the
            ref key upon return will be used to update the key data.</param>
            <exception cref="T:System.ArgumentException">The sort order of the key was changed by the predicate</exception>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.ConditionalSetOrRemove(`0,TreeLib.UpdatePredicate{`0})">
            <summary>
            Conditionally update or add a key, based on the return value from the predicate.
            ConditionalSetOrRemove is more efficient when the decision to remove or update depends on the value of the item.
            </summary>
            <param name="key">The key to update or remove</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the key will be removed from the
            collection if it is in the collection. If the key remains in the collection, the ref key upon return will be used
            to update the key data.</param>
            <exception cref="T:System.ArgumentException">The sort order of the key was changed by the predicate</exception>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key)</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key)</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.NearestLessOrEqual(`0,`0@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.NearestLess(`0,`0@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.NearestGreaterOrEqual(`0,`0@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.NearestGreater(`0,`0@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.TryAdd(`0)">
            <summary>
            Attempts to add a key to the collection. If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <returns>true if the key was added; false if the key was already present</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.TryGet(`0,`0@,System.Int32@)">
            <summary>
            Attempts to get the actual key data and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">the actual key contained in the collection</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.TryGetKeyByRank(System.Int32,`0@)">
            <summary>
            Retrieves the key at the specified rank index.
            If all keys in the collection were converted to a sorted array, this would be the equivalent of array[rank].
            </summary>
            <param name="rank">the rank index to query</param>
            <param name="key">an out paramter receiving the key at the specified rank index</param>
            <returns>the key located at that index</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.Add(`0)">
            <summary>
            Adds a key to the collection.
            </summary>
            <param name="key">key to insert</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.Get(`0,`0@,System.Int32@)">
            <summary>
            Retrieves the actual key data and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">the actual key contained in the collection</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.GetKeyByRank(System.Int32)">
            <summary>
            Retrieves the key at the specified rank index.
            If all keys in the collection were converted to a sorted array, this would be the equivalent of array[rank].
            </summary>
            <param name="rank">the rank index to query</param>
            <returns>the key located at that index</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.AdjustCount(`0,System.Int32)">
            <summary>
            Adjusts the rank count associated with the key-value pair. The countAdjust added to the existing count.
            For a RankMap, the only valid values are 0 (which does nothing) and -1 (which removes the key-value pair).
            </summary>
            <param name="key">key identifying the key-value pair to update</param>
            <param name="countAdjust">adjustment that is added to the count</param>
            <returns>The adjusted count</returns>
            <exception cref="T:System.ArgumentException">if the count is an invalid value or the key does not exist in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="P:TreeLib.AVLTreeRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.TreeLib#Internal#INonInvasiveMultiRankMapInspection#GetRanks">
            <summary>
            INonInvasiveMultiRankMapInspection.GetRanks() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.TreeLib#Internal#INonInvasiveMultiRankMapInspection#Validate">
            <summary>
            INonInvasiveMultiRankMapInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.GetEnumerator">
            <summary>
            Get the default enumerator, which is the fast enumerator for AVL trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator’s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator’s current key (i.e. in the portion of the
            collection the enumerator hasn’t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it’s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. The complexity of the fast enumerator
            is O(1) per element, or O(N) to enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.GetEnumerable(`0)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.GetEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.GetFastEnumerable(`0)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.GetFastEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.GetRobustEnumerable(`0)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankList`1.GetRobustEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.AVLTreeRankList`1.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. However, since it uses queries it
            is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.AVLTreeRankList`1.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any Add or Remove to the tree invalidates it.
            </summary>
        </member>
        <member name="T:TreeLib.AVLTreeRankMap`2">
            <summary>
            Implements a map, list or range collection using an AVL tree. 
            </summary>
            <summary>
            Represents an ordered key-value mapping, augmented with rank information. The rank of a key-value pair is the index it would
            be located in if all the key-value pairs in the tree were placed into a sorted array.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
            <typeparam name="ValueType">Type of value associated with each entry.</typeparam>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.#ctor(System.Collections.Generic.IComparer{`0},System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on an AVL tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on an AVL tree, with the specified capacity and allocation mode and using
            the default comparer.
            </summary>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a new collection based on an AVL tree, with default allocation options and using the specified comparer.
            </summary>
            <param name="comparer">The comparer to use for sorting keys</param>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.#ctor">
            <summary>
            Create a new collection based on an AVL tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.#ctor(TreeLib.AVLTreeRankMap{`0,`1})">
            <summary>
            Create a new collection based on an AVL tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.AVLTreeRankMap`2.Count">
            <summary>
            Returns the number of key-value pairs in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue key-value pairs.</exception>
        </member>
        <member name="P:TreeLib.AVLTreeRankMap`2.LongCount">
            <summary>
            Returns the number of key-value pairs in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.Clear">
            <summary>
            Removes all key-value pairs from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.TryRemove(`0)">
            <summary>
            Attempts to remove a key-value pair from the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key-value pair was found and removed</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to get the value associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.TrySetValue(`0,`1)">
            <summary>
            Attempts to set the value associated with a key in the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <returns>true if the key-value pair was found and the value was updated</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.Remove(`0)">
            <summary>
            Removes a key-value pair from the collection.
            </summary>
            <param name="key">key of the key-value pair to remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.GetValue(`0)">
            <summary>
            Retrieves the value associated with a key in the collection
            </summary>
            <param name="key">key to search for</param>
            <returns>the value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.SetValue(`0,`1)">
            <summary>
            Updates the value associated with a key in the collection
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.ConditionalSetOrAdd(`0,TreeLib.UpdatePredicate{`0,`1})">
            <summary>
            Conditionally update or add an item, based on the return value from the predicate.
            ConditionalSetOrAdd is more efficient when the decision to add or update depends on the value of the item.
            </summary>
            <param name="key">The key of the item to update or add</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the item will be added to the
            collection if it is not already in the collection. Whether true or false, if the item is in the collection, the
            ref value upon return will be used to update the item.</param>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.ConditionalSetOrRemove(`0,TreeLib.UpdatePredicate{`0,`1})">
            <summary>
            Conditionally update or add an item, based on the return value from the predicate.
            ConditionalSetOrRemove is more efficient when the decision to remove or update depends on the value of the item.
            </summary>
            <param name="key">The key of the item to update or remove</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the item will be removed from the
            collection if it is in the collection. If the item remains in the collection, the ref value upon return will be used
            to update the item.</param>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.Least(`0@,`1@)">
            <summary>
            Retrieves the lowest in the collection (in sort order) and the value associated with it.
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.Greatest(`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection (in sort order) and the value associated with it.
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.NearestLessOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.NearestLessOrEqual(`0,`0@,`1@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key and
            the value and rank associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.NearestLess(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.NearestLess(`0,`0@,`1@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key and
            the value and rank  associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.NearestGreaterOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.NearestGreaterOrEqual(`0,`0@,`1@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key and
            the value and rank  associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.NearestGreater(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.NearestGreater(`0,`0@,`1@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key and
            the value and rank  associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.TryAdd(`0,`1)">
            <summary>
            Attempts to add a key-value pair to the collection. If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="value">value to associate with the key</param>
            <returns>true if the key-value pair was added; false if the key was already present</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.TryGet(`0,`1@,System.Int32@)">
            <summary>
            Attempts to get the value and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.TryGetKeyByRank(System.Int32,`0@)">
            <summary>
            Attempts to return the key of a key-value pair at the specified rank index.
            If all key-value pairs in the collection were converted to a sorted array, this would be the equivalent of array[rank].Key.
            </summary>
            <param name="rank">the rank index to query</param>
            <param name="key">the key located at that index</param>
            <returns>true if there is an element at the the specified index</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.Add(`0,`1)">
            <summary>
            Adds a key-value pair to the collection.
            </summary>
            <param name="key">key to insert</param>
            <param name="value">value to associate with the key</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.Get(`0,`1@,System.Int32@)">
            <summary>
            Retrieves the value and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.GetKeyByRank(System.Int32)">
            <summary>
            Retrieves the key of a key-value pair at the specified rank index.
            If all key-value pairs in the collection were converted to a sorted array, this would be the equivalent of array[rank].Key.
            </summary>
            <param name="rank">the rank index to query</param>
            <returns>the key located at that index</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.AdjustCount(`0,System.Int32)">
            <summary>
            Adjusts the rank count associated with the key-value pair. The countAdjust added to the existing count.
            For a RankMap, the only valid values are 0 (which does nothing) and -1 (which removes the key-value pair).
            </summary>
            <param name="key">key identifying the key-value pair to update</param>
            <param name="countAdjust">adjustment that is added to the count</param>
            <returns>The adjusted count</returns>
            <exception cref="T:System.ArgumentException">if the count is an invalid value or the key does not exist in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="P:TreeLib.AVLTreeRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.TreeLib#Internal#INonInvasiveMultiRankMapInspection#GetRanks">
            <summary>
            INonInvasiveMultiRankMapInspection.GetRanks() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.TreeLib#Internal#INonInvasiveMultiRankMapInspection#Validate">
            <summary>
            INonInvasiveMultiRankMapInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.GetEnumerator">
            <summary>
            Get the default enumerator, which is the fast enumerator for AVL trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator’s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator’s current key (i.e. in the portion of the
            collection the enumerator hasn’t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it’s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. The complexity of the fast enumerator
            is O(1) per element, or O(N) to enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.GetEnumerable(`0)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.GetEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.GetFastEnumerable(`0)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.GetFastEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.GetRobustEnumerable(`0)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.AVLTreeRankMap`2.GetRobustEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.AVLTreeRankMap`2.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. However, since it uses queries it
            is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.AVLTreeRankMap`2.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any Add or Remove to the tree invalidates it.
            </summary>
        </member>
        <member name="T:TreeLib.RedBlackTreeList`1">
            <summary>
            Implements a map, list or range collection using a red-black tree. 
            </summary>
            <summary>
            Represents an ordered key collection.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.#ctor(System.Collections.Generic.IComparer{`0},System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a red-black tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a red-black tree, with the specified capacity and allocation mode and using
            the default comparer.
            </summary>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a new collection based on a red-black tree, with default allocation options and using the specified comparer.
            </summary>
            <param name="comparer">The comparer to use for sorting keys</param>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.#ctor">
            <summary>
            Create a new collection based on a red-black tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.#ctor(TreeLib.RedBlackTreeList{`0})">
            <summary>
            Create a new collection based on a red-blacck tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.RedBlackTreeList`1.Count">
            <summary>
            Returns the number of keys in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue keys.</exception>
        </member>
        <member name="P:TreeLib.RedBlackTreeList`1.LongCount">
            <summary>
            Returns the number of keys in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.Clear">
            <summary>
            Removes all keys from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.TryAdd(`0)">
            <summary>
            Attempts to add a key to the collection. If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <returns>true if the key was added; false if the key was already present</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.TryRemove(`0)">
            <summary>
            Attempts to remove a key from the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key was found and removed</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.TryGetKey(`0,`0@)">
            <summary>
            Attempts to get the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">the actual key contained in the collection</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.TrySetKey(`0)">
            <summary>
            Attempts to update the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.Add(`0)">
            <summary>
            Adds a key to the collection.
            </summary>
            <param name="key">key to insert</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.Remove(`0)">
            <summary>
            Removes a key from the collection.
            </summary>
            <param name="key">key to remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.GetKey(`0)">
            <summary>
            Retrieves the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <returns>the value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.SetKey(`0)">
            <summary>
            Updates the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.ConditionalSetOrAdd(`0,TreeLib.UpdatePredicate{`0})">
            <summary>
            Conditionally update or add a key, based on the return value from the predicate.
            ConditionalSetOrAdd is more efficient when the decision to add or update depends on the value of the item.
            </summary>
            <param name="key">The key to update or add</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the key will be added to the
            collection if it is not already in the collection. Whether true or false, if the key is in the collection, the
            ref key upon return will be used to update the key data.</param>
            <exception cref="T:System.ArgumentException">The sort order of the key was changed by the predicate</exception>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.ConditionalSetOrRemove(`0,TreeLib.UpdatePredicate{`0})">
            <summary>
            Conditionally update or add a key, based on the return value from the predicate.
            ConditionalSetOrRemove is more efficient when the decision to remove or update depends on the value of the item.
            </summary>
            <param name="key">The key to update or remove</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the key will be removed from the
            collection if it is in the collection. If the key remains in the collection, the ref key upon return will be used
            to update the key data.</param>
            <exception cref="T:System.ArgumentException">The sort order of the key was changed by the predicate</exception>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key)</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key)</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="P:TreeLib.RedBlackTreeList`1.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.GetEnumerator">
            <summary>
            Get the default enumerator, which is the fast enumerator for red-black trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator’s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator’s current key (i.e. in the portion of the
            collection the enumerator hasn’t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it’s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. For red-black trees, a
            failed insertion or deletion will still invalidate the enumerator, as failed operations may still have performed
            rotations in the tree. The complexity of the fast enumerator is O(1) per element, or O(N) to enumerate the
            entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.GetEnumerable(`0)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.GetEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.GetFastEnumerable(`0)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.GetFastEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.GetRobustEnumerable(`0)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeList`1.GetRobustEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.RedBlackTreeList`1.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. However, since it uses queries it
            is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.RedBlackTreeList`1.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any Add or Remove to the tree invalidates it.
            </summary>
        </member>
        <member name="T:TreeLib.RedBlackTreeMap`2">
            <summary>
            Implements a map, list or range collection using a red-black tree. 
            </summary>
            <summary>
            Represents an ordered key-value mapping.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
            <typeparam name="ValueType">Type of value associated with each entry.</typeparam>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.#ctor(System.Collections.Generic.IComparer{`0},System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a red-black tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a red-black tree, with the specified capacity and allocation mode and using
            the default comparer.
            </summary>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a new collection based on a red-black tree, with default allocation options and using the specified comparer.
            </summary>
            <param name="comparer">The comparer to use for sorting keys</param>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.#ctor">
            <summary>
            Create a new collection based on a red-black tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.#ctor(TreeLib.RedBlackTreeMap{`0,`1})">
            <summary>
            Create a new collection based on a red-blacck tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.RedBlackTreeMap`2.Count">
            <summary>
            Returns the number of key-value pairs in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue key-value pairs.</exception>
        </member>
        <member name="P:TreeLib.RedBlackTreeMap`2.LongCount">
            <summary>
            Returns the number of key-value pairs in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.Clear">
            <summary>
            Removes all key-value pairs from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.SetOrAddValue(`0,`1)">
            <summary>
            Either set the value associated with a key (if the key is already present in the collection)
            or insert a new key-value pair into the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="value">value to associate with the key</param>
            <returns>true if key was not present and key-value pair was added; false if key-value pair was already present and value was updated</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.TryAdd(`0,`1)">
            <summary>
            Attempts to add a key-value pair to the collection. If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="value">value to associate with the key</param>
            <returns>true if the key-value pair was added; false if the key was already present</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.TryRemove(`0)">
            <summary>
            Attempts to remove a key-value pair from the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key-value pair was found and removed</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to get the value associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.TrySetValue(`0,`1)">
            <summary>
            Attempts to set the value associated with a key in the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <returns>true if the key-value pair was found and the value was updated</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.Add(`0,`1)">
            <summary>
            Adds a key-value pair to the collection.
            </summary>
            <param name="key">key to insert</param>
            <param name="value">value to associate with the key</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.Remove(`0)">
            <summary>
            Removes a key-value pair from the collection.
            </summary>
            <param name="key">key of the key-value pair to remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.GetValue(`0)">
            <summary>
            Retrieves the value associated with a key in the collection
            </summary>
            <param name="key">key to search for</param>
            <returns>the value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.SetValue(`0,`1)">
            <summary>
            Updates the value associated with a key in the collection
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.ConditionalSetOrAdd(`0,TreeLib.UpdatePredicate{`0,`1})">
            <summary>
            Conditionally update or add an item, based on the return value from the predicate.
            ConditionalSetOrAdd is more efficient when the decision to add or update depends on the value of the item.
            </summary>
            <param name="key">The key of the item to update or add</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the item will be added to the
            collection if it is not already in the collection. Whether true or false, if the item is in the collection, the
            ref value upon return will be used to update the item.</param>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.ConditionalSetOrRemove(`0,TreeLib.UpdatePredicate{`0,`1})">
            <summary>
            Conditionally update or add an item, based on the return value from the predicate.
            ConditionalSetOrRemove is more efficient when the decision to remove or update depends on the value of the item.
            </summary>
            <param name="key">The key of the item to update or remove</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the item will be removed from the
            collection if it is in the collection. If the item remains in the collection, the ref value upon return will be used
            to update the item.</param>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.Least(`0@,`1@)">
            <summary>
            Retrieves the lowest key-value pair in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.Greatest(`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.NearestLessOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.NearestLess(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.NearestGreaterOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.NearestGreater(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="P:TreeLib.RedBlackTreeMap`2.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.GetEnumerator">
            <summary>
            Get the default enumerator, which is the fast enumerator for red-black trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator’s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator’s current key (i.e. in the portion of the
            collection the enumerator hasn’t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it’s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. For red-black trees, a
            failed insertion or deletion will still invalidate the enumerator, as failed operations may still have performed
            rotations in the tree. The complexity of the fast enumerator is O(1) per element, or O(N) to enumerate the
            entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.GetEnumerable(`0)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.GetEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.GetFastEnumerable(`0)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.GetFastEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.GetRobustEnumerable(`0)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMap`2.GetRobustEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.RedBlackTreeMap`2.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. However, since it uses queries it
            is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.RedBlackTreeMap`2.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any Add or Remove to the tree invalidates it.
            </summary>
        </member>
        <member name="T:TreeLib.RedBlackTreeMultiRankList`1">
            <summary>
            Implements a map, list or range collection using a red-black tree. 
            </summary>
            <summary>
            Represents an ordered key collection, augmented with multi-rank information. The rank of a key is the index it would
            be located in if all the keys in the tree were placed into a sorted array. Each key also has a count
            associated with it, which models sorted arrays containing multiple instances of a key. It is equivalent to the number of times
            the key appears in the array. Rank index values account for such multiple occurrences. In this case, the rank
            index is the index at which the first instance of a particular key would occur in a sorted array containing all keys.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.#ctor(System.Collections.Generic.IComparer{`0},System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a red-black tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a red-black tree, with the specified capacity and allocation mode and using
            the default comparer.
            </summary>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a new collection based on a red-black tree, with default allocation options and using the specified comparer.
            </summary>
            <param name="comparer">The comparer to use for sorting keys</param>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.#ctor">
            <summary>
            Create a new collection based on a red-black tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.#ctor(TreeLib.RedBlackTreeMultiRankList{`0})">
            <summary>
            Create a new collection based on a red-blacck tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.RedBlackTreeMultiRankList`1.Count">
            <summary>
            Returns the number of keys in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue keys.</exception>
        </member>
        <member name="P:TreeLib.RedBlackTreeMultiRankList`1.LongCount">
            <summary>
            Returns the number of keys in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.Clear">
            <summary>
            Removes all keys from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.TryRemove(`0)">
            <summary>
            Attempts to remove a key from the collection. If the key is not present, no change is made to the collection.
            The entire key is removed, regardless of the rank count for it.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key was found and removed</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.TryGetKey(`0,`0@)">
            <summary>
            Attempts to get the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">the actual key contained in the collection</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.TrySetKey(`0)">
            <summary>
            Attempts to update the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.Remove(`0)">
            <summary>
            Removes a key from the collection. If the key is not present, no change is made to the collection.
            The entire key is removed, regardless of the rank count for it.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.GetKey(`0)">
            <summary>
            Retrieves the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <returns>the value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.SetKey(`0)">
            <summary>
            Updates the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.NearestLessOrEqual(`0,`0@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.NearestLess(`0,`0@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.NearestGreaterOrEqual(`0,`0@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.NearestGreater(`0,`0@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.NearestLessOrEqualByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a key's range into the start index of a key's range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the specified index is greater than or equal to the extent it will return the last key's start index.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <returns>true if a key was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.NearestLessOrEqualByRank(System.Int32,`0@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a key's range into the start index of a key's range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the specified index is greater than or equal to the extent it will return the last key's start index.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <returns>true if a key was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.NearestLessByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a key's range, the start of the previous key's range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.NearestLessByRank(System.Int32,`0@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a key's range, the start of the previous key's range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.NearestGreaterOrEqualByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range, that index will be returned.
            If the index refers to the interior index for a key's range, the start of the next key's range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than the start of the last key's range, no index will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.NearestGreaterOrEqualByRank(System.Int32,`0@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range, that index will be returned.
            If the index refers to the interior index for a key's range, the start of the next key's range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than the start of the last key's range, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.NearestGreaterByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range or is an interior index for a range, the next key's range will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than or equal to the start of the last key's range, no index will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.NearestGreaterByRank(System.Int32,`0@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest key's range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range or is an interior index for a range, the next key's range will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than or equal to the start of the last key's range, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="P:TreeLib.RedBlackTreeMultiRankList`1.RankCount">
            <summary>
            Returns the total size of an array containing all keys, where each key occurs one or more times, determined by
            the 'count' associated with each key.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.TryAdd(`0,System.Int32)">
            <summary>
            Attempts to add a key to the collection.
            If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="count">number of instances to repeat this key if the collection were converted to a sorted array</param>
            <returns>true if key was not present and key was added; false if key was already present</returns>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.TryGet(`0,`0@,System.Int32@,System.Int32@)">
            <summary>
            Attempts to get the actual key, rank index, and count associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">out parameter that returns the actual key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key</param>
            <param name="count">out parameter that returns the count, where count is the number of instances to repeat
            this key if the collection were converted to a sorted array</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.TrySet(`0,System.Int32)">
            <summary>
            Attempts to update the key data and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for and also update</param>
            <param name="rank">the new rank count</param>
            <returns>true if they key was found and the rank was a valid value or false if the rank count was not at least 1
            or the sum of counts would have exceeded Int32.MaxValue</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.TryGetKeyByRank(System.Int32,`0@)">
            <summary>
            Attempts to return the key at the specified rank index. If all keys in the collection were
            converted to a sorted array of keys, this would be the equivalent of array[rank]s, subject to the
            constraint that only the first occurrence of each key can be indexed.
            </summary>
            <param name="rank">the rank index to query; the rank must be of the first occurrence of the key in a virtual
            sorted array where each key occurs 'count' times.</param>
            <param name="key">the key located at that index</param>
            <returns>true if there is an element at the the specified index and it corresponds to the first in the virtual
            ordered sequence of multiple instances in an equivalent sorted array</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.Add(`0,System.Int32)">
            <summary>
            Adds a key to the collection with an associated count.
            If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="count">number of instances to repeat this key if the collection were converted to a sorted array</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.Get(`0,`0@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the actual key, rank index, and count associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">out parameter that returns the actual key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key</param>
            <param name="count">out parameter that returns the count, where count is the number of instances to repeat
            this key if the collection were converted to a sorted array</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.Set(`0,System.Int32)">
            <summary>
            Updates the key and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for and also update</param>
            <param name="rank">the new rank count</param>
            <exception cref="T:System.ArgumentException">the rank count was not at least 1</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.GetKeyByRank(System.Int32)">
            <summary>
            Retrieves the key at the specified rank index. If all keys in the collection were
            converted to a sorted array of keys, this would be the equivalent of array[rank], subject to the
            constraint that only the first occurrence of each key can be indexed.
            </summary>
            <param name="rank">the rank index to query; the rank must be of the first occurrence of the key in a virtual
            sorted array where each key occurs 'count' times.</param>
            <returns>the key located at that index</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.AdjustCount(`0,System.Int32)">
            <summary>
            Adjusts the rank count associated with the key. The countAdjust added to the existing count.
            If the countAdjust is equal to the negative value of the current count, the key will be removed.
            </summary>
            <param name="key">key identifying the key to update</param>
            <param name="countAdjust">adjustment that is added to the count</param>
            <returns>The adjusted count</returns>
            <exception cref="T:System.ArgumentException">if the count is an invalid value or the key does not exist in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="P:TreeLib.RedBlackTreeMultiRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.TreeLib#Internal#INonInvasiveMultiRankMapInspection#GetRanks">
            <summary>
            INonInvasiveMultiRankMapInspection.GetRanks() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.TreeLib#Internal#INonInvasiveMultiRankMapInspection#Validate">
            <summary>
            INonInvasiveMultiRankMapInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.GetEnumerator">
            <summary>
            Get the default enumerator, which is the fast enumerator for red-black trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator’s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator’s current key (i.e. in the portion of the
            collection the enumerator hasn’t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it’s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. For red-black trees, a
            failed insertion or deletion will still invalidate the enumerator, as failed operations may still have performed
            rotations in the tree. The complexity of the fast enumerator is O(1) per element, or O(N) to enumerate the
            entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.GetEnumerable(`0)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.GetEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.GetFastEnumerable(`0)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.GetFastEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.GetRobustEnumerable(`0)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankList`1.GetRobustEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.RedBlackTreeMultiRankList`1.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. However, since it uses queries it
            is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.RedBlackTreeMultiRankList`1.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any Add or Remove to the tree invalidates it.
            </summary>
        </member>
        <member name="T:TreeLib.RedBlackTreeMultiRankMap`2">
            <summary>
            Implements a map, list or range collection using a red-black tree. 
            </summary>
            <summary>
            Represents an ordered key-value mapping, augmented with multi-rank information. The rank of a key-value pair is the index it would
            be located in if all the key-value pairs in the tree were placed into a sorted array. Each key-value pair also has a count
            associated with it, which models sorted arrays containing multiple instances of a key. It is equivalent to the number of times
            the key-value pair appears in the array. Rank index values account for such multiple occurrences. In this case, the rank
            index is the index at which the first instance of a particular key would occur in a sorted array containing all keys.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
            <typeparam name="ValueType">Type of value associated with each entry.</typeparam>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.#ctor(System.Collections.Generic.IComparer{`0},System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a red-black tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a red-black tree, with the specified capacity and allocation mode and using
            the default comparer.
            </summary>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a new collection based on a red-black tree, with default allocation options and using the specified comparer.
            </summary>
            <param name="comparer">The comparer to use for sorting keys</param>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.#ctor">
            <summary>
            Create a new collection based on a red-black tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.#ctor(TreeLib.RedBlackTreeMultiRankMap{`0,`1})">
            <summary>
            Create a new collection based on a red-blacck tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.RedBlackTreeMultiRankMap`2.Count">
            <summary>
            Returns the number of key-value pairs in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue key-value pairs.</exception>
        </member>
        <member name="P:TreeLib.RedBlackTreeMultiRankMap`2.LongCount">
            <summary>
            Returns the number of key-value pairs in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.Clear">
            <summary>
            Removes all key-value pairs from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.TryRemove(`0)">
            <summary>
            Attempts to remove a key-value pair from the collection. If the key is not present, no change is made to the collection.
            The entire key-value pair is removed, regardless of the rank count for it.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key-value pair was found and removed</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to get the value associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.TrySetValue(`0,`1)">
            <summary>
            Attempts to set the value associated with a key in the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <returns>true if the key-value pair was found and the value was updated</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.Remove(`0)">
            <summary>
            Removes a key-value pair from the collection. If the key is not present, no change is made to the collection.
            The entire key-value pair is removed, regardless of the rank count for it.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.GetValue(`0)">
            <summary>
            Retrieves the value associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <returns>value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.SetValue(`0,`1)">
            <summary>
            Updates the value associated with a key in the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.Least(`0@,`1@)">
            <summary>
            Retrieves the lowest key-value pair in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.Greatest(`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.NearestLessOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.NearestLessOrEqual(`0,`0@,`1@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key and
            the value, rank and count associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.NearestLess(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.NearestLess(`0,`0@,`1@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key and
            the value, rank and count  associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.NearestGreaterOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.NearestGreaterOrEqual(`0,`0@,`1@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key and
            the value, rank and count  associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.NearestGreater(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.NearestGreater(`0,`0@,`1@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key and
            the value, rank and count  associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.NearestLessOrEqualByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a key's range into the start index of a key's range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the specified index is greater than or equal to the extent it will return the last key's start index.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <returns>true if a key was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.NearestLessOrEqualByRank(System.Int32,`0@,System.Int32@,System.Int32@,`1@)">
            <summary>
            Search for the nearest key's index that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a key's range into the start index of a key's range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the specified index is greater than or equal to the extent it will return the last key's start index.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <param name="value">the value associated with the key</param>
            <returns>true if a key was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.NearestLessByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a key's range, the start of the previous key's range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.NearestLessByRank(System.Int32,`0@,System.Int32@,System.Int32@,`1@)">
            <summary>
            Search for the nearest key's index that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a key's range, the start of the previous key's range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <param name="value">the value associated with the key</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.NearestGreaterOrEqualByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range, that index will be returned.
            If the index refers to the interior index for a key's range, the start of the next key's range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than the start of the last key's range, no index will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.NearestGreaterOrEqualByRank(System.Int32,`0@,System.Int32@,System.Int32@,`1@)">
            <summary>
            Search for the nearest key's index that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range, that index will be returned.
            If the index refers to the interior index for a key's range, the start of the next key's range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than the start of the last key's range, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <param name="value">the value associated with the key</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.NearestGreaterByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range or is an interior index for a range, the next key's range will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than or equal to the start of the last key's range, no index will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.NearestGreaterByRank(System.Int32,`0@,System.Int32@,System.Int32@,`1@)">
            <summary>
            Search for the nearest key's range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range or is an interior index for a range, the next key's range will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than or equal to the start of the last key's range, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <param name="value">the value associated with the key</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="P:TreeLib.RedBlackTreeMultiRankMap`2.RankCount">
            <summary>
            Returns the total size of an array containing all key-value pairs, where each key occurs one or more times, determined by
            the 'count' associated with each key-value pair.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.TryAdd(`0,`1,System.Int32)">
            <summary>
            Attempts to add a key to the collection with an associated value and count.
            If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="value">value to associate with the key</param>
            <param name="count">number of instances to repeat this key-value pair if the collection were converted to a sorted array</param>
            <returns>true if key was not present and key-value pair was added; false if key-value pair was already present and value was updated</returns>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.TryGet(`0,`1@,System.Int32@,System.Int32@)">
            <summary>
            Attempts to get the value, rank index, and count associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <param name="count">out parameter that returns the count, where count is the number of instances to repeat
            this key-value pair if the collection were converted to a sorted array</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.TrySet(`0,`1,System.Int32)">
            <summary>
            Attempts to update the value and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">the new value to set</param>
            <param name="rank">the new rank count</param>
            <returns>true if they key was found and the rank was a valid value or false if the rank count was not at least 1
            or the sum of counts would have exceeded Int32.MaxValue</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.TryGetKeyByRank(System.Int32,`0@)">
            <summary>
            Attempts to return the key of a key-value pair at the specified rank index. If all key-value pairs in the collection were
            converted to a sorted array of key-value pairs, this would be the equivalent of array[rank].Key, subject to the
            constraint that only the first occurrence of each key can be indexed.
            </summary>
            <param name="rank">the rank index to query; the rank must be of the first occurrence of the key in a virtual
            sorted array where each key occurs 'count' times.</param>
            <param name="key">the key located at that index</param>
            <returns>true if there is an element at the the specified index and it corresponds to the first in the virtual
            ordered sequence of multiple instances in an equivalent sorted array</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.Add(`0,`1,System.Int32)">
            <summary>
            Adds a key to the collection with an associated value and count.
            If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="value">value to associate with the key</param>
            <param name="count">number of instances to repeat this key-value pair if the collection were converted to a sorted array</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.Get(`0,`1@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the value, rank index, and count associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <param name="count">out parameter that returns the count, where count is the number of instances to repeat
            this key-value pair if the collection were converted to a sorted array</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.Set(`0,`1,System.Int32)">
            <summary>
            Updates the value and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">the new value to set</param>
            <param name="rank">the new rank count</param>
            <exception cref="T:System.ArgumentException">the rank count was not at least 1</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.GetKeyByRank(System.Int32)">
            <summary>
            Retrieves the key of a key-value pair at the specified rank index. If all key-value pairs in the collection were
            converted to a sorted array of key-value pairs, this would be the equivalent of array[rank].Key, subject to the
            constraint that only the first occurrence of each key can be indexed.
            </summary>
            <param name="rank">the rank index to query; the rank must be of the first occurrence of the key in a virtual
            sorted array where each key occurs 'count' times.</param>
            <returns>the key located at that index</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.AdjustCount(`0,System.Int32)">
            <summary>
            Adjusts the rank count associated with the key-value pair. The countAdjust added to the existing count.
            If the countAdjust is equal to the negative value of the current count, the key-value pair will be removed.
            </summary>
            <param name="key">key identifying the key-value pair to update</param>
            <param name="countAdjust">adjustment that is added to the count</param>
            <returns>The adjusted count</returns>
            <exception cref="T:System.ArgumentException">if the count is an invalid value or the key does not exist in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="P:TreeLib.RedBlackTreeMultiRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.TreeLib#Internal#INonInvasiveMultiRankMapInspection#GetRanks">
            <summary>
            INonInvasiveMultiRankMapInspection.GetRanks() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.TreeLib#Internal#INonInvasiveMultiRankMapInspection#Validate">
            <summary>
            INonInvasiveMultiRankMapInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.GetEnumerator">
            <summary>
            Get the default enumerator, which is the fast enumerator for red-black trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator’s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator’s current key (i.e. in the portion of the
            collection the enumerator hasn’t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it’s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. For red-black trees, a
            failed insertion or deletion will still invalidate the enumerator, as failed operations may still have performed
            rotations in the tree. The complexity of the fast enumerator is O(1) per element, or O(N) to enumerate the
            entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.GetEnumerable(`0)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.GetEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.GetFastEnumerable(`0)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.GetFastEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.GetRobustEnumerable(`0)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeMultiRankMap`2.GetRobustEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.RedBlackTreeMultiRankMap`2.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. However, since it uses queries it
            is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.RedBlackTreeMultiRankMap`2.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any Add or Remove to the tree invalidates it.
            </summary>
        </member>
        <member name="T:TreeLib.RedBlackTreeRange2List">
            <summary>
            Implements a map, list or range collection using a red-black tree. 
            </summary>
            <summary>
            Represents an sequenced collection of range-to-range pairs (without associated values). Each range pair is defined by two lengths,
            one for the X sequence and one for the Y sequence.
            With regard to a particular sequence, each range occupies a particular position in the sequence, determined by the location
            where it was inserted (and any insertions/deletions that have occurred before or after it in the sequence).
            Within the sequence, the start indices of each range are determined as follows:
            The first range in the sequence starts at 0 and each subsequent range starts at the starting index of the previous range
            plus the length of the previous range. The 'extent' of the range collection is the sum of all lengths.
            The above applies separately to both the X side sequence and the Y side sequence.
            All ranges must have a lengths of at least 1, on both sides.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a red-black tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.#ctor">
            <summary>
            Create a new collection based on a red-black tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.#ctor(TreeLib.RedBlackTreeRange2List)">
            <summary>
            Create a new collection based on a red-blacck tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.RedBlackTreeRange2List.Count">
            <summary>
            Returns the number of range pairs in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue range pairs.</exception>
        </member>
        <member name="P:TreeLib.RedBlackTreeRange2List.LongCount">
            <summary>
            Returns the number of ranges in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.Clear">
            <summary>
            Removes all range pairs from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.Contains(System.Int32,TreeLib.Side)">
            <summary>
            Determines if there is a range pair in the collection starting at the index specified, with respect to the side specified.
            </summary>
            <param name="start">index to look for the start of a range at</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <returns>true if there is a range starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.TryInsert(System.Int32,TreeLib.Side,System.Int32,System.Int32)">
            <summary>
            Attempt to insert a range pair defined by the given pair of lengths at the specified start index with respect to
            the specified side.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            The sequence of the non-specified side is also updated, by inserting the other length of the pair at the same
            rank in the sequence as on the specified side.
            </summary>
            <param name="start">the specified start index to insert before</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <param name="xLength">the length of the X side of the range pair. the length must be at least 1.</param>
            <param name="yLength">the length of the Y side of the range pair. the length must be at least 1.</param>
            <returns>true if the range was successfully inserted</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue on either side</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.TryDelete(System.Int32,TreeLib.Side)">
            <summary>
            Attempt to delete the range pair starting at the specified index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to delete</param>
            <param name="side">the side (X or Y) to which the start index applies</param>
            <returns>true if a range pair was successfully deleted</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.TryGetLength(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Attempt to query the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies. The side also determines which length is returned</param>
            <param name="length">the length of the range from the specified side (X or Y)</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.TrySetLength(System.Int32,TreeLib.Side,System.Int32)">
            <summary>
            Attempt to change the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to modify</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="length">the new length to apply on the specified side (X or Y) of the range pair. The new length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.OverflowException">the sum of lengths on the specified side would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.TryGet(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Attempt to get the lengths associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="otherStart">out parameter receiving the start index of the range from the opposite side of that specified</param>
            <param name="xLength">out parameter receiving the length of the range on the X side</param>
            <param name="yLength">out parameter receiving the length f the range on the Y side</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.TrySet(System.Int32,TreeLib.Side,System.Int32,System.Int32)">
            <summary>
            Attempt to change the lengths associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="side">the side with which the start parameter applies</param>
            <param name="xLength">new X-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="yLength">new Y-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <returns>true if a range was found starting at the specified index and updated; false if the
            start was not found or the sum of lengths would have exceeded Int32.MaxValue</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.Insert(System.Int32,TreeLib.Side,System.Int32,System.Int32)">
            <summary>
            Insert a range pair defined by the given pair of lengths at the specified start index with respect to
            the specified side.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            The sequence of the non-specified side is also updated, by inserting the other length of the pair at the same
            rank in the sequence as on the specified side.
            </summary>
            <param name="start">the specified start index to insert before</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <param name="xLength">the length of the X side of the range pair. the length must be at least 1.</param>
            <param name="yLength">the length of the Y side of the range pair. the length must be at least 1.</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue on either side</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.Delete(System.Int32,TreeLib.Side)">
            <summary>
            Deletes the range pair starting at the specified index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to delete</param>
            <param name="side">the side (X or Y) to which the start index applies</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.GetLength(System.Int32,TreeLib.Side)">
            <summary>
            Retrieves the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies. The side also determines which length is returned</param>
            <returns>the length of the range from the specified side (X or Y)</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.SetLength(System.Int32,TreeLib.Side,System.Int32)">
            <summary>
            Changes the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to modify</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="length">the new length to apply on the specified side (X or Y) of the range pair. The new length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
            <exception cref="T:System.OverflowException">the sum of lengths on the specified side would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.Get(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Attempt to get the lengths associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="otherStart">out parameter receiving the start index of the range from the opposite side of that specified</param>
            <param name="xLength">out parameter receiving the length of the range on the X side</param>
            <param name="yLength">out parameter receiving the length f the range on the Y side</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.Set(System.Int32,TreeLib.Side,System.Int32,System.Int32)">
            <summary>
            Changes the lengths associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="side">the side with which the start parameter applies</param>
            <param name="xLength">new X-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="yLength">new Y-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <returns>true if a range was found starting at the specified index and updated; false if the
            start was not found or the sum of lengths would have exceeded Int32.MaxValue</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.GetExtent(TreeLib.Side)">
            <summary>
            Retrieves the extent of the sequence of ranges on the specified side. The extent is the sum of the lengths of all the ranges.
            </summary>
            <param name="side">the side (X or Y) to which the query applies.</param>
            <returns>the extent of the ranges on the specified side</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.NearestLessOrEqual(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index with respect to the specified side.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.NearestLessOrEqual(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index with respect to the specified side.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.NearestLess(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.NearestLess(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.NearestGreaterOrEqual(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.NearestGreaterOrEqual(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.NearestGreater(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.NearestGreater(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.AdjustLength(System.Int32,TreeLib.Side,System.Int32,System.Int32)">
            <summary>
            Adjust the lengths of the range starting at 'start' by adding xAdjust and yAdjust to the current lengths of the
            range. If the lengths would become 0, the range is removed.
            </summary>
            <param name="start">the start index of the range to adjust</param>
            <param name="side">which side (X or Y) the start parameter applies</param>
            <param name="xAdjust">the amount to adjust the X length by. Value may be negative to shrink the length</param>
            <param name="yAdjust">the amount to adjust the Y length by. Value may be negative to shrink the length</param>
            <returns>The adjusted length</returns>
            <exception cref="T:System.ArgumentException">There is no range starting at the index specified by 'start', or the length on
            one side would become 0 while the length on the other side would not be 0.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">one or both of the lengths would become negative</exception>
            <exception cref="T:System.OverflowException">the X or Y extent would become larger than Int32.MaxValue</exception>
        </member>
        <member name="P:TreeLib.RedBlackTreeRange2List.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.TreeLib#Internal#INonInvasiveRange2MapInspection#GetRanges">
            <summary>
            INonInvasiveRange2MapInspection.GetRanges() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.TreeLib#Internal#INonInvasiveRange2MapInspection#Validate">
            <summary>
            INonInvasiveRange2MapInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.GetEnumerator">
            <summary>
            Get the default enumerator, which is the fast enumerator for red-black trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator’s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator’s current key (i.e. in the portion of the
            collection the enumerator hasn’t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it’s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. For red-black trees, a
            failed insertion or deletion will still invalidate the enumerator, as failed operations may still have performed
            rotations in the tree. The complexity of the fast enumerator is O(1) per element, or O(N) to enumerate the
            entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.GetEnumerable(System.Int32,TreeLib.Side)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.GetEnumerable(System.Int32,TreeLib.Side,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.GetFastEnumerable(System.Int32,TreeLib.Side)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.GetFastEnumerable(System.Int32,TreeLib.Side,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.GetRobustEnumerable(System.Int32,TreeLib.Side)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2List.GetRobustEnumerable(System.Int32,TreeLib.Side,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.RedBlackTreeRange2List.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. However, since it uses queries it
            is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.RedBlackTreeRange2List.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any Add or Remove to the tree invalidates it.
            </summary>
        </member>
        <member name="T:TreeLib.RedBlackTreeRange2Map`1">
            <summary>
            Implements a map, list or range collection using a red-black tree. 
            </summary>
            <summary>
            Represents an sequenced collection of range-to-range pairs with associated values. Each range pair is defined by two lengths,
            one for the X sequence and one for the Y sequence.
            With regard to a particular sequence, each range occupies a particular position in the sequence, determined by the location
            where it was inserted (and any insertions/deletions that have occurred before or after it in the sequence).
            Within the sequence, the start indices of each range are determined as follows:
            The first range in the sequence starts at 0 and each subsequent range starts at the starting index of the previous range
            plus the length of the previous range. The 'extent' of the range collection is the sum of all lengths.
            The above applies separately to both the X side sequence and the Y side sequence.
            All ranges must have a lengths of at least 1, on both sides.
            </summary>
            <typeparam name="ValueType">type of the value associated with each range pair</typeparam>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a red-black tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.#ctor">
            <summary>
            Create a new collection based on a red-black tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.#ctor(TreeLib.RedBlackTreeRange2Map{`0})">
            <summary>
            Create a new collection based on a red-blacck tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.RedBlackTreeRange2Map`1.Count">
            <summary>
            Returns the number of range pairs in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue range pairs.</exception>
        </member>
        <member name="P:TreeLib.RedBlackTreeRange2Map`1.LongCount">
            <summary>
            Returns the number of ranges in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.Clear">
            <summary>
            Removes all range pairs from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.Contains(System.Int32,TreeLib.Side)">
            <summary>
            Determines if there is a range pair in the collection starting at the index specified, with respect to the side specified.
            </summary>
            <param name="start">index to look for the start of a range at</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <returns>true if there is a range starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.TryInsert(System.Int32,TreeLib.Side,System.Int32,System.Int32,`0)">
            <summary>
            Attempt to insert a range pair defined by the given pair of lengths at the specified start index with respect to
            the specified side and with an associated value.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            The sequence of the non-specified side is also updated, by inserting the other length of the pair at the same
            rank in the sequence as on the specified side.
            </summary>
            <param name="start">the specified start index to insert before</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <param name="xLength">the length of the X side of the range pair. the length must be at least 1.</param>
            <param name="yLength">the length of the Y side of the range pair. the length must be at least 1.</param>
            <param name="value">the value to associate with the range pair</param>
            <returns>true if the range was successfully inserted</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue on either side</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.TryDelete(System.Int32,TreeLib.Side)">
            <summary>
            Attempt to delete the range pair starting at the specified index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to delete</param>
            <param name="side">the side (X or Y) to which the start index applies</param>
            <returns>true if a range pair was successfully deleted</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.TryGetLength(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Attempt to query the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies. The side also determines which length is returned</param>
            <param name="length">the length of the range from the specified side (X or Y)</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.TrySetLength(System.Int32,TreeLib.Side,System.Int32)">
            <summary>
            Attempt to change the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to modify</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="length">the new length to apply on the specified side (X or Y) of the range pair. The new length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.OverflowException">the sum of lengths on the specified side would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.TryGetValue(System.Int32,TreeLib.Side,`0@)">
            <summary>
            Attempt to query the value associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="value">value associated with the range</param>
            <returns>true if a range was found starting at the specified index on the specified side</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.TrySetValue(System.Int32,TreeLib.Side,`0)">
            <summary>
            Attempt to update the value associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to update</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="value">new value that replaces the old value associated with the range</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.TryGet(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,`0@)">
            <summary>
            Attempt to get the value and lengths associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="otherStart">out parameter receiving the start index of the range from the opposite side of that specified</param>
            <param name="xLength">out parameter receiving the length of the range on the X side</param>
            <param name="yLength">out parameter receiving the length f the range on the Y side</param>
            <param name="value">out parameter receiving the value associated with the range</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.TrySet(System.Int32,TreeLib.Side,System.Int32,System.Int32,`0)">
            <summary>
            Attempt to change the lengths and value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="side">the side with which the start parameter applies</param>
            <param name="xLength">new X-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="yLength">new Y-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="value">the value to replace the old value associated with the range</param>
            <returns>true if a range was found starting at the specified index and updated; false if the
            start was not found or the sum of lengths would have exceeded Int32.MaxValue</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.Insert(System.Int32,TreeLib.Side,System.Int32,System.Int32,`0)">
            <summary>
            Insert a range pair defined by the given pair of lengths at the specified start index with respect to
            the specified side and with an associated value.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            The sequence of the non-specified side is also updated, by inserting the other length of the pair at the same
            rank in the sequence as on the specified side.
            </summary>
            <param name="start">the specified start index to insert before</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <param name="xLength">the length of the X side of the range pair. the length must be at least 1.</param>
            <param name="yLength">the length of the Y side of the range pair. the length must be at least 1.</param>
            <param name="value">the value to associate with the range pair</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue on either side</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.Delete(System.Int32,TreeLib.Side)">
            <summary>
            Deletes the range pair starting at the specified index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to delete</param>
            <param name="side">the side (X or Y) to which the start index applies</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.GetLength(System.Int32,TreeLib.Side)">
            <summary>
            Retrieves the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies. The side also determines which length is returned</param>
            <returns>the length of the range from the specified side (X or Y)</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.SetLength(System.Int32,TreeLib.Side,System.Int32)">
            <summary>
            Changes the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to modify</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="length">the new length to apply on the specified side (X or Y) of the range pair. The new length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
            <exception cref="T:System.OverflowException">the sum of lengths on the specified side would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.GetValue(System.Int32,TreeLib.Side)">
            <summary>
            Retrieves the value associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <returns>the value associated with the range</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.SetValue(System.Int32,TreeLib.Side,`0)">
            <summary>
            Updates the value associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to update</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="value">new value that replaces the old value associated with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.Get(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,`0@)">
            <summary>
            Attempt to get the value and lengths associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="otherStart">out parameter receiving the start index of the range from the opposite side of that specified</param>
            <param name="xLength">out parameter receiving the length of the range on the X side</param>
            <param name="yLength">out parameter receiving the length f the range on the Y side</param>
            <param name="value">out parameter receiving the value associated with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.Set(System.Int32,TreeLib.Side,System.Int32,System.Int32,`0)">
            <summary>
            Changes the lengths and value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="side">the side with which the start parameter applies</param>
            <param name="xLength">new X-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="yLength">new Y-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="value">the value to replace the old value associated with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
            <exception cref="T:System.OverflowException">sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.GetExtent(TreeLib.Side)">
            <summary>
            Retrieves the extent of the sequence of ranges on the specified side. The extent is the sum of the lengths of all the ranges.
            </summary>
            <param name="side">the side (X or Y) to which the query applies.</param>
            <returns>the extent of the ranges on the specified side</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.NearestLessOrEqual(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index with respect to the specified side.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.NearestLessOrEqual(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index with respect to the specified side.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.NearestLess(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.NearestLess(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.NearestGreaterOrEqual(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.NearestGreaterOrEqual(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.NearestGreater(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.NearestGreater(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.AdjustLength(System.Int32,TreeLib.Side,System.Int32,System.Int32)">
            <summary>
            Adjust the lengths of the range starting at 'start' by adding xAdjust and yAdjust to the current lengths of the
            range. If the lengths would become 0, the range is removed.
            </summary>
            <param name="start">the start index of the range to adjust</param>
            <param name="side">which side (X or Y) the start parameter applies</param>
            <param name="xAdjust">the amount to adjust the X length by. Value may be negative to shrink the length</param>
            <param name="yAdjust">the amount to adjust the Y length by. Value may be negative to shrink the length</param>
            <returns>The adjusted length</returns>
            <exception cref="T:System.ArgumentException">There is no range starting at the index specified by 'start', or the length on
            one side would become 0 while the length on the other side would not be 0.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">one or both of the lengths would become negative</exception>
            <exception cref="T:System.OverflowException">the X or Y extent would become larger than Int32.MaxValue</exception>
        </member>
        <member name="P:TreeLib.RedBlackTreeRange2Map`1.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.TreeLib#Internal#INonInvasiveRange2MapInspection#GetRanges">
            <summary>
            INonInvasiveRange2MapInspection.GetRanges() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.TreeLib#Internal#INonInvasiveRange2MapInspection#Validate">
            <summary>
            INonInvasiveRange2MapInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.GetEnumerator">
            <summary>
            Get the default enumerator, which is the fast enumerator for red-black trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator’s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator’s current key (i.e. in the portion of the
            collection the enumerator hasn’t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it’s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. For red-black trees, a
            failed insertion or deletion will still invalidate the enumerator, as failed operations may still have performed
            rotations in the tree. The complexity of the fast enumerator is O(1) per element, or O(N) to enumerate the
            entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.GetEnumerable(System.Int32,TreeLib.Side)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.GetEnumerable(System.Int32,TreeLib.Side,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.GetFastEnumerable(System.Int32,TreeLib.Side)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.GetFastEnumerable(System.Int32,TreeLib.Side,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.GetRobustEnumerable(System.Int32,TreeLib.Side)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRange2Map`1.GetRobustEnumerable(System.Int32,TreeLib.Side,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.RedBlackTreeRange2Map`1.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. However, since it uses queries it
            is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.RedBlackTreeRange2Map`1.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any Add or Remove to the tree invalidates it.
            </summary>
        </member>
        <member name="T:TreeLib.RedBlackTreeRangeList">
            <summary>
            Implements a map, list or range collection using a red-black tree. 
            </summary>
            <summary>
            Represents an sequenced collection of ranges (without associated values). Each range is defined by it's length, and occupies
            a particular position in the sequence, determined by the location where it was inserted (and any insertions/deletions that
            have occurred before or after it in the sequence). The start indices of each range are determined as follows:
            The first range in the sequence starts at 0 and each subsequent range starts at the starting index of the previous range
            plus the length of the previous range. The 'extent' of the range collection is the sum of all lengths.
            All ranges must have a length of at least 1.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a red-black tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.#ctor">
            <summary>
            Create a new collection based on a red-black tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.#ctor(TreeLib.RedBlackTreeRangeList)">
            <summary>
            Create a new collection based on a red-blacck tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.RedBlackTreeRangeList.Count">
            <summary>
            Returns the number of ranges in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue ranges.</exception>
        </member>
        <member name="P:TreeLib.RedBlackTreeRangeList.LongCount">
            <summary>
            Returns the number of ranges in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.Clear">
            <summary>
            Removes all ranges from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.Contains(System.Int32)">
            <summary>
            Determines if there is a range in the collection starting at the specified index.
            </summary>
            <param name="start">index to look for the start of a range at</param>
            <returns>true if there is a range starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.TryInsert(System.Int32,System.Int32)">
            <summary>
            Attempt to insert a range of a given length at the specified start index.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            </summary>
            <param name="start">starting index to attempt to insert the new range at</param>
            <param name="length">length of the new range. The length must be at least 1.</param>
            <returns>true if the range was successfully inserted</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.TryDelete(System.Int32)">
            <summary>
            Attempt to delete the range starting at the specified index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of a range to attempt to delete</param>
            <returns>true if a range was successfully deleted</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.TryGetLength(System.Int32,System.Int32@)">
            <summary>
            Attempt to query the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">out parameter receiving the length of the range</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.TrySetLength(System.Int32,System.Int32)">
            <summary>
            Attempt to change the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.Insert(System.Int32,System.Int32)">
            <summary>
            Inserts a range of a given length at the specified start index.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            </summary>
            <param name="start">starting index to attempt to insert the new range at</param>
            <param name="length">length of the new range. The length must be at least 1.</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.Delete(System.Int32)">
            <summary>
            Attempt to delete the range starting at the specified index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of a range to attempt to delete</param>
            <returns>true if a range was successfully deleted</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.GetLength(System.Int32)">
            <summary>
            Retrieves the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <returns>the length of the range found at the specified start index</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.SetLength(System.Int32,System.Int32)">
            <summary>
            Changes the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.GetExtent">
            <summary>
            Retrieves the extent of the sequence of ranges. The extent is the sum of the lengths of all the ranges.
            </summary>
            <returns>the extent of the ranges</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.NearestLessOrEqual(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.NearestLessOrEqual(System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.NearestLess(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.NearestLess(System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.NearestGreaterOrEqual(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.NearestGreaterOrEqual(System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.NearestGreater(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.NearestGreater(System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.AdjustLength(System.Int32,System.Int32)">
            <summary>
            Adjust the length of the range starting at 'start' by adding 'adjust' to the current length of the
            range. If the length would become 0, the range is removed.
            </summary>
            <param name="start">the start index of the range to adjust</param>
            <param name="adjust">the amount to adjust the length by. Value may be negative to shrink the length</param>
            <returns>The adjusted length</returns>
            <exception cref="T:System.ArgumentException">There is no range starting at the index specified by 'start'.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">the length would become negative</exception>
            <exception cref="T:System.OverflowException">the extent would become larger than Int32.MaxValue</exception>
        </member>
        <member name="P:TreeLib.RedBlackTreeRangeList.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.TreeLib#Internal#INonInvasiveRange2MapInspection#GetRanges">
            <summary>
            INonInvasiveRange2MapInspection.GetRanges() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.TreeLib#Internal#INonInvasiveRange2MapInspection#Validate">
            <summary>
            INonInvasiveRange2MapInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.GetEnumerator">
            <summary>
            Get the default enumerator, which is the fast enumerator for red-black trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator’s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator’s current key (i.e. in the portion of the
            collection the enumerator hasn’t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it’s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. For red-black trees, a
            failed insertion or deletion will still invalidate the enumerator, as failed operations may still have performed
            rotations in the tree. The complexity of the fast enumerator is O(1) per element, or O(N) to enumerate the
            entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.GetEnumerable(System.Int32)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.GetEnumerable(System.Int32,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.GetFastEnumerable(System.Int32)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.GetFastEnumerable(System.Int32,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.GetRobustEnumerable(System.Int32)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeList.GetRobustEnumerable(System.Int32,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.RedBlackTreeRangeList.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. However, since it uses queries it
            is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.RedBlackTreeRangeList.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any Add or Remove to the tree invalidates it.
            </summary>
        </member>
        <member name="T:TreeLib.RedBlackTreeRangeMap`1">
            <summary>
            Implements a map, list or range collection using a red-black tree. 
            </summary>
            <summary>
            Represents an sequenced collection of ranges with associated values. Each range is defined by it's length, and occupies
            a particular position in the sequence, determined by the location where it was inserted (and any insertions/deletions that
            have occurred before or after it in the sequence). The start indices of each range are determined as follows:
            The first range in the sequence starts at 0 and each subsequent range starts at the starting index of the previous range
            plus the length of the previous range. The 'extent' of the range collection is the sum of all lengths.
            All ranges must have a length of at least 1.
            </summary>
            <typeparam name="ValueType">type of the value associated with each range</typeparam>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a red-black tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.#ctor">
            <summary>
            Create a new collection based on a red-black tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.#ctor(TreeLib.RedBlackTreeRangeMap{`0})">
            <summary>
            Create a new collection based on a red-blacck tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.RedBlackTreeRangeMap`1.Count">
            <summary>
            Returns the number of ranges in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue ranges.</exception>
        </member>
        <member name="P:TreeLib.RedBlackTreeRangeMap`1.LongCount">
            <summary>
            Returns the number of ranges in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.Clear">
            <summary>
            Removes all ranges from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.Contains(System.Int32)">
            <summary>
            Determines if there is a range in the collection starting at the specified index.
            </summary>
            <param name="start">index to look for the start of a range at</param>
            <returns>true if there is a range starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.TryInsert(System.Int32,System.Int32,`0)">
            <summary>
            Attempt to insert a range of a given length at the specified start index and with an associated value.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            </summary>
            <param name="start">starting index to attempt to insert the new range at</param>
            <param name="length">length of the new range. The length must be at least 1.</param>
            <param name="value">value to associate with the range</param>
            <returns>true if the range was successfully inserted</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.TryDelete(System.Int32)">
            <summary>
            Attempt to delete the range starting at the specified index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of a range to attempt to delete</param>
            <returns>true if a range was successfully deleted</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.TryGetLength(System.Int32,System.Int32@)">
            <summary>
            Attempt to query the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">out parameter receiving the length of the range</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.TrySetLength(System.Int32,System.Int32)">
            <summary>
            Attempt to change the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.TryGetValue(System.Int32,`0@)">
            <summary>
            Attempt to query the value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="value">value associated with the range</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.TrySetValue(System.Int32,`0)">
            <summary>
            Attempt to update the value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="value">new value that replaces the old value associated with the range</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.TryGet(System.Int32,System.Int32@,`0@)">
            <summary>
            Attempt to get the value and length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">out parameter receiving the length of the range</param>
            <param name="value">out parameter receiving the value associated with the range</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.TrySet(System.Int32,System.Int32,`0)">
            <summary>
            Attempt to change the length and value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <param name="value">the value to replace the old value associated with the range</param>
            <returns>true if a range was found starting at the specified index and updated; false if the
            start was not found or the sum of lengths would have exceeded Int32.MaxValue</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.Insert(System.Int32,System.Int32,`0)">
            <summary>
            Inserts a range of a given length at the specified start index and with an associated value.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            </summary>
            <param name="start">starting index to attempt to insert the new range at</param>
            <param name="length">length of the new range. The length must be at least 1.</param>
            <param name="value">value to associate with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.Delete(System.Int32)">
            <summary>
            Attempt to delete the range starting at the specified index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of a range to attempt to delete</param>
            <returns>true if a range was successfully deleted</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.GetLength(System.Int32)">
            <summary>
            Retrieves the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <returns>the length of the range found at the specified start index</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.SetLength(System.Int32,System.Int32)">
            <summary>
            Changes the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.GetValue(System.Int32)">
            <summary>
            Retrieves the value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <returns>the value associated with the range</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.SetValue(System.Int32,`0)">
            <summary>
            Updates the value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="value">new value that replaces the old value associated with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.Get(System.Int32,System.Int32@,`0@)">
            <summary>
            Retrieves the value and length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">out parameter receiving the length of the range</param>
            <param name="value">out parameter receiving the value associated with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.Set(System.Int32,System.Int32,`0)">
            <summary>
            Changes the length and value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <param name="value">the value to replace the old value associated with the range</param>
            <exception cref="T:System.ArgumentException">the start was not the beginning of a range</exception>
            <exception cref="T:System.OverflowException">sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.GetExtent">
            <summary>
            Retrieves the extent of the sequence of ranges. The extent is the sum of the lengths of all the ranges.
            </summary>
            <returns>the extent of the ranges</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.NearestLessOrEqual(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.NearestLessOrEqual(System.Int32,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.NearestLess(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.NearestLess(System.Int32,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.NearestGreaterOrEqual(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.NearestGreaterOrEqual(System.Int32,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.NearestGreater(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.NearestGreater(System.Int32,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.AdjustLength(System.Int32,System.Int32)">
            <summary>
            Adjust the length of the range starting at 'start' by adding 'adjust' to the current length of the
            range. If the length would become 0, the range is removed.
            </summary>
            <param name="start">the start index of the range to adjust</param>
            <param name="adjust">the amount to adjust the length by. Value may be negative to shrink the length</param>
            <returns>The adjusted length</returns>
            <exception cref="T:System.ArgumentException">There is no range starting at the index specified by 'start'.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">the length would become negative</exception>
            <exception cref="T:System.OverflowException">the extent would become larger than Int32.MaxValue</exception>
        </member>
        <member name="P:TreeLib.RedBlackTreeRangeMap`1.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.TreeLib#Internal#INonInvasiveRange2MapInspection#GetRanges">
            <summary>
            INonInvasiveRange2MapInspection.GetRanges() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.TreeLib#Internal#INonInvasiveRange2MapInspection#Validate">
            <summary>
            INonInvasiveRange2MapInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.GetEnumerator">
            <summary>
            Get the default enumerator, which is the fast enumerator for red-black trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator’s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator’s current key (i.e. in the portion of the
            collection the enumerator hasn’t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it’s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. For red-black trees, a
            failed insertion or deletion will still invalidate the enumerator, as failed operations may still have performed
            rotations in the tree. The complexity of the fast enumerator is O(1) per element, or O(N) to enumerate the
            entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.GetEnumerable(System.Int32)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.GetEnumerable(System.Int32,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.GetFastEnumerable(System.Int32)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.GetFastEnumerable(System.Int32,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.GetRobustEnumerable(System.Int32)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRangeMap`1.GetRobustEnumerable(System.Int32,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.RedBlackTreeRangeMap`1.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. However, since it uses queries it
            is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.RedBlackTreeRangeMap`1.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any Add or Remove to the tree invalidates it.
            </summary>
        </member>
        <member name="T:TreeLib.RedBlackTreeRankList`1">
            <summary>
            Implements a map, list or range collection using a red-black tree. 
            </summary>
            <summary>
            Represents an ordered key collection, augmented with rank information. The rank of a key is the index it would
            be located in if all the keys in the tree were placed into a sorted array.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.#ctor(System.Collections.Generic.IComparer{`0},System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a red-black tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a red-black tree, with the specified capacity and allocation mode and using
            the default comparer.
            </summary>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a new collection based on a red-black tree, with default allocation options and using the specified comparer.
            </summary>
            <param name="comparer">The comparer to use for sorting keys</param>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.#ctor">
            <summary>
            Create a new collection based on a red-black tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.#ctor(TreeLib.RedBlackTreeRankList{`0})">
            <summary>
            Create a new collection based on a red-blacck tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.RedBlackTreeRankList`1.Count">
            <summary>
            Returns the number of keys in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue keys.</exception>
        </member>
        <member name="P:TreeLib.RedBlackTreeRankList`1.LongCount">
            <summary>
            Returns the number of keys in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.Clear">
            <summary>
            Removes all keys from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.TryRemove(`0)">
            <summary>
            Attempts to remove a key from the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key was found and removed</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.TryGetKey(`0,`0@)">
            <summary>
            Attempts to get the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">the actual key contained in the collection</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.TrySetKey(`0)">
            <summary>
            Attempts to update the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.Remove(`0)">
            <summary>
            Removes a key from the collection.
            </summary>
            <param name="key">key to remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.GetKey(`0)">
            <summary>
            Retrieves the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <returns>the value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.SetKey(`0)">
            <summary>
            Updates the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.ConditionalSetOrAdd(`0,TreeLib.UpdatePredicate{`0})">
            <summary>
            Conditionally update or add a key, based on the return value from the predicate.
            ConditionalSetOrAdd is more efficient when the decision to add or update depends on the value of the item.
            </summary>
            <param name="key">The key to update or add</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the key will be added to the
            collection if it is not already in the collection. Whether true or false, if the key is in the collection, the
            ref key upon return will be used to update the key data.</param>
            <exception cref="T:System.ArgumentException">The sort order of the key was changed by the predicate</exception>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.ConditionalSetOrRemove(`0,TreeLib.UpdatePredicate{`0})">
            <summary>
            Conditionally update or add a key, based on the return value from the predicate.
            ConditionalSetOrRemove is more efficient when the decision to remove or update depends on the value of the item.
            </summary>
            <param name="key">The key to update or remove</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the key will be removed from the
            collection if it is in the collection. If the key remains in the collection, the ref key upon return will be used
            to update the key data.</param>
            <exception cref="T:System.ArgumentException">The sort order of the key was changed by the predicate</exception>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key)</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key)</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.NearestLessOrEqual(`0,`0@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.NearestLess(`0,`0@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.NearestGreaterOrEqual(`0,`0@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.NearestGreater(`0,`0@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.TryAdd(`0)">
            <summary>
            Attempts to add a key to the collection. If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <returns>true if the key was added; false if the key was already present</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.TryGet(`0,`0@,System.Int32@)">
            <summary>
            Attempts to get the actual key data and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">the actual key contained in the collection</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.TryGetKeyByRank(System.Int32,`0@)">
            <summary>
            Retrieves the key at the specified rank index.
            If all keys in the collection were converted to a sorted array, this would be the equivalent of array[rank].
            </summary>
            <param name="rank">the rank index to query</param>
            <param name="key">an out paramter receiving the key at the specified rank index</param>
            <returns>the key located at that index</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.Add(`0)">
            <summary>
            Adds a key to the collection.
            </summary>
            <param name="key">key to insert</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.Get(`0,`0@,System.Int32@)">
            <summary>
            Retrieves the actual key data and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">the actual key contained in the collection</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.GetKeyByRank(System.Int32)">
            <summary>
            Retrieves the key at the specified rank index.
            If all keys in the collection were converted to a sorted array, this would be the equivalent of array[rank].
            </summary>
            <param name="rank">the rank index to query</param>
            <returns>the key located at that index</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.AdjustCount(`0,System.Int32)">
            <summary>
            Adjusts the rank count associated with the key-value pair. The countAdjust added to the existing count.
            For a RankMap, the only valid values are 0 (which does nothing) and -1 (which removes the key-value pair).
            </summary>
            <param name="key">key identifying the key-value pair to update</param>
            <param name="countAdjust">adjustment that is added to the count</param>
            <returns>The adjusted count</returns>
            <exception cref="T:System.ArgumentException">if the count is an invalid value or the key does not exist in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="P:TreeLib.RedBlackTreeRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.TreeLib#Internal#INonInvasiveMultiRankMapInspection#GetRanks">
            <summary>
            INonInvasiveMultiRankMapInspection.GetRanks() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.TreeLib#Internal#INonInvasiveMultiRankMapInspection#Validate">
            <summary>
            INonInvasiveMultiRankMapInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.GetEnumerator">
            <summary>
            Get the default enumerator, which is the fast enumerator for red-black trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator’s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator’s current key (i.e. in the portion of the
            collection the enumerator hasn’t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it’s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. For red-black trees, a
            failed insertion or deletion will still invalidate the enumerator, as failed operations may still have performed
            rotations in the tree. The complexity of the fast enumerator is O(1) per element, or O(N) to enumerate the
            entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.GetEnumerable(`0)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.GetEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.GetFastEnumerable(`0)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.GetFastEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.GetRobustEnumerable(`0)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankList`1.GetRobustEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.RedBlackTreeRankList`1.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. However, since it uses queries it
            is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.RedBlackTreeRankList`1.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any Add or Remove to the tree invalidates it.
            </summary>
        </member>
        <member name="T:TreeLib.RedBlackTreeRankMap`2">
            <summary>
            Implements a map, list or range collection using a red-black tree. 
            </summary>
            <summary>
            Represents an ordered key-value mapping, augmented with rank information. The rank of a key-value pair is the index it would
            be located in if all the key-value pairs in the tree were placed into a sorted array.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
            <typeparam name="ValueType">Type of value associated with each entry.</typeparam>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.#ctor(System.Collections.Generic.IComparer{`0},System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a red-black tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a red-black tree, with the specified capacity and allocation mode and using
            the default comparer.
            </summary>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a new collection based on a red-black tree, with default allocation options and using the specified comparer.
            </summary>
            <param name="comparer">The comparer to use for sorting keys</param>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.#ctor">
            <summary>
            Create a new collection based on a red-black tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.#ctor(TreeLib.RedBlackTreeRankMap{`0,`1})">
            <summary>
            Create a new collection based on a red-blacck tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.RedBlackTreeRankMap`2.Count">
            <summary>
            Returns the number of key-value pairs in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue key-value pairs.</exception>
        </member>
        <member name="P:TreeLib.RedBlackTreeRankMap`2.LongCount">
            <summary>
            Returns the number of key-value pairs in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.Clear">
            <summary>
            Removes all key-value pairs from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.TryRemove(`0)">
            <summary>
            Attempts to remove a key-value pair from the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key-value pair was found and removed</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to get the value associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.TrySetValue(`0,`1)">
            <summary>
            Attempts to set the value associated with a key in the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <returns>true if the key-value pair was found and the value was updated</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.Remove(`0)">
            <summary>
            Removes a key-value pair from the collection.
            </summary>
            <param name="key">key of the key-value pair to remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.GetValue(`0)">
            <summary>
            Retrieves the value associated with a key in the collection
            </summary>
            <param name="key">key to search for</param>
            <returns>the value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.SetValue(`0,`1)">
            <summary>
            Updates the value associated with a key in the collection
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.ConditionalSetOrAdd(`0,TreeLib.UpdatePredicate{`0,`1})">
            <summary>
            Conditionally update or add an item, based on the return value from the predicate.
            ConditionalSetOrAdd is more efficient when the decision to add or update depends on the value of the item.
            </summary>
            <param name="key">The key of the item to update or add</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the item will be added to the
            collection if it is not already in the collection. Whether true or false, if the item is in the collection, the
            ref value upon return will be used to update the item.</param>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.ConditionalSetOrRemove(`0,TreeLib.UpdatePredicate{`0,`1})">
            <summary>
            Conditionally update or add an item, based on the return value from the predicate.
            ConditionalSetOrRemove is more efficient when the decision to remove or update depends on the value of the item.
            </summary>
            <param name="key">The key of the item to update or remove</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the item will be removed from the
            collection if it is in the collection. If the item remains in the collection, the ref value upon return will be used
            to update the item.</param>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.Least(`0@,`1@)">
            <summary>
            Retrieves the lowest in the collection (in sort order) and the value associated with it.
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.Greatest(`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection (in sort order) and the value associated with it.
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.NearestLessOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.NearestLessOrEqual(`0,`0@,`1@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key and
            the value and rank associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.NearestLess(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.NearestLess(`0,`0@,`1@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key and
            the value and rank  associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.NearestGreaterOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.NearestGreaterOrEqual(`0,`0@,`1@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key and
            the value and rank  associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.NearestGreater(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.NearestGreater(`0,`0@,`1@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key and
            the value and rank  associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.TryAdd(`0,`1)">
            <summary>
            Attempts to add a key-value pair to the collection. If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="value">value to associate with the key</param>
            <returns>true if the key-value pair was added; false if the key was already present</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.TryGet(`0,`1@,System.Int32@)">
            <summary>
            Attempts to get the value and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.TryGetKeyByRank(System.Int32,`0@)">
            <summary>
            Attempts to return the key of a key-value pair at the specified rank index.
            If all key-value pairs in the collection were converted to a sorted array, this would be the equivalent of array[rank].Key.
            </summary>
            <param name="rank">the rank index to query</param>
            <param name="key">the key located at that index</param>
            <returns>true if there is an element at the the specified index</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.Add(`0,`1)">
            <summary>
            Adds a key-value pair to the collection.
            </summary>
            <param name="key">key to insert</param>
            <param name="value">value to associate with the key</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.Get(`0,`1@,System.Int32@)">
            <summary>
            Retrieves the value and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.GetKeyByRank(System.Int32)">
            <summary>
            Retrieves the key of a key-value pair at the specified rank index.
            If all key-value pairs in the collection were converted to a sorted array, this would be the equivalent of array[rank].Key.
            </summary>
            <param name="rank">the rank index to query</param>
            <returns>the key located at that index</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.AdjustCount(`0,System.Int32)">
            <summary>
            Adjusts the rank count associated with the key-value pair. The countAdjust added to the existing count.
            For a RankMap, the only valid values are 0 (which does nothing) and -1 (which removes the key-value pair).
            </summary>
            <param name="key">key identifying the key-value pair to update</param>
            <param name="countAdjust">adjustment that is added to the count</param>
            <returns>The adjusted count</returns>
            <exception cref="T:System.ArgumentException">if the count is an invalid value or the key does not exist in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="P:TreeLib.RedBlackTreeRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.TreeLib#Internal#INonInvasiveMultiRankMapInspection#GetRanks">
            <summary>
            INonInvasiveMultiRankMapInspection.GetRanks() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.TreeLib#Internal#INonInvasiveMultiRankMapInspection#Validate">
            <summary>
            INonInvasiveMultiRankMapInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.GetEnumerator">
            <summary>
            Get the default enumerator, which is the fast enumerator for red-black trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator’s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator’s current key (i.e. in the portion of the
            collection the enumerator hasn’t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it’s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. For red-black trees, a
            failed insertion or deletion will still invalidate the enumerator, as failed operations may still have performed
            rotations in the tree. The complexity of the fast enumerator is O(1) per element, or O(N) to enumerate the
            entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.GetEnumerable(`0)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.GetEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.GetFastEnumerable(`0)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.GetFastEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.GetRobustEnumerable(`0)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.RedBlackTreeRankMap`2.GetRobustEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.RedBlackTreeRankMap`2.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. However, since it uses queries it
            is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.RedBlackTreeRankMap`2.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any Add or Remove to the tree invalidates it.
            </summary>
        </member>
        <member name="T:TreeLib.SplayTreeList`1">
            <summary>
            Implements a map, list or range collection using a splay tree. 
            </summary>
            <summary>
            Represents an ordered key collection.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.#ctor(System.Collections.Generic.IComparer{`0},System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a splay tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a splay tree, with the specified capacity and allocation mode and using
            the default comparer.
            </summary>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a new collection based on a splay tree, with default allocation options and using the specified comparer.
            </summary>
            <param name="comparer">The comparer to use for sorting keys</param>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.#ctor">
            <summary>
            Create a new collection based on a splay tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.#ctor(TreeLib.SplayTreeList{`0})">
            <summary>
            Create a new collection based on a splay tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.SplayTreeList`1.Count">
            <summary>
            Returns the number of keys in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue keys.</exception>
        </member>
        <member name="P:TreeLib.SplayTreeList`1.LongCount">
            <summary>
            Returns the number of keys in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.Clear">
            <summary>
            Removes all keys from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.TryAdd(`0)">
            <summary>
            Attempts to add a key to the collection. If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <returns>true if the key was added; false if the key was already present</returns>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.TryRemove(`0)">
            <summary>
            Attempts to remove a key from the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key was found and removed</returns>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.TryGetKey(`0,`0@)">
            <summary>
            Attempts to get the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">the actual key contained in the collection</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.TrySetKey(`0)">
            <summary>
            Attempts to update the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.Add(`0)">
            <summary>
            Adds a key to the collection.
            </summary>
            <param name="key">key to insert</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.Remove(`0)">
            <summary>
            Removes a key from the collection.
            </summary>
            <param name="key">key to remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.GetKey(`0)">
            <summary>
            Retrieves the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <returns>the value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.SetKey(`0)">
            <summary>
            Updates the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.ConditionalSetOrAdd(`0,TreeLib.UpdatePredicate{`0})">
            <summary>
            Conditionally update or add a key, based on the return value from the predicate.
            ConditionalSetOrAdd is more efficient when the decision to add or update depends on the value of the item.
            </summary>
            <param name="key">The key to update or add</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the key will be added to the
            collection if it is not already in the collection. Whether true or false, if the key is in the collection, the
            ref key upon return will be used to update the key data.</param>
            <exception cref="T:System.ArgumentException">The sort order of the key was changed by the predicate</exception>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.ConditionalSetOrRemove(`0,TreeLib.UpdatePredicate{`0})">
            <summary>
            Conditionally update or add a key, based on the return value from the predicate.
            ConditionalSetOrRemove is more efficient when the decision to remove or update depends on the value of the item.
            </summary>
            <param name="key">The key to update or remove</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the key will be removed from the
            collection if it is in the collection. If the key remains in the collection, the ref key upon return will be used
            to update the key data.</param>
            <exception cref="T:System.ArgumentException">The sort order of the key was changed by the predicate</exception>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key)</returns>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key)</returns>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="P:TreeLib.SplayTreeList`1.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.GetEnumerator">
            <summary>
            Get the default enumerator, which is the robust enumerator for splay trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator�s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator�s current key (i.e. in the portion of the
            collection the enumerator hasn�t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it�s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. For the Splay tree, all operations modify
            the tree structure, include queries, and will invalidate the enumerator. The complexity of the fast enumerator
            is O(1) per element, or O(N) to enumerate the entire tree.
            
            A note about splay trees and enumeration: Enumeration of splay trees is generally problematic, for two reasons.
            First, every operation on a splay tree modifies the structure of the tree, including queries. Second, splay trees
            may have depth of N in the worst case (as compared to other trees which are guaranteed to be less deep than
            approximately two times the optimal depth, or 2 lg N). The first property makes fast enumeration less useful, and
            the second property means fast enumeration may consume up to memory proportional to N for the internal stack used
            for traversal. Therefore, the robust enumerator is recommended for splay trees. The drawback is the
            robust enumerator�s O(N lg N) complexity.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.GetEnumerable(`0)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.GetEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.GetFastEnumerable(`0)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.GetFastEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.GetRobustEnumerable(`0)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeList`1.GetRobustEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.SplayTreeList`1.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. The enumerator also uses a constant
            amount of memory. However, since it uses queries it is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.SplayTreeList`1.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any change to the tree invalidates it, and that *includes queries* since a query causes a splay
            operation that changes the structure of the tree.
            Worse, this enumerator also uses a stack that can be as deep as the tree, and since the depth of a splay
            tree is in the worst case n (number of nodes), the stack can potentially be size n.
            </summary>
        </member>
        <member name="T:TreeLib.SplayTreeMap`2">
            <summary>
            Implements a map, list or range collection using a splay tree. 
            </summary>
            <summary>
            Represents an ordered key-value mapping.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
            <typeparam name="ValueType">Type of value associated with each entry.</typeparam>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.#ctor(System.Collections.Generic.IComparer{`0},System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a splay tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a splay tree, with the specified capacity and allocation mode and using
            the default comparer.
            </summary>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a new collection based on a splay tree, with default allocation options and using the specified comparer.
            </summary>
            <param name="comparer">The comparer to use for sorting keys</param>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.#ctor">
            <summary>
            Create a new collection based on a splay tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.#ctor(TreeLib.SplayTreeMap{`0,`1})">
            <summary>
            Create a new collection based on a splay tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.SplayTreeMap`2.Count">
            <summary>
            Returns the number of key-value pairs in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue key-value pairs.</exception>
        </member>
        <member name="P:TreeLib.SplayTreeMap`2.LongCount">
            <summary>
            Returns the number of key-value pairs in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.Clear">
            <summary>
            Removes all key-value pairs from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.SetOrAddValue(`0,`1)">
            <summary>
            Either set the value associated with a key (if the key is already present in the collection)
            or insert a new key-value pair into the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="value">value to associate with the key</param>
            <returns>true if key was not present and key-value pair was added; false if key-value pair was already present and value was updated</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.TryAdd(`0,`1)">
            <summary>
            Attempts to add a key-value pair to the collection. If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="value">value to associate with the key</param>
            <returns>true if the key-value pair was added; false if the key was already present</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.TryRemove(`0)">
            <summary>
            Attempts to remove a key-value pair from the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key-value pair was found and removed</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to get the value associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.TrySetValue(`0,`1)">
            <summary>
            Attempts to set the value associated with a key in the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <returns>true if the key-value pair was found and the value was updated</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.Add(`0,`1)">
            <summary>
            Adds a key-value pair to the collection.
            </summary>
            <param name="key">key to insert</param>
            <param name="value">value to associate with the key</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.Remove(`0)">
            <summary>
            Removes a key-value pair from the collection.
            </summary>
            <param name="key">key of the key-value pair to remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.GetValue(`0)">
            <summary>
            Retrieves the value associated with a key in the collection
            </summary>
            <param name="key">key to search for</param>
            <returns>the value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.SetValue(`0,`1)">
            <summary>
            Updates the value associated with a key in the collection
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.ConditionalSetOrAdd(`0,TreeLib.UpdatePredicate{`0,`1})">
            <summary>
            Conditionally update or add an item, based on the return value from the predicate.
            ConditionalSetOrAdd is more efficient when the decision to add or update depends on the value of the item.
            </summary>
            <param name="key">The key of the item to update or add</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the item will be added to the
            collection if it is not already in the collection. Whether true or false, if the item is in the collection, the
            ref value upon return will be used to update the item.</param>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.ConditionalSetOrRemove(`0,TreeLib.UpdatePredicate{`0,`1})">
            <summary>
            Conditionally update or add an item, based on the return value from the predicate.
            ConditionalSetOrRemove is more efficient when the decision to remove or update depends on the value of the item.
            </summary>
            <param name="key">The key of the item to update or remove</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the item will be removed from the
            collection if it is in the collection. If the item remains in the collection, the ref value upon return will be used
            to update the item.</param>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.Least(`0@,`1@)">
            <summary>
            Retrieves the lowest key-value pair in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.Greatest(`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.NearestLessOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.NearestLess(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.NearestGreaterOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.NearestGreater(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="P:TreeLib.SplayTreeMap`2.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.GetEnumerator">
            <summary>
            Get the default enumerator, which is the robust enumerator for splay trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator�s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator�s current key (i.e. in the portion of the
            collection the enumerator hasn�t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it�s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. For the Splay tree, all operations modify
            the tree structure, include queries, and will invalidate the enumerator. The complexity of the fast enumerator
            is O(1) per element, or O(N) to enumerate the entire tree.
            
            A note about splay trees and enumeration: Enumeration of splay trees is generally problematic, for two reasons.
            First, every operation on a splay tree modifies the structure of the tree, including queries. Second, splay trees
            may have depth of N in the worst case (as compared to other trees which are guaranteed to be less deep than
            approximately two times the optimal depth, or 2 lg N). The first property makes fast enumeration less useful, and
            the second property means fast enumeration may consume up to memory proportional to N for the internal stack used
            for traversal. Therefore, the robust enumerator is recommended for splay trees. The drawback is the
            robust enumerator�s O(N lg N) complexity.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.GetEnumerable(`0)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.GetEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.GetFastEnumerable(`0)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.GetFastEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.GetRobustEnumerable(`0)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMap`2.GetRobustEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.SplayTreeMap`2.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. The enumerator also uses a constant
            amount of memory. However, since it uses queries it is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.SplayTreeMap`2.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any change to the tree invalidates it, and that *includes queries* since a query causes a splay
            operation that changes the structure of the tree.
            Worse, this enumerator also uses a stack that can be as deep as the tree, and since the depth of a splay
            tree is in the worst case n (number of nodes), the stack can potentially be size n.
            </summary>
        </member>
        <member name="T:TreeLib.SplayTreeMultiRankList`1">
            <summary>
            Implements a map, list or range collection using a splay tree. 
            </summary>
            <summary>
            Represents an ordered key collection, augmented with multi-rank information. The rank of a key is the index it would
            be located in if all the keys in the tree were placed into a sorted array. Each key also has a count
            associated with it, which models sorted arrays containing multiple instances of a key. It is equivalent to the number of times
            the key appears in the array. Rank index values account for such multiple occurrences. In this case, the rank
            index is the index at which the first instance of a particular key would occur in a sorted array containing all keys.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.#ctor(System.Collections.Generic.IComparer{`0},System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a splay tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a splay tree, with the specified capacity and allocation mode and using
            the default comparer.
            </summary>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a new collection based on a splay tree, with default allocation options and using the specified comparer.
            </summary>
            <param name="comparer">The comparer to use for sorting keys</param>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.#ctor">
            <summary>
            Create a new collection based on a splay tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.#ctor(TreeLib.SplayTreeMultiRankList{`0})">
            <summary>
            Create a new collection based on a splay tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.SplayTreeMultiRankList`1.Count">
            <summary>
            Returns the number of keys in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue keys.</exception>
        </member>
        <member name="P:TreeLib.SplayTreeMultiRankList`1.LongCount">
            <summary>
            Returns the number of keys in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.Clear">
            <summary>
            Removes all keys from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.TryRemove(`0)">
            <summary>
            Attempts to remove a key from the collection. If the key is not present, no change is made to the collection.
            The entire key is removed, regardless of the rank count for it.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key was found and removed</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.TryGetKey(`0,`0@)">
            <summary>
            Attempts to get the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">the actual key contained in the collection</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.TrySetKey(`0)">
            <summary>
            Attempts to update the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.Remove(`0)">
            <summary>
            Removes a key from the collection. If the key is not present, no change is made to the collection.
            The entire key is removed, regardless of the rank count for it.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.GetKey(`0)">
            <summary>
            Retrieves the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <returns>the value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.SetKey(`0)">
            <summary>
            Updates the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.NearestLessOrEqual(`0,`0@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.NearestLess(`0,`0@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.NearestGreaterOrEqual(`0,`0@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.NearestGreater(`0,`0@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.NearestLessOrEqualByRank(System.Int32,`0@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a key's range into the start index of a key's range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the specified index is greater than or equal to the extent it will return the last key's start index.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <returns>true if a key was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.NearestLessOrEqualByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a key's range into the start index of a key's range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the specified index is greater than or equal to the extent it will return the last key's start index.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <returns>true if a key was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.NearestLessByRank(System.Int32,`0@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a key's range, the start of the previous key's range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.NearestLessByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a key's range, the start of the previous key's range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.NearestGreaterOrEqualByRank(System.Int32,`0@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range, that index will be returned.
            If the index refers to the interior index for a key's range, the start of the next key's range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than the start of the last key's range, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.NearestGreaterOrEqualByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range, that index will be returned.
            If the index refers to the interior index for a key's range, the start of the next key's range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than the start of the last key's range, no index will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.NearestGreaterByRank(System.Int32,`0@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest key's range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range or is an interior index for a range, the next key's range will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than or equal to the start of the last key's range, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.NearestGreaterByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range or is an interior index for a range, the next key's range will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than or equal to the start of the last key's range, no index will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="P:TreeLib.SplayTreeMultiRankList`1.RankCount">
            <summary>
            Returns the total size of an array containing all keys, where each key occurs one or more times, determined by
            the 'count' associated with each key.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.TryAdd(`0,System.Int32)">
            <summary>
            Attempts to add a key to the collection.
            If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="count">number of instances to repeat this key if the collection were converted to a sorted array</param>
            <returns>true if key was not present and key was added; false if key was already present</returns>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.TryGet(`0,`0@,System.Int32@,System.Int32@)">
            <summary>
            Attempts to get the actual key, rank index, and count associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">out parameter that returns the actual key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key</param>
            <param name="count">out parameter that returns the count, where count is the number of instances to repeat
            this key if the collection were converted to a sorted array</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.TrySet(`0,System.Int32)">
            <summary>
            Attempts to update the key data and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for and also update</param>
            <param name="rank">the new rank count</param>
            <returns>true if they key was found and the rank was a valid value or false if the rank count was not at least 1
            or the sum of counts would have exceeded Int32.MaxValue</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.TryGetKeyByRank(System.Int32,`0@)">
            <summary>
            Attempts to return the key at the specified rank index. If all keys in the collection were
            converted to a sorted array of keys, this would be the equivalent of array[rank]s, subject to the
            constraint that only the first occurrence of each key can be indexed.
            </summary>
            <param name="rank">the rank index to query; the rank must be of the first occurrence of the key in a virtual
            sorted array where each key occurs 'count' times.</param>
            <param name="key">the key located at that index</param>
            <returns>true if there is an element at the the specified index and it corresponds to the first in the virtual
            ordered sequence of multiple instances in an equivalent sorted array</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.Add(`0,System.Int32)">
            <summary>
            Adds a key to the collection with an associated count.
            If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="count">number of instances to repeat this key if the collection were converted to a sorted array</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.Get(`0,`0@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the actual key, rank index, and count associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">out parameter that returns the actual key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key</param>
            <param name="count">out parameter that returns the count, where count is the number of instances to repeat
            this key if the collection were converted to a sorted array</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.Set(`0,System.Int32)">
            <summary>
            Updates the key and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for and also update</param>
            <param name="rank">the new rank count</param>
            <exception cref="T:System.ArgumentException">the rank count was not at least 1</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.GetKeyByRank(System.Int32)">
            <summary>
            Retrieves the key at the specified rank index. If all keys in the collection were
            converted to a sorted array of keys, this would be the equivalent of array[rank], subject to the
            constraint that only the first occurrence of each key can be indexed.
            </summary>
            <param name="rank">the rank index to query; the rank must be of the first occurrence of the key in a virtual
            sorted array where each key occurs 'count' times.</param>
            <returns>the key located at that index</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.AdjustCount(`0,System.Int32)">
            <summary>
            Adjusts the rank count associated with the key. The countAdjust added to the existing count.
            If the countAdjust is equal to the negative value of the current count, the key will be removed.
            </summary>
            <param name="key">key identifying the key to update</param>
            <param name="countAdjust">adjustment that is added to the count</param>
            <returns>The adjusted count</returns>
            <exception cref="T:System.ArgumentException">if the count is an invalid value or the key does not exist in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="P:TreeLib.SplayTreeMultiRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.TreeLib#Internal#INonInvasiveMultiRankMapInspection#GetRanks">
            <summary>
            INonInvasiveMultiRankMapInspection.GetRanks() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.TreeLib#Internal#INonInvasiveMultiRankMapInspection#Validate">
            <summary>
            INonInvasiveMultiRankMapInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.GetEnumerator">
            <summary>
            Get the default enumerator, which is the robust enumerator for splay trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator�s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator�s current key (i.e. in the portion of the
            collection the enumerator hasn�t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it�s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. For the Splay tree, all operations modify
            the tree structure, include queries, and will invalidate the enumerator. The complexity of the fast enumerator
            is O(1) per element, or O(N) to enumerate the entire tree.
            
            A note about splay trees and enumeration: Enumeration of splay trees is generally problematic, for two reasons.
            First, every operation on a splay tree modifies the structure of the tree, including queries. Second, splay trees
            may have depth of N in the worst case (as compared to other trees which are guaranteed to be less deep than
            approximately two times the optimal depth, or 2 lg N). The first property makes fast enumeration less useful, and
            the second property means fast enumeration may consume up to memory proportional to N for the internal stack used
            for traversal. Therefore, the robust enumerator is recommended for splay trees. The drawback is the
            robust enumerator�s O(N lg N) complexity.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.GetEnumerable(`0)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.GetEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.GetFastEnumerable(`0)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.GetFastEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.GetRobustEnumerable(`0)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankList`1.GetRobustEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.SplayTreeMultiRankList`1.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. The enumerator also uses a constant
            amount of memory. However, since it uses queries it is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.SplayTreeMultiRankList`1.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any change to the tree invalidates it, and that *includes queries* since a query causes a splay
            operation that changes the structure of the tree.
            Worse, this enumerator also uses a stack that can be as deep as the tree, and since the depth of a splay
            tree is in the worst case n (number of nodes), the stack can potentially be size n.
            </summary>
        </member>
        <member name="T:TreeLib.SplayTreeMultiRankMap`2">
            <summary>
            Implements a map, list or range collection using a splay tree. 
            </summary>
            <summary>
            Represents an ordered key-value mapping, augmented with multi-rank information. The rank of a key-value pair is the index it would
            be located in if all the key-value pairs in the tree were placed into a sorted array. Each key-value pair also has a count
            associated with it, which models sorted arrays containing multiple instances of a key. It is equivalent to the number of times
            the key-value pair appears in the array. Rank index values account for such multiple occurrences. In this case, the rank
            index is the index at which the first instance of a particular key would occur in a sorted array containing all keys.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
            <typeparam name="ValueType">Type of value associated with each entry.</typeparam>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.#ctor(System.Collections.Generic.IComparer{`0},System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a splay tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a splay tree, with the specified capacity and allocation mode and using
            the default comparer.
            </summary>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a new collection based on a splay tree, with default allocation options and using the specified comparer.
            </summary>
            <param name="comparer">The comparer to use for sorting keys</param>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.#ctor">
            <summary>
            Create a new collection based on a splay tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.#ctor(TreeLib.SplayTreeMultiRankMap{`0,`1})">
            <summary>
            Create a new collection based on a splay tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.SplayTreeMultiRankMap`2.Count">
            <summary>
            Returns the number of key-value pairs in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue key-value pairs.</exception>
        </member>
        <member name="P:TreeLib.SplayTreeMultiRankMap`2.LongCount">
            <summary>
            Returns the number of key-value pairs in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.Clear">
            <summary>
            Removes all key-value pairs from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.TryRemove(`0)">
            <summary>
            Attempts to remove a key-value pair from the collection. If the key is not present, no change is made to the collection.
            The entire key-value pair is removed, regardless of the rank count for it.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key-value pair was found and removed</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to get the value associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.TrySetValue(`0,`1)">
            <summary>
            Attempts to set the value associated with a key in the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <returns>true if the key-value pair was found and the value was updated</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.Remove(`0)">
            <summary>
            Removes a key-value pair from the collection. If the key is not present, no change is made to the collection.
            The entire key-value pair is removed, regardless of the rank count for it.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.GetValue(`0)">
            <summary>
            Retrieves the value associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <returns>value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.SetValue(`0,`1)">
            <summary>
            Updates the value associated with a key in the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.Least(`0@,`1@)">
            <summary>
            Retrieves the lowest key-value pair in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.Greatest(`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.NearestLessOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.NearestLessOrEqual(`0,`0@,`1@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key and
            the value, rank and count associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.NearestLess(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.NearestLess(`0,`0@,`1@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key and
            the value, rank and count  associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.NearestGreaterOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.NearestGreaterOrEqual(`0,`0@,`1@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key and
            the value, rank and count  associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.NearestGreater(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.NearestGreater(`0,`0@,`1@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key and
            the value, rank and count  associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.NearestLessOrEqualByRank(System.Int32,`0@,System.Int32@,System.Int32@,`1@)">
            <summary>
            Search for the nearest key's index that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a key's range into the start index of a key's range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the specified index is greater than or equal to the extent it will return the last key's start index.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <param name="value">the value associated with the key</param>
            <returns>true if a key was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.NearestLessOrEqualByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a key's range into the start index of a key's range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the specified index is greater than or equal to the extent it will return the last key's start index.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <returns>true if a key was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.NearestLessByRank(System.Int32,`0@,System.Int32@,System.Int32@,`1@)">
            <summary>
            Search for the nearest key's index that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a key's range, the start of the previous key's range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <param name="value">the value associated with the key</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.NearestLessByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a key's range, the start of the previous key's range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.NearestGreaterOrEqualByRank(System.Int32,`0@,System.Int32@,System.Int32@,`1@)">
            <summary>
            Search for the nearest key's index that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range, that index will be returned.
            If the index refers to the interior index for a key's range, the start of the next key's range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than the start of the last key's range, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <param name="value">the value associated with the key</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.NearestGreaterOrEqualByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range, that index will be returned.
            If the index refers to the interior index for a key's range, the start of the next key's range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than the start of the last key's range, no index will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.NearestGreaterByRank(System.Int32,`0@,System.Int32@,System.Int32@,`1@)">
            <summary>
            Search for the nearest key's range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range or is an interior index for a range, the next key's range will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than or equal to the start of the last key's range, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <param name="value">the value associated with the key</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.NearestGreaterByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range or is an interior index for a range, the next key's range will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than or equal to the start of the last key's range, no index will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="P:TreeLib.SplayTreeMultiRankMap`2.RankCount">
            <summary>
            Returns the total size of an array containing all key-value pairs, where each key occurs one or more times, determined by
            the 'count' associated with each key-value pair.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.TryAdd(`0,`1,System.Int32)">
            <summary>
            Attempts to add a key to the collection with an associated value and count.
            If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="value">value to associate with the key</param>
            <param name="count">number of instances to repeat this key-value pair if the collection were converted to a sorted array</param>
            <returns>true if key was not present and key-value pair was added; false if key-value pair was already present and value was updated</returns>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.TryGet(`0,`1@,System.Int32@,System.Int32@)">
            <summary>
            Attempts to get the value, rank index, and count associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <param name="count">out parameter that returns the count, where count is the number of instances to repeat
            this key-value pair if the collection were converted to a sorted array</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.TrySet(`0,`1,System.Int32)">
            <summary>
            Attempts to update the value and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">the new value to set</param>
            <param name="rank">the new rank count</param>
            <returns>true if they key was found and the rank was a valid value or false if the rank count was not at least 1
            or the sum of counts would have exceeded Int32.MaxValue</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.TryGetKeyByRank(System.Int32,`0@)">
            <summary>
            Attempts to return the key of a key-value pair at the specified rank index. If all key-value pairs in the collection were
            converted to a sorted array of key-value pairs, this would be the equivalent of array[rank].Key, subject to the
            constraint that only the first occurrence of each key can be indexed.
            </summary>
            <param name="rank">the rank index to query; the rank must be of the first occurrence of the key in a virtual
            sorted array where each key occurs 'count' times.</param>
            <param name="key">the key located at that index</param>
            <returns>true if there is an element at the the specified index and it corresponds to the first in the virtual
            ordered sequence of multiple instances in an equivalent sorted array</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.Add(`0,`1,System.Int32)">
            <summary>
            Adds a key to the collection with an associated value and count.
            If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="value">value to associate with the key</param>
            <param name="count">number of instances to repeat this key-value pair if the collection were converted to a sorted array</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.Get(`0,`1@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the value, rank index, and count associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <param name="count">out parameter that returns the count, where count is the number of instances to repeat
            this key-value pair if the collection were converted to a sorted array</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.Set(`0,`1,System.Int32)">
            <summary>
            Updates the value and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">the new value to set</param>
            <param name="rank">the new rank count</param>
            <exception cref="T:System.ArgumentException">the rank count was not at least 1</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.GetKeyByRank(System.Int32)">
            <summary>
            Retrieves the key of a key-value pair at the specified rank index. If all key-value pairs in the collection were
            converted to a sorted array of key-value pairs, this would be the equivalent of array[rank].Key, subject to the
            constraint that only the first occurrence of each key can be indexed.
            </summary>
            <param name="rank">the rank index to query; the rank must be of the first occurrence of the key in a virtual
            sorted array where each key occurs 'count' times.</param>
            <returns>the key located at that index</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.AdjustCount(`0,System.Int32)">
            <summary>
            Adjusts the rank count associated with the key-value pair. The countAdjust added to the existing count.
            If the countAdjust is equal to the negative value of the current count, the key-value pair will be removed.
            </summary>
            <param name="key">key identifying the key-value pair to update</param>
            <param name="countAdjust">adjustment that is added to the count</param>
            <returns>The adjusted count</returns>
            <exception cref="T:System.ArgumentException">if the count is an invalid value or the key does not exist in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="P:TreeLib.SplayTreeMultiRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.TreeLib#Internal#INonInvasiveMultiRankMapInspection#GetRanks">
            <summary>
            INonInvasiveMultiRankMapInspection.GetRanks() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.TreeLib#Internal#INonInvasiveMultiRankMapInspection#Validate">
            <summary>
            INonInvasiveMultiRankMapInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.GetEnumerator">
            <summary>
            Get the default enumerator, which is the robust enumerator for splay trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator�s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator�s current key (i.e. in the portion of the
            collection the enumerator hasn�t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it�s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. For the Splay tree, all operations modify
            the tree structure, include queries, and will invalidate the enumerator. The complexity of the fast enumerator
            is O(1) per element, or O(N) to enumerate the entire tree.
            
            A note about splay trees and enumeration: Enumeration of splay trees is generally problematic, for two reasons.
            First, every operation on a splay tree modifies the structure of the tree, including queries. Second, splay trees
            may have depth of N in the worst case (as compared to other trees which are guaranteed to be less deep than
            approximately two times the optimal depth, or 2 lg N). The first property makes fast enumeration less useful, and
            the second property means fast enumeration may consume up to memory proportional to N for the internal stack used
            for traversal. Therefore, the robust enumerator is recommended for splay trees. The drawback is the
            robust enumerator�s O(N lg N) complexity.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.GetEnumerable(`0)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.GetEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.GetFastEnumerable(`0)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.GetFastEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.GetRobustEnumerable(`0)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeMultiRankMap`2.GetRobustEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.SplayTreeMultiRankMap`2.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. The enumerator also uses a constant
            amount of memory. However, since it uses queries it is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.SplayTreeMultiRankMap`2.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any change to the tree invalidates it, and that *includes queries* since a query causes a splay
            operation that changes the structure of the tree.
            Worse, this enumerator also uses a stack that can be as deep as the tree, and since the depth of a splay
            tree is in the worst case n (number of nodes), the stack can potentially be size n.
            </summary>
        </member>
        <member name="T:TreeLib.SplayTreeRange2List">
            <summary>
            Implements a map, list or range collection using a splay tree. 
            </summary>
            <summary>
            Represents an sequenced collection of range-to-range pairs (without associated values). Each range pair is defined by two lengths,
            one for the X sequence and one for the Y sequence.
            With regard to a particular sequence, each range occupies a particular position in the sequence, determined by the location
            where it was inserted (and any insertions/deletions that have occurred before or after it in the sequence).
            Within the sequence, the start indices of each range are determined as follows:
            The first range in the sequence starts at 0 and each subsequent range starts at the starting index of the previous range
            plus the length of the previous range. The 'extent' of the range collection is the sum of all lengths.
            The above applies separately to both the X side sequence and the Y side sequence.
            All ranges must have a lengths of at least 1, on both sides.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a splay tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.#ctor">
            <summary>
            Create a new collection based on a splay tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.#ctor(TreeLib.SplayTreeRange2List)">
            <summary>
            Create a new collection based on a splay tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.SplayTreeRange2List.Count">
            <summary>
            Returns the number of range pairs in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue range pairs.</exception>
        </member>
        <member name="P:TreeLib.SplayTreeRange2List.LongCount">
            <summary>
            Returns the number of ranges in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.Clear">
            <summary>
            Removes all range pairs from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.Contains(System.Int32,TreeLib.Side)">
            <summary>
            Determines if there is a range pair in the collection starting at the index specified, with respect to the side specified.
            </summary>
            <param name="start">index to look for the start of a range at</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <returns>true if there is a range starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.TryInsert(System.Int32,TreeLib.Side,System.Int32,System.Int32)">
            <summary>
            Attempt to insert a range pair defined by the given pair of lengths at the specified start index with respect to
            the specified side.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            The sequence of the non-specified side is also updated, by inserting the other length of the pair at the same
            rank in the sequence as on the specified side.
            </summary>
            <param name="start">the specified start index to insert before</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <param name="xLength">the length of the X side of the range pair. the length must be at least 1.</param>
            <param name="yLength">the length of the Y side of the range pair. the length must be at least 1.</param>
            <returns>true if the range was successfully inserted</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue on either side</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.TryDelete(System.Int32,TreeLib.Side)">
            <summary>
            Attempt to delete the range pair starting at the specified index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to delete</param>
            <param name="side">the side (X or Y) to which the start index applies</param>
            <returns>true if a range pair was successfully deleted</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.TryGetLength(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Attempt to query the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies. The side also determines which length is returned</param>
            <param name="length">the length of the range from the specified side (X or Y)</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.TrySetLength(System.Int32,TreeLib.Side,System.Int32)">
            <summary>
            Attempt to change the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to modify</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="length">the new length to apply on the specified side (X or Y) of the range pair. The new length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.OverflowException">the sum of lengths on the specified side would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.TryGet(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Attempt to get the lengths associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="otherStart">out parameter receiving the start index of the range from the opposite side of that specified</param>
            <param name="xLength">out parameter receiving the length of the range on the X side</param>
            <param name="yLength">out parameter receiving the length f the range on the Y side</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.TrySet(System.Int32,TreeLib.Side,System.Int32,System.Int32)">
            <summary>
            Attempt to change the lengths associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="side">the side with which the start parameter applies</param>
            <param name="xLength">new X-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="yLength">new Y-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <returns>true if a range was found starting at the specified index and updated; false if the
            start was not found or the sum of lengths would have exceeded Int32.MaxValue</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.Insert(System.Int32,TreeLib.Side,System.Int32,System.Int32)">
            <summary>
            Insert a range pair defined by the given pair of lengths at the specified start index with respect to
            the specified side.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            The sequence of the non-specified side is also updated, by inserting the other length of the pair at the same
            rank in the sequence as on the specified side.
            </summary>
            <param name="start">the specified start index to insert before</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <param name="xLength">the length of the X side of the range pair. the length must be at least 1.</param>
            <param name="yLength">the length of the Y side of the range pair. the length must be at least 1.</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue on either side</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.Delete(System.Int32,TreeLib.Side)">
            <summary>
            Deletes the range pair starting at the specified index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to delete</param>
            <param name="side">the side (X or Y) to which the start index applies</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.GetLength(System.Int32,TreeLib.Side)">
            <summary>
            Retrieves the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies. The side also determines which length is returned</param>
            <returns>the length of the range from the specified side (X or Y)</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.SetLength(System.Int32,TreeLib.Side,System.Int32)">
            <summary>
            Changes the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to modify</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="length">the new length to apply on the specified side (X or Y) of the range pair. The new length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
            <exception cref="T:System.OverflowException">the sum of lengths on the specified side would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.Get(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Attempt to get the lengths associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="otherStart">out parameter receiving the start index of the range from the opposite side of that specified</param>
            <param name="xLength">out parameter receiving the length of the range on the X side</param>
            <param name="yLength">out parameter receiving the length f the range on the Y side</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.Set(System.Int32,TreeLib.Side,System.Int32,System.Int32)">
            <summary>
            Changes the lengths associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="side">the side with which the start parameter applies</param>
            <param name="xLength">new X-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="yLength">new Y-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <returns>true if a range was found starting at the specified index and updated; false if the
            start was not found or the sum of lengths would have exceeded Int32.MaxValue</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.GetExtent(TreeLib.Side)">
            <summary>
            Retrieves the extent of the sequence of ranges on the specified side. The extent is the sum of the lengths of all the ranges.
            </summary>
            <param name="side">the side (X or Y) to which the query applies.</param>
            <returns>the extent of the ranges on the specified side</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.NearestLessOrEqual(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index with respect to the specified side.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.NearestLessOrEqual(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index with respect to the specified side.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.NearestLess(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.NearestLess(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.NearestGreaterOrEqual(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.NearestGreaterOrEqual(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.NearestGreater(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.NearestGreater(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.AdjustLength(System.Int32,TreeLib.Side,System.Int32,System.Int32)">
            <summary>
            Adjust the lengths of the range starting at 'start' by adding xAdjust and yAdjust to the current lengths of the
            range. If the lengths would become 0, the range is removed.
            </summary>
            <param name="start">the start index of the range to adjust</param>
            <param name="side">which side (X or Y) the start parameter applies</param>
            <param name="xAdjust">the amount to adjust the X length by. Value may be negative to shrink the length</param>
            <param name="yAdjust">the amount to adjust the Y length by. Value may be negative to shrink the length</param>
            <returns>The adjusted length</returns>
            <exception cref="T:System.ArgumentException">There is no range starting at the index specified by 'start', or the length on
            one side would become 0 while the length on the other side would not be 0.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">one or both of the lengths would become negative</exception>
            <exception cref="T:System.OverflowException">the X or Y extent would become larger than Int32.MaxValue</exception>
        </member>
        <member name="P:TreeLib.SplayTreeRange2List.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.TreeLib#Internal#INonInvasiveRange2MapInspection#GetRanges">
            <summary>
            INonInvasiveRange2MapInspection.GetRanges() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.TreeLib#Internal#INonInvasiveRange2MapInspection#Validate">
            <summary>
            INonInvasiveRange2MapInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.GetEnumerator">
            <summary>
            Get the default enumerator, which is the robust enumerator for splay trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator�s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator�s current key (i.e. in the portion of the
            collection the enumerator hasn�t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it�s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. For the Splay tree, all operations modify
            the tree structure, include queries, and will invalidate the enumerator. The complexity of the fast enumerator
            is O(1) per element, or O(N) to enumerate the entire tree.
            
            A note about splay trees and enumeration: Enumeration of splay trees is generally problematic, for two reasons.
            First, every operation on a splay tree modifies the structure of the tree, including queries. Second, splay trees
            may have depth of N in the worst case (as compared to other trees which are guaranteed to be less deep than
            approximately two times the optimal depth, or 2 lg N). The first property makes fast enumeration less useful, and
            the second property means fast enumeration may consume up to memory proportional to N for the internal stack used
            for traversal. Therefore, the robust enumerator is recommended for splay trees. The drawback is the
            robust enumerator�s O(N lg N) complexity.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.GetEnumerable(System.Int32,TreeLib.Side)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.GetEnumerable(System.Int32,TreeLib.Side,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.GetFastEnumerable(System.Int32,TreeLib.Side)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.GetFastEnumerable(System.Int32,TreeLib.Side,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.GetRobustEnumerable(System.Int32,TreeLib.Side)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2List.GetRobustEnumerable(System.Int32,TreeLib.Side,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.SplayTreeRange2List.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. The enumerator also uses a constant
            amount of memory. However, since it uses queries it is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.SplayTreeRange2List.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any change to the tree invalidates it, and that *includes queries* since a query causes a splay
            operation that changes the structure of the tree.
            Worse, this enumerator also uses a stack that can be as deep as the tree, and since the depth of a splay
            tree is in the worst case n (number of nodes), the stack can potentially be size n.
            </summary>
        </member>
        <member name="T:TreeLib.SplayTreeRange2Map`1">
            <summary>
            Implements a map, list or range collection using a splay tree. 
            </summary>
            <summary>
            Represents an sequenced collection of range-to-range pairs with associated values. Each range pair is defined by two lengths,
            one for the X sequence and one for the Y sequence.
            With regard to a particular sequence, each range occupies a particular position in the sequence, determined by the location
            where it was inserted (and any insertions/deletions that have occurred before or after it in the sequence).
            Within the sequence, the start indices of each range are determined as follows:
            The first range in the sequence starts at 0 and each subsequent range starts at the starting index of the previous range
            plus the length of the previous range. The 'extent' of the range collection is the sum of all lengths.
            The above applies separately to both the X side sequence and the Y side sequence.
            All ranges must have a lengths of at least 1, on both sides.
            </summary>
            <typeparam name="ValueType">type of the value associated with each range pair</typeparam>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a splay tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.#ctor">
            <summary>
            Create a new collection based on a splay tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.#ctor(TreeLib.SplayTreeRange2Map{`0})">
            <summary>
            Create a new collection based on a splay tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.SplayTreeRange2Map`1.Count">
            <summary>
            Returns the number of range pairs in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue range pairs.</exception>
        </member>
        <member name="P:TreeLib.SplayTreeRange2Map`1.LongCount">
            <summary>
            Returns the number of ranges in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.Clear">
            <summary>
            Removes all range pairs from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.Contains(System.Int32,TreeLib.Side)">
            <summary>
            Determines if there is a range pair in the collection starting at the index specified, with respect to the side specified.
            </summary>
            <param name="start">index to look for the start of a range at</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <returns>true if there is a range starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.TryInsert(System.Int32,TreeLib.Side,System.Int32,System.Int32,`0)">
            <summary>
            Attempt to insert a range pair defined by the given pair of lengths at the specified start index with respect to
            the specified side and with an associated value.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            The sequence of the non-specified side is also updated, by inserting the other length of the pair at the same
            rank in the sequence as on the specified side.
            </summary>
            <param name="start">the specified start index to insert before</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <param name="xLength">the length of the X side of the range pair. the length must be at least 1.</param>
            <param name="yLength">the length of the Y side of the range pair. the length must be at least 1.</param>
            <param name="value">the value to associate with the range pair</param>
            <returns>true if the range was successfully inserted</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue on either side</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.TryDelete(System.Int32,TreeLib.Side)">
            <summary>
            Attempt to delete the range pair starting at the specified index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to delete</param>
            <param name="side">the side (X or Y) to which the start index applies</param>
            <returns>true if a range pair was successfully deleted</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.TryGetLength(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Attempt to query the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies. The side also determines which length is returned</param>
            <param name="length">the length of the range from the specified side (X or Y)</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.TrySetLength(System.Int32,TreeLib.Side,System.Int32)">
            <summary>
            Attempt to change the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to modify</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="length">the new length to apply on the specified side (X or Y) of the range pair. The new length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.OverflowException">the sum of lengths on the specified side would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.TryGetValue(System.Int32,TreeLib.Side,`0@)">
            <summary>
            Attempt to query the value associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="value">value associated with the range</param>
            <returns>true if a range was found starting at the specified index on the specified side</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.TrySetValue(System.Int32,TreeLib.Side,`0)">
            <summary>
            Attempt to update the value associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to update</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="value">new value that replaces the old value associated with the range</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.TryGet(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,`0@)">
            <summary>
            Attempt to get the value and lengths associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="otherStart">out parameter receiving the start index of the range from the opposite side of that specified</param>
            <param name="xLength">out parameter receiving the length of the range on the X side</param>
            <param name="yLength">out parameter receiving the length f the range on the Y side</param>
            <param name="value">out parameter receiving the value associated with the range</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.TrySet(System.Int32,TreeLib.Side,System.Int32,System.Int32,`0)">
            <summary>
            Attempt to change the lengths and value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="side">the side with which the start parameter applies</param>
            <param name="xLength">new X-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="yLength">new Y-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="value">the value to replace the old value associated with the range</param>
            <returns>true if a range was found starting at the specified index and updated; false if the
            start was not found or the sum of lengths would have exceeded Int32.MaxValue</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.Insert(System.Int32,TreeLib.Side,System.Int32,System.Int32,`0)">
            <summary>
            Insert a range pair defined by the given pair of lengths at the specified start index with respect to
            the specified side and with an associated value.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            The sequence of the non-specified side is also updated, by inserting the other length of the pair at the same
            rank in the sequence as on the specified side.
            </summary>
            <param name="start">the specified start index to insert before</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <param name="xLength">the length of the X side of the range pair. the length must be at least 1.</param>
            <param name="yLength">the length of the Y side of the range pair. the length must be at least 1.</param>
            <param name="value">the value to associate with the range pair</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue on either side</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.Delete(System.Int32,TreeLib.Side)">
            <summary>
            Deletes the range pair starting at the specified index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to delete</param>
            <param name="side">the side (X or Y) to which the start index applies</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.GetLength(System.Int32,TreeLib.Side)">
            <summary>
            Retrieves the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies. The side also determines which length is returned</param>
            <returns>the length of the range from the specified side (X or Y)</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.SetLength(System.Int32,TreeLib.Side,System.Int32)">
            <summary>
            Changes the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to modify</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="length">the new length to apply on the specified side (X or Y) of the range pair. The new length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
            <exception cref="T:System.OverflowException">the sum of lengths on the specified side would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.GetValue(System.Int32,TreeLib.Side)">
            <summary>
            Retrieves the value associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <returns>the value associated with the range</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.SetValue(System.Int32,TreeLib.Side,`0)">
            <summary>
            Updates the value associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to update</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="value">new value that replaces the old value associated with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.Get(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,`0@)">
            <summary>
            Attempt to get the value and lengths associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="otherStart">out parameter receiving the start index of the range from the opposite side of that specified</param>
            <param name="xLength">out parameter receiving the length of the range on the X side</param>
            <param name="yLength">out parameter receiving the length f the range on the Y side</param>
            <param name="value">out parameter receiving the value associated with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.Set(System.Int32,TreeLib.Side,System.Int32,System.Int32,`0)">
            <summary>
            Changes the lengths and value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="side">the side with which the start parameter applies</param>
            <param name="xLength">new X-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="yLength">new Y-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="value">the value to replace the old value associated with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
            <exception cref="T:System.OverflowException">sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.GetExtent(TreeLib.Side)">
            <summary>
            Retrieves the extent of the sequence of ranges on the specified side. The extent is the sum of the lengths of all the ranges.
            </summary>
            <param name="side">the side (X or Y) to which the query applies.</param>
            <returns>the extent of the ranges on the specified side</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.NearestLessOrEqual(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index with respect to the specified side.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.NearestLessOrEqual(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index with respect to the specified side.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.NearestLess(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.NearestLess(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.NearestGreaterOrEqual(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.NearestGreaterOrEqual(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.NearestGreater(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.NearestGreater(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.AdjustLength(System.Int32,TreeLib.Side,System.Int32,System.Int32)">
            <summary>
            Adjust the lengths of the range starting at 'start' by adding xAdjust and yAdjust to the current lengths of the
            range. If the lengths would become 0, the range is removed.
            </summary>
            <param name="start">the start index of the range to adjust</param>
            <param name="side">which side (X or Y) the start parameter applies</param>
            <param name="xAdjust">the amount to adjust the X length by. Value may be negative to shrink the length</param>
            <param name="yAdjust">the amount to adjust the Y length by. Value may be negative to shrink the length</param>
            <returns>The adjusted length</returns>
            <exception cref="T:System.ArgumentException">There is no range starting at the index specified by 'start', or the length on
            one side would become 0 while the length on the other side would not be 0.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">one or both of the lengths would become negative</exception>
            <exception cref="T:System.OverflowException">the X or Y extent would become larger than Int32.MaxValue</exception>
        </member>
        <member name="P:TreeLib.SplayTreeRange2Map`1.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.TreeLib#Internal#INonInvasiveRange2MapInspection#GetRanges">
            <summary>
            INonInvasiveRange2MapInspection.GetRanges() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.TreeLib#Internal#INonInvasiveRange2MapInspection#Validate">
            <summary>
            INonInvasiveRange2MapInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.GetEnumerator">
            <summary>
            Get the default enumerator, which is the robust enumerator for splay trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator�s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator�s current key (i.e. in the portion of the
            collection the enumerator hasn�t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it�s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. For the Splay tree, all operations modify
            the tree structure, include queries, and will invalidate the enumerator. The complexity of the fast enumerator
            is O(1) per element, or O(N) to enumerate the entire tree.
            
            A note about splay trees and enumeration: Enumeration of splay trees is generally problematic, for two reasons.
            First, every operation on a splay tree modifies the structure of the tree, including queries. Second, splay trees
            may have depth of N in the worst case (as compared to other trees which are guaranteed to be less deep than
            approximately two times the optimal depth, or 2 lg N). The first property makes fast enumeration less useful, and
            the second property means fast enumeration may consume up to memory proportional to N for the internal stack used
            for traversal. Therefore, the robust enumerator is recommended for splay trees. The drawback is the
            robust enumerator�s O(N lg N) complexity.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.GetEnumerable(System.Int32,TreeLib.Side)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.GetEnumerable(System.Int32,TreeLib.Side,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.GetFastEnumerable(System.Int32,TreeLib.Side)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.GetFastEnumerable(System.Int32,TreeLib.Side,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.GetRobustEnumerable(System.Int32,TreeLib.Side)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRange2Map`1.GetRobustEnumerable(System.Int32,TreeLib.Side,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.SplayTreeRange2Map`1.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. The enumerator also uses a constant
            amount of memory. However, since it uses queries it is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.SplayTreeRange2Map`1.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any change to the tree invalidates it, and that *includes queries* since a query causes a splay
            operation that changes the structure of the tree.
            Worse, this enumerator also uses a stack that can be as deep as the tree, and since the depth of a splay
            tree is in the worst case n (number of nodes), the stack can potentially be size n.
            </summary>
        </member>
        <member name="T:TreeLib.SplayTreeRangeList">
            <summary>
            Implements a map, list or range collection using a splay tree. 
            </summary>
            <summary>
            Represents an sequenced collection of ranges (without associated values). Each range is defined by it's length, and occupies
            a particular position in the sequence, determined by the location where it was inserted (and any insertions/deletions that
            have occurred before or after it in the sequence). The start indices of each range are determined as follows:
            The first range in the sequence starts at 0 and each subsequent range starts at the starting index of the previous range
            plus the length of the previous range. The 'extent' of the range collection is the sum of all lengths.
            All ranges must have a length of at least 1.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a splay tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.#ctor">
            <summary>
            Create a new collection based on a splay tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.#ctor(TreeLib.SplayTreeRangeList)">
            <summary>
            Create a new collection based on a splay tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.SplayTreeRangeList.Count">
            <summary>
            Returns the number of ranges in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue ranges.</exception>
        </member>
        <member name="P:TreeLib.SplayTreeRangeList.LongCount">
            <summary>
            Returns the number of ranges in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.Clear">
            <summary>
            Removes all ranges from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.Contains(System.Int32)">
            <summary>
            Determines if there is a range in the collection starting at the specified index.
            </summary>
            <param name="start">index to look for the start of a range at</param>
            <returns>true if there is a range starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.TryInsert(System.Int32,System.Int32)">
            <summary>
            Attempt to insert a range of a given length at the specified start index.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            </summary>
            <param name="start">starting index to attempt to insert the new range at</param>
            <param name="length">length of the new range. The length must be at least 1.</param>
            <returns>true if the range was successfully inserted</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.TryDelete(System.Int32)">
            <summary>
            Attempt to delete the range starting at the specified index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of a range to attempt to delete</param>
            <returns>true if a range was successfully deleted</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.TryGetLength(System.Int32,System.Int32@)">
            <summary>
            Attempt to query the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">out parameter receiving the length of the range</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.TrySetLength(System.Int32,System.Int32)">
            <summary>
            Attempt to change the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.Insert(System.Int32,System.Int32)">
            <summary>
            Inserts a range of a given length at the specified start index.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            </summary>
            <param name="start">starting index to attempt to insert the new range at</param>
            <param name="length">length of the new range. The length must be at least 1.</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.Delete(System.Int32)">
            <summary>
            Attempt to delete the range starting at the specified index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of a range to attempt to delete</param>
            <returns>true if a range was successfully deleted</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.GetLength(System.Int32)">
            <summary>
            Retrieves the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <returns>the length of the range found at the specified start index</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.SetLength(System.Int32,System.Int32)">
            <summary>
            Changes the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.GetExtent">
            <summary>
            Retrieves the extent of the sequence of ranges. The extent is the sum of the lengths of all the ranges.
            </summary>
            <returns>the extent of the ranges</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.NearestLessOrEqual(System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.NearestLessOrEqual(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.NearestLess(System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.NearestLess(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.NearestGreaterOrEqual(System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.NearestGreaterOrEqual(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.NearestGreater(System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.NearestGreater(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.AdjustLength(System.Int32,System.Int32)">
            <summary>
            Adjust the length of the range starting at 'start' by adding 'adjust' to the current length of the
            range. If the length would become 0, the range is removed.
            </summary>
            <param name="start">the start index of the range to adjust</param>
            <param name="adjust">the amount to adjust the length by. Value may be negative to shrink the length</param>
            <returns>The adjusted length</returns>
            <exception cref="T:System.ArgumentException">There is no range starting at the index specified by 'start'.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">the length would become negative</exception>
            <exception cref="T:System.OverflowException">the extent would become larger than Int32.MaxValue</exception>
        </member>
        <member name="P:TreeLib.SplayTreeRangeList.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.TreeLib#Internal#INonInvasiveRange2MapInspection#GetRanges">
            <summary>
            INonInvasiveRange2MapInspection.GetRanges() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.TreeLib#Internal#INonInvasiveRange2MapInspection#Validate">
            <summary>
            INonInvasiveRange2MapInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.GetEnumerator">
            <summary>
            Get the default enumerator, which is the robust enumerator for splay trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator�s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator�s current key (i.e. in the portion of the
            collection the enumerator hasn�t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it�s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. For the Splay tree, all operations modify
            the tree structure, include queries, and will invalidate the enumerator. The complexity of the fast enumerator
            is O(1) per element, or O(N) to enumerate the entire tree.
            
            A note about splay trees and enumeration: Enumeration of splay trees is generally problematic, for two reasons.
            First, every operation on a splay tree modifies the structure of the tree, including queries. Second, splay trees
            may have depth of N in the worst case (as compared to other trees which are guaranteed to be less deep than
            approximately two times the optimal depth, or 2 lg N). The first property makes fast enumeration less useful, and
            the second property means fast enumeration may consume up to memory proportional to N for the internal stack used
            for traversal. Therefore, the robust enumerator is recommended for splay trees. The drawback is the
            robust enumerator�s O(N lg N) complexity.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.GetEnumerable(System.Int32)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.GetEnumerable(System.Int32,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.GetFastEnumerable(System.Int32)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.GetFastEnumerable(System.Int32,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.GetRobustEnumerable(System.Int32)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeList.GetRobustEnumerable(System.Int32,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.SplayTreeRangeList.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. The enumerator also uses a constant
            amount of memory. However, since it uses queries it is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.SplayTreeRangeList.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any change to the tree invalidates it, and that *includes queries* since a query causes a splay
            operation that changes the structure of the tree.
            Worse, this enumerator also uses a stack that can be as deep as the tree, and since the depth of a splay
            tree is in the worst case n (number of nodes), the stack can potentially be size n.
            </summary>
        </member>
        <member name="T:TreeLib.SplayTreeRangeMap`1">
            <summary>
            Implements a map, list or range collection using a splay tree. 
            </summary>
            <summary>
            Represents an sequenced collection of ranges with associated values. Each range is defined by it's length, and occupies
            a particular position in the sequence, determined by the location where it was inserted (and any insertions/deletions that
            have occurred before or after it in the sequence). The start indices of each range are determined as follows:
            The first range in the sequence starts at 0 and each subsequent range starts at the starting index of the previous range
            plus the length of the previous range. The 'extent' of the range collection is the sum of all lengths.
            All ranges must have a length of at least 1.
            </summary>
            <typeparam name="ValueType">type of the value associated with each range</typeparam>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a splay tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.#ctor">
            <summary>
            Create a new collection based on a splay tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.#ctor(TreeLib.SplayTreeRangeMap{`0})">
            <summary>
            Create a new collection based on a splay tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.SplayTreeRangeMap`1.Count">
            <summary>
            Returns the number of ranges in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue ranges.</exception>
        </member>
        <member name="P:TreeLib.SplayTreeRangeMap`1.LongCount">
            <summary>
            Returns the number of ranges in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.Clear">
            <summary>
            Removes all ranges from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.Contains(System.Int32)">
            <summary>
            Determines if there is a range in the collection starting at the specified index.
            </summary>
            <param name="start">index to look for the start of a range at</param>
            <returns>true if there is a range starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.TryInsert(System.Int32,System.Int32,`0)">
            <summary>
            Attempt to insert a range of a given length at the specified start index and with an associated value.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            </summary>
            <param name="start">starting index to attempt to insert the new range at</param>
            <param name="length">length of the new range. The length must be at least 1.</param>
            <param name="value">value to associate with the range</param>
            <returns>true if the range was successfully inserted</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.TryDelete(System.Int32)">
            <summary>
            Attempt to delete the range starting at the specified index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of a range to attempt to delete</param>
            <returns>true if a range was successfully deleted</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.TryGetLength(System.Int32,System.Int32@)">
            <summary>
            Attempt to query the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">out parameter receiving the length of the range</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.TrySetLength(System.Int32,System.Int32)">
            <summary>
            Attempt to change the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.TryGetValue(System.Int32,`0@)">
            <summary>
            Attempt to query the value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="value">value associated with the range</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.TrySetValue(System.Int32,`0)">
            <summary>
            Attempt to update the value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="value">new value that replaces the old value associated with the range</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.TryGet(System.Int32,System.Int32@,`0@)">
            <summary>
            Attempt to get the value and length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">out parameter receiving the length of the range</param>
            <param name="value">out parameter receiving the value associated with the range</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.TrySet(System.Int32,System.Int32,`0)">
            <summary>
            Attempt to change the length and value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <param name="value">the value to replace the old value associated with the range</param>
            <returns>true if a range was found starting at the specified index and updated; false if the
            start was not found or the sum of lengths would have exceeded Int32.MaxValue</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.Insert(System.Int32,System.Int32,`0)">
            <summary>
            Inserts a range of a given length at the specified start index and with an associated value.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            </summary>
            <param name="start">starting index to attempt to insert the new range at</param>
            <param name="length">length of the new range. The length must be at least 1.</param>
            <param name="value">value to associate with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.Delete(System.Int32)">
            <summary>
            Attempt to delete the range starting at the specified index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of a range to attempt to delete</param>
            <returns>true if a range was successfully deleted</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.GetLength(System.Int32)">
            <summary>
            Retrieves the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <returns>the length of the range found at the specified start index</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.SetLength(System.Int32,System.Int32)">
            <summary>
            Changes the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.GetValue(System.Int32)">
            <summary>
            Retrieves the value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <returns>the value associated with the range</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.SetValue(System.Int32,`0)">
            <summary>
            Updates the value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="value">new value that replaces the old value associated with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.Get(System.Int32,System.Int32@,`0@)">
            <summary>
            Retrieves the value and length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">out parameter receiving the length of the range</param>
            <param name="value">out parameter receiving the value associated with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.Set(System.Int32,System.Int32,`0)">
            <summary>
            Changes the length and value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <param name="value">the value to replace the old value associated with the range</param>
            <exception cref="T:System.ArgumentException">the start was not the beginning of a range</exception>
            <exception cref="T:System.OverflowException">sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.GetExtent">
            <summary>
            Retrieves the extent of the sequence of ranges. The extent is the sum of the lengths of all the ranges.
            </summary>
            <returns>the extent of the ranges</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.NearestLessOrEqual(System.Int32,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.NearestLessOrEqual(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.NearestLess(System.Int32,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.NearestLess(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.NearestGreaterOrEqual(System.Int32,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.NearestGreaterOrEqual(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.NearestGreater(System.Int32,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.NearestGreater(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.AdjustLength(System.Int32,System.Int32)">
            <summary>
            Adjust the length of the range starting at 'start' by adding 'adjust' to the current length of the
            range. If the length would become 0, the range is removed.
            </summary>
            <param name="start">the start index of the range to adjust</param>
            <param name="adjust">the amount to adjust the length by. Value may be negative to shrink the length</param>
            <returns>The adjusted length</returns>
            <exception cref="T:System.ArgumentException">There is no range starting at the index specified by 'start'.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">the length would become negative</exception>
            <exception cref="T:System.OverflowException">the extent would become larger than Int32.MaxValue</exception>
        </member>
        <member name="P:TreeLib.SplayTreeRangeMap`1.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.TreeLib#Internal#INonInvasiveRange2MapInspection#GetRanges">
            <summary>
            INonInvasiveRange2MapInspection.GetRanges() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.TreeLib#Internal#INonInvasiveRange2MapInspection#Validate">
            <summary>
            INonInvasiveRange2MapInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.GetEnumerator">
            <summary>
            Get the default enumerator, which is the robust enumerator for splay trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator�s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator�s current key (i.e. in the portion of the
            collection the enumerator hasn�t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it�s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. For the Splay tree, all operations modify
            the tree structure, include queries, and will invalidate the enumerator. The complexity of the fast enumerator
            is O(1) per element, or O(N) to enumerate the entire tree.
            
            A note about splay trees and enumeration: Enumeration of splay trees is generally problematic, for two reasons.
            First, every operation on a splay tree modifies the structure of the tree, including queries. Second, splay trees
            may have depth of N in the worst case (as compared to other trees which are guaranteed to be less deep than
            approximately two times the optimal depth, or 2 lg N). The first property makes fast enumeration less useful, and
            the second property means fast enumeration may consume up to memory proportional to N for the internal stack used
            for traversal. Therefore, the robust enumerator is recommended for splay trees. The drawback is the
            robust enumerator�s O(N lg N) complexity.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.GetEnumerable(System.Int32)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.GetEnumerable(System.Int32,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.GetFastEnumerable(System.Int32)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.GetFastEnumerable(System.Int32,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.GetRobustEnumerable(System.Int32)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRangeMap`1.GetRobustEnumerable(System.Int32,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.SplayTreeRangeMap`1.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. The enumerator also uses a constant
            amount of memory. However, since it uses queries it is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.SplayTreeRangeMap`1.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any change to the tree invalidates it, and that *includes queries* since a query causes a splay
            operation that changes the structure of the tree.
            Worse, this enumerator also uses a stack that can be as deep as the tree, and since the depth of a splay
            tree is in the worst case n (number of nodes), the stack can potentially be size n.
            </summary>
        </member>
        <member name="T:TreeLib.SplayTreeRankList`1">
            <summary>
            Implements a map, list or range collection using a splay tree. 
            </summary>
            <summary>
            Represents an ordered key collection, augmented with rank information. The rank of a key is the index it would
            be located in if all the keys in the tree were placed into a sorted array.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.#ctor(System.Collections.Generic.IComparer{`0},System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a splay tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a splay tree, with the specified capacity and allocation mode and using
            the default comparer.
            </summary>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a new collection based on a splay tree, with default allocation options and using the specified comparer.
            </summary>
            <param name="comparer">The comparer to use for sorting keys</param>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.#ctor">
            <summary>
            Create a new collection based on a splay tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.#ctor(TreeLib.SplayTreeRankList{`0})">
            <summary>
            Create a new collection based on a splay tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.SplayTreeRankList`1.Count">
            <summary>
            Returns the number of keys in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue keys.</exception>
        </member>
        <member name="P:TreeLib.SplayTreeRankList`1.LongCount">
            <summary>
            Returns the number of keys in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.Clear">
            <summary>
            Removes all keys from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.TryRemove(`0)">
            <summary>
            Attempts to remove a key from the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key was found and removed</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.TryGetKey(`0,`0@)">
            <summary>
            Attempts to get the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">the actual key contained in the collection</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.TrySetKey(`0)">
            <summary>
            Attempts to update the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.Remove(`0)">
            <summary>
            Removes a key from the collection.
            </summary>
            <param name="key">key to remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.GetKey(`0)">
            <summary>
            Retrieves the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <returns>the value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.SetKey(`0)">
            <summary>
            Updates the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.ConditionalSetOrAdd(`0,TreeLib.UpdatePredicate{`0})">
            <summary>
            Conditionally update or add a key, based on the return value from the predicate.
            ConditionalSetOrAdd is more efficient when the decision to add or update depends on the value of the item.
            </summary>
            <param name="key">The key to update or add</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the key will be added to the
            collection if it is not already in the collection. Whether true or false, if the key is in the collection, the
            ref key upon return will be used to update the key data.</param>
            <exception cref="T:System.ArgumentException">The sort order of the key was changed by the predicate</exception>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.ConditionalSetOrRemove(`0,TreeLib.UpdatePredicate{`0})">
            <summary>
            Conditionally update or add a key, based on the return value from the predicate.
            ConditionalSetOrRemove is more efficient when the decision to remove or update depends on the value of the item.
            </summary>
            <param name="key">The key to update or remove</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the key will be removed from the
            collection if it is in the collection. If the key remains in the collection, the ref key upon return will be used
            to update the key data.</param>
            <exception cref="T:System.ArgumentException">The sort order of the key was changed by the predicate</exception>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key)</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key)</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.NearestLessOrEqual(`0,`0@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.NearestLess(`0,`0@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.NearestGreaterOrEqual(`0,`0@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.NearestGreater(`0,`0@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.TryAdd(`0)">
            <summary>
            Attempts to add a key to the collection. If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <returns>true if the key was added; false if the key was already present</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.TryGet(`0,`0@,System.Int32@)">
            <summary>
            Attempts to get the actual key data and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">the actual key contained in the collection</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.TryGetKeyByRank(System.Int32,`0@)">
            <summary>
            Retrieves the key at the specified rank index.
            If all keys in the collection were converted to a sorted array, this would be the equivalent of array[rank].
            </summary>
            <param name="rank">the rank index to query</param>
            <param name="key">an out paramter receiving the key at the specified rank index</param>
            <returns>the key located at that index</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.Add(`0)">
            <summary>
            Adds a key to the collection.
            </summary>
            <param name="key">key to insert</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.Get(`0,`0@,System.Int32@)">
            <summary>
            Retrieves the actual key data and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">the actual key contained in the collection</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.GetKeyByRank(System.Int32)">
            <summary>
            Retrieves the key at the specified rank index.
            If all keys in the collection were converted to a sorted array, this would be the equivalent of array[rank].
            </summary>
            <param name="rank">the rank index to query</param>
            <returns>the key located at that index</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.AdjustCount(`0,System.Int32)">
            <summary>
            Adjusts the rank count associated with the key-value pair. The countAdjust added to the existing count.
            For a RankMap, the only valid values are 0 (which does nothing) and -1 (which removes the key-value pair).
            </summary>
            <param name="key">key identifying the key-value pair to update</param>
            <param name="countAdjust">adjustment that is added to the count</param>
            <returns>The adjusted count</returns>
            <exception cref="T:System.ArgumentException">if the count is an invalid value or the key does not exist in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="P:TreeLib.SplayTreeRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.TreeLib#Internal#INonInvasiveMultiRankMapInspection#GetRanks">
            <summary>
            INonInvasiveMultiRankMapInspection.GetRanks() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.TreeLib#Internal#INonInvasiveMultiRankMapInspection#Validate">
            <summary>
            INonInvasiveMultiRankMapInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.GetEnumerator">
            <summary>
            Get the default enumerator, which is the robust enumerator for splay trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator�s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator�s current key (i.e. in the portion of the
            collection the enumerator hasn�t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it�s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. For the Splay tree, all operations modify
            the tree structure, include queries, and will invalidate the enumerator. The complexity of the fast enumerator
            is O(1) per element, or O(N) to enumerate the entire tree.
            
            A note about splay trees and enumeration: Enumeration of splay trees is generally problematic, for two reasons.
            First, every operation on a splay tree modifies the structure of the tree, including queries. Second, splay trees
            may have depth of N in the worst case (as compared to other trees which are guaranteed to be less deep than
            approximately two times the optimal depth, or 2 lg N). The first property makes fast enumeration less useful, and
            the second property means fast enumeration may consume up to memory proportional to N for the internal stack used
            for traversal. Therefore, the robust enumerator is recommended for splay trees. The drawback is the
            robust enumerator�s O(N lg N) complexity.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.GetEnumerable(`0)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.GetEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.GetFastEnumerable(`0)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.GetFastEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.GetRobustEnumerable(`0)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankList`1.GetRobustEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.SplayTreeRankList`1.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. The enumerator also uses a constant
            amount of memory. However, since it uses queries it is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.SplayTreeRankList`1.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any change to the tree invalidates it, and that *includes queries* since a query causes a splay
            operation that changes the structure of the tree.
            Worse, this enumerator also uses a stack that can be as deep as the tree, and since the depth of a splay
            tree is in the worst case n (number of nodes), the stack can potentially be size n.
            </summary>
        </member>
        <member name="T:TreeLib.SplayTreeRankMap`2">
            <summary>
            Implements a map, list or range collection using a splay tree. 
            </summary>
            <summary>
            Represents an ordered key-value mapping, augmented with rank information. The rank of a key-value pair is the index it would
            be located in if all the key-value pairs in the tree were placed into a sorted array.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
            <typeparam name="ValueType">Type of value associated with each entry.</typeparam>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.#ctor(System.Collections.Generic.IComparer{`0},System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a splay tree, explicitly configured.
            </summary>
            <param name="comparer">The comparer to use for sorting keys (present only for keyed collections)</param>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.#ctor(System.UInt32,TreeLib.AllocationMode)">
            <summary>
            Create a new collection based on a splay tree, with the specified capacity and allocation mode and using
            the default comparer.
            </summary>
            <param name="capacity">
            For PreallocatedFixed mode, the maximum capacity of the tree, the memory for which is
            preallocated at construction time; exceeding that capacity will result in an OutOfMemory exception.
            For DynamicDiscard or DynamicRetainFreelist, the number of nodes to pre-allocate at construction time (the collection
            is permitted to exceed that capacity, in which case additional nodes will be allocated from the heap).
            For DynamicDiscard, nodes are unreferenced upon removal, allowing the garbage collector to reclaim the memory at any time.
            For DynamicRetainFreelist or PreallocatedFixed, upon removal nodes are returned to a free list from which subsequent
            nodes will be allocated.
            </param>
            <param name="allocationMode">The allocation mode (see capacity)</param>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a new collection based on a splay tree, with default allocation options and using the specified comparer.
            </summary>
            <param name="comparer">The comparer to use for sorting keys</param>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.#ctor">
            <summary>
            Create a new collection based on a splay tree, with default allocation options and allocation mode and using
            the default comparer (applicable only to keyed collections).
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.#ctor(TreeLib.SplayTreeRankMap{`0,`1})">
            <summary>
            Create a new collection based on a splay tree that is an exact clone of the provided collection, including in
            allocation mode, content, structure, capacity and free list state, and comparer.
            </summary>
            <param name="original">the tree to copy</param>
        </member>
        <member name="P:TreeLib.SplayTreeRankMap`2.Count">
            <summary>
            Returns the number of key-value pairs in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue key-value pairs.</exception>
        </member>
        <member name="P:TreeLib.SplayTreeRankMap`2.LongCount">
            <summary>
            Returns the number of key-value pairs in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.Clear">
            <summary>
            Removes all key-value pairs from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.TryRemove(`0)">
            <summary>
            Attempts to remove a key-value pair from the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key-value pair was found and removed</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to get the value associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.TrySetValue(`0,`1)">
            <summary>
            Attempts to set the value associated with a key in the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <returns>true if the key-value pair was found and the value was updated</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.Remove(`0)">
            <summary>
            Removes a key-value pair from the collection.
            </summary>
            <param name="key">key of the key-value pair to remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.GetValue(`0)">
            <summary>
            Retrieves the value associated with a key in the collection
            </summary>
            <param name="key">key to search for</param>
            <returns>the value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.SetValue(`0,`1)">
            <summary>
            Updates the value associated with a key in the collection
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.ConditionalSetOrAdd(`0,TreeLib.UpdatePredicate{`0,`1})">
            <summary>
            Conditionally update or add an item, based on the return value from the predicate.
            ConditionalSetOrAdd is more efficient when the decision to add or update depends on the value of the item.
            </summary>
            <param name="key">The key of the item to update or add</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the item will be added to the
            collection if it is not already in the collection. Whether true or false, if the item is in the collection, the
            ref value upon return will be used to update the item.</param>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.ConditionalSetOrRemove(`0,TreeLib.UpdatePredicate{`0,`1})">
            <summary>
            Conditionally update or add an item, based on the return value from the predicate.
            ConditionalSetOrRemove is more efficient when the decision to remove or update depends on the value of the item.
            </summary>
            <param name="key">The key of the item to update or remove</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the item will be removed from the
            collection if it is in the collection. If the item remains in the collection, the ref value upon return will be used
            to update the item.</param>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.Least(`0@,`1@)">
            <summary>
            Retrieves the lowest in the collection (in sort order) and the value associated with it.
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.Greatest(`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection (in sort order) and the value associated with it.
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.NearestLessOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.NearestLessOrEqual(`0,`0@,`1@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key and
            the value and rank associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.NearestLess(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.NearestLess(`0,`0@,`1@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key and
            the value and rank  associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.NearestGreaterOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.NearestGreaterOrEqual(`0,`0@,`1@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key and
            the value and rank  associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.NearestGreater(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.NearestGreater(`0,`0@,`1@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key and
            the value and rank  associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.TryAdd(`0,`1)">
            <summary>
            Attempts to add a key-value pair to the collection. If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="value">value to associate with the key</param>
            <returns>true if the key-value pair was added; false if the key was already present</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.TryGet(`0,`1@,System.Int32@)">
            <summary>
            Attempts to get the value and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.TryGetKeyByRank(System.Int32,`0@)">
            <summary>
            Attempts to return the key of a key-value pair at the specified rank index.
            If all key-value pairs in the collection were converted to a sorted array, this would be the equivalent of array[rank].Key.
            </summary>
            <param name="rank">the rank index to query</param>
            <param name="key">the key located at that index</param>
            <returns>true if there is an element at the the specified index</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.Add(`0,`1)">
            <summary>
            Adds a key-value pair to the collection.
            </summary>
            <param name="key">key to insert</param>
            <param name="value">value to associate with the key</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.Get(`0,`1@,System.Int32@)">
            <summary>
            Retrieves the value and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.GetKeyByRank(System.Int32)">
            <summary>
            Retrieves the key of a key-value pair at the specified rank index.
            If all key-value pairs in the collection were converted to a sorted array, this would be the equivalent of array[rank].Key.
            </summary>
            <param name="rank">the rank index to query</param>
            <returns>the key located at that index</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.AdjustCount(`0,System.Int32)">
            <summary>
            Adjusts the rank count associated with the key-value pair. The countAdjust added to the existing count.
            For a RankMap, the only valid values are 0 (which does nothing) and -1 (which removes the key-value pair).
            </summary>
            <param name="key">key identifying the key-value pair to update</param>
            <param name="countAdjust">adjustment that is added to the count</param>
            <returns>The adjusted count</returns>
            <exception cref="T:System.ArgumentException">if the count is an invalid value or the key does not exist in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="P:TreeLib.SplayTreeRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#Root">
            <summary>
            INonInvasiveTreeInspection.Root is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetLeftChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetLeftChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetRightChild(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetRightChild() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetKey(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetKey() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetValue(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetValue() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#GetMetadata(System.Object)">
            <summary>
            INonInvasiveTreeInspection.GetMetadata() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.TreeLib#Internal#INonInvasiveTreeInspection#Validate">
            <summary>
            INonInvasiveTreeInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.TreeLib#Internal#INonInvasiveMultiRankMapInspection#GetRanks">
            <summary>
            INonInvasiveMultiRankMapInspection.GetRanks() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.TreeLib#Internal#INonInvasiveMultiRankMapInspection#Validate">
            <summary>
            INonInvasiveMultiRankMapInspection.Validate() is a diagnostic method intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.GetEnumerator">
            <summary>
            Get the default enumerator, which is the robust enumerator for splay trees.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.GetRobustEnumerable">
            <summary>
            Get the robust enumerator. The robust enumerator uses an internal key cursor and queries the tree using the NextGreater()
            method to advance the enumerator. This enumerator is robust because it tolerates changes to the underlying tree. If a key
            is inserted or removed and it comes before the enumerator�s current key in sorting order, it will have no affect on the
            enumerator. If a key is inserted or removed and it comes after the enumerator�s current key (i.e. in the portion of the
            collection the enumerator hasn�t visited yet), the enumerator will include the key if inserted or skip the key if removed.
            Because the enumerator queries the tree for each element it�s running time per element is O(lg N), or O(N lg N) to
            enumerate the entire tree.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.GetFastEnumerable">
            <summary>
            Get the fast enumerator. The fast enumerator uses an internal stack of nodes to peform in-order traversal of the
            tree structure. Because it uses the tree structure, it is invalidated if the tree is modified by an insertion or
            deletion and will throw an InvalidOperationException when next advanced. For the Splay tree, all operations modify
            the tree structure, include queries, and will invalidate the enumerator. The complexity of the fast enumerator
            is O(1) per element, or O(N) to enumerate the entire tree.
            
            A note about splay trees and enumeration: Enumeration of splay trees is generally problematic, for two reasons.
            First, every operation on a splay tree modifies the structure of the tree, including queries. Second, splay trees
            may have depth of N in the worst case (as compared to other trees which are guaranteed to be less deep than
            approximately two times the optimal depth, or 2 lg N). The first property makes fast enumeration less useful, and
            the second property means fast enumeration may consume up to memory proportional to N for the internal stack used
            for traversal. Therefore, the robust enumerator is recommended for splay trees. The drawback is the
            robust enumerator�s O(N lg N) complexity.
            </summary>
            <returns>An IEnumerable which can be used in a foreach statement</returns>
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.GetEnumerable(`0)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.GetEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.GetFastEnumerable(`0)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.GetFastEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.GetRobustEnumerable(`0)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.SplayTreeRankMap`2.GetRobustEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.SplayTreeRankMap`2.RobustEnumerator">
            <summary>
            This enumerator is robust in that it can continue to walk the tree even in the face of changes, because
            it keeps a current key and uses NearestGreater to find the next one. The enumerator also uses a constant
            amount of memory. However, since it uses queries it is slow, O(n lg(n)) to enumerate the entire tree.
            </summary>
        </member>
        <member name="T:TreeLib.SplayTreeRankMap`2.FastEnumerator">
            <summary>
            This enumerator is fast because it uses an in-order traversal of the tree that has O(1) cost per element.
            However, any change to the tree invalidates it, and that *includes queries* since a query causes a splay
            operation that changes the structure of the tree.
            Worse, this enumerator also uses a stack that can be as deep as the tree, and since the depth of a splay
            tree is in the worst case n (number of nodes), the stack can potentially be size n.
            </summary>
        </member>
    </members>
</doc>
