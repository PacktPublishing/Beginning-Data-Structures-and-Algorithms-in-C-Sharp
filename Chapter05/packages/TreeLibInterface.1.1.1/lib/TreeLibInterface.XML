<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TreeLibInterface</name>
    </assembly>
    <members>
        <member name="T:TreeLib.Internal.INonInvasiveTreeInspection">
            <summary>
            INonInvasiveTreeInspection is a diagnostic interface intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="T:TreeLib.Internal.Range">
            <summary>
            Range is a diagnostic interface intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="T:TreeLib.Internal.RangeLong">
            <summary>
            RangeLong is a diagnostic interface intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="T:TreeLib.Internal.Range2MapEntry">
            <summary>
            Range2MapEntry is a diagnostic interface intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="T:TreeLib.Internal.Range2MapEntryLong">
            <summary>
            Range2MapEntryLong is a diagnostic interface intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="T:TreeLib.Internal.INonInvasiveRange2MapInspection">
            <summary>
            INonInvasiveRange2MapInspection is a diagnostic interface intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="T:TreeLib.Internal.INonInvasiveRange2MapInspectionLong">
            <summary>
            INonInvasiveRange2MapInspectionLong is a diagnostic interface intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="T:TreeLib.Internal.MultiRankMapEntry">
            <summary>
            MultiRankMapEntry is a diagnostic interface intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="T:TreeLib.Internal.MultiRankMapEntryLong">
            <summary>
            MultiRankMapEntryLong is a diagnostic interface intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="T:TreeLib.Internal.INonInvasiveMultiRankMapInspection">
            <summary>
            INonInvasiveMultiRankMapInspection is a diagnostic interface intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="T:TreeLib.Internal.INonInvasiveMultiRankMapInspectionLong">
            <summary>
            INonInvasiveMultiRankMapInspectionLong is a diagnostic interface intended to be used ONLY for validation of trees
            during unit testing. It is not intended for consumption by users of the library and there is no
            guarrantee that it will be supported in future versions.
            </summary>
        </member>
        <member name="T:TreeLib.EntryList`1">
            <summary>
            A type defining the struct returned for each item in a tree by an enumerator. The struct contains properties
            for all relevant per-item data, including one or more of key, value, rank/count, and/or range start/length, as
            appropriate for the type of collection.
            </summary>
        </member>
        <member name="P:TreeLib.EntryList`1.Key">
            <summary>
            Returns the key associated with a key-value pair mapping, or the key associated with a key-only collection.
            </summary>
        </member>
        <member name="T:TreeLib.EntryMap`2">
            <summary>
            A type defining the struct returned for each item in a tree by an enumerator. The struct contains properties
            for all relevant per-item data, including one or more of key, value, rank/count, and/or range start/length, as
            appropriate for the type of collection.
            </summary>
        </member>
        <member name="P:TreeLib.EntryMap`2.Key">
            <summary>
            Returns the key associated with a key-value pair mapping, or the key associated with a key-only collection.
            </summary>
        </member>
        <member name="P:TreeLib.EntryMap`2.Value">
            <summary>
            Returns the value associated with a key-value pair mapping.
            </summary>
        </member>
        <member name="T:TreeLib.EntryMultiRankList`1">
            <summary>
            A type defining the struct returned for each item in a tree by an enumerator. The struct contains properties
            for all relevant per-item data, including one or more of key, value, rank/count, and/or range start/length, as
            appropriate for the type of collection.
            </summary>
        </member>
        <member name="P:TreeLib.EntryMultiRankList`1.Key">
            <summary>
            Returns the key associated with a key-value pair mapping, or the key associated with a key-only collection.
            </summary>
        </member>
        <member name="P:TreeLib.EntryMultiRankList`1.Rank">
            <summary>
            Returns the rank of an item in a rank collection, or the start of a range in a range collection
            (for range-to-range mapping, returns the X side start)
            </summary>
        </member>
        <member name="P:TreeLib.EntryMultiRankList`1.Count">
            <summary>
            Returns the count of an item in a multi-rank collection, or the length of a range in a range collection
            (for range-to-range mapping, returns the X side length)
            </summary>
        </member>
        <member name="T:TreeLib.EntryMultiRankListLong`1">
            <summary>
            A type defining the struct returned for each item in a tree by an enumerator. The struct contains properties
            for all relevant per-item data, including one or more of key, value, rank/count, and/or range start/length, as
            appropriate for the type of collection.
            </summary>
        </member>
        <member name="P:TreeLib.EntryMultiRankListLong`1.Key">
            <summary>
            Returns the key associated with a key-value pair mapping, or the key associated with a key-only collection.
            </summary>
        </member>
        <member name="P:TreeLib.EntryMultiRankListLong`1.Rank">
            <summary>
            Returns the rank of an item in a rank collection, or the start of a range in a range collection
            (for range-to-range mapping, returns the X side start)
            </summary>
        </member>
        <member name="P:TreeLib.EntryMultiRankListLong`1.Count">
            <summary>
            Returns the count of an item in a multi-rank collection, or the length of a range in a range collection
            (for range-to-range mapping, returns the X side length)
            </summary>
        </member>
        <member name="T:TreeLib.EntryMultiRankMap`2">
            <summary>
            A type defining the struct returned for each item in a tree by an enumerator. The struct contains properties
            for all relevant per-item data, including one or more of key, value, rank/count, and/or range start/length, as
            appropriate for the type of collection.
            </summary>
        </member>
        <member name="P:TreeLib.EntryMultiRankMap`2.Key">
            <summary>
            Returns the key associated with a key-value pair mapping, or the key associated with a key-only collection.
            </summary>
        </member>
        <member name="P:TreeLib.EntryMultiRankMap`2.Value">
            <summary>
            Returns the value associated with a key-value pair mapping.
            </summary>
        </member>
        <member name="P:TreeLib.EntryMultiRankMap`2.Rank">
            <summary>
            Returns the rank of an item in a rank collection, or the start of a range in a range collection
            (for range-to-range mapping, returns the X side start)
            </summary>
        </member>
        <member name="P:TreeLib.EntryMultiRankMap`2.Count">
            <summary>
            Returns the count of an item in a multi-rank collection, or the length of a range in a range collection
            (for range-to-range mapping, returns the X side length)
            </summary>
        </member>
        <member name="T:TreeLib.EntryMultiRankMapLong`2">
            <summary>
            A type defining the struct returned for each item in a tree by an enumerator. The struct contains properties
            for all relevant per-item data, including one or more of key, value, rank/count, and/or range start/length, as
            appropriate for the type of collection.
            </summary>
        </member>
        <member name="P:TreeLib.EntryMultiRankMapLong`2.Key">
            <summary>
            Returns the key associated with a key-value pair mapping, or the key associated with a key-only collection.
            </summary>
        </member>
        <member name="P:TreeLib.EntryMultiRankMapLong`2.Value">
            <summary>
            Returns the value associated with a key-value pair mapping.
            </summary>
        </member>
        <member name="P:TreeLib.EntryMultiRankMapLong`2.Rank">
            <summary>
            Returns the rank of an item in a rank collection, or the start of a range in a range collection
            (for range-to-range mapping, returns the X side start)
            </summary>
        </member>
        <member name="P:TreeLib.EntryMultiRankMapLong`2.Count">
            <summary>
            Returns the count of an item in a multi-rank collection, or the length of a range in a range collection
            (for range-to-range mapping, returns the X side length)
            </summary>
        </member>
        <member name="T:TreeLib.EntryRange2List">
            <summary>
            A type defining the struct returned for each item in a tree by an enumerator. The struct contains properties
            for all relevant per-item data, including one or more of key, value, rank/count, and/or range start/length, as
            appropriate for the type of collection.
            </summary>
        </member>
        <member name="P:TreeLib.EntryRange2List.XStart">
            <summary>
            Returns the rank of an item in a rank collection, or the start of a range in a range collection
            (for range-to-range mapping, returns the X side start)
            </summary>
        </member>
        <member name="P:TreeLib.EntryRange2List.XLength">
            <summary>
            Returns the count of an item in a multi-rank collection, or the length of a range in a range collection
            (for range-to-range mapping, returns the X side length)
            </summary>
        </member>
        <member name="P:TreeLib.EntryRange2List.YStart">
            <summary>
            Returns the Y side start of a range in a range-to-range mapping collection
            </summary>
        </member>
        <member name="P:TreeLib.EntryRange2List.YLength">
            <summary>
            Returns the Y side length of a range in a range-to-range mapping collection
            </summary>
        </member>
        <member name="T:TreeLib.EntryRange2ListLong">
            <summary>
            A type defining the struct returned for each item in a tree by an enumerator. The struct contains properties
            for all relevant per-item data, including one or more of key, value, rank/count, and/or range start/length, as
            appropriate for the type of collection.
            </summary>
        </member>
        <member name="P:TreeLib.EntryRange2ListLong.XStart">
            <summary>
            Returns the rank of an item in a rank collection, or the start of a range in a range collection
            (for range-to-range mapping, returns the X side start)
            </summary>
        </member>
        <member name="P:TreeLib.EntryRange2ListLong.XLength">
            <summary>
            Returns the count of an item in a multi-rank collection, or the length of a range in a range collection
            (for range-to-range mapping, returns the X side length)
            </summary>
        </member>
        <member name="P:TreeLib.EntryRange2ListLong.YStart">
            <summary>
            Returns the Y side start of a range in a range-to-range mapping collection
            </summary>
        </member>
        <member name="P:TreeLib.EntryRange2ListLong.YLength">
            <summary>
            Returns the Y side length of a range in a range-to-range mapping collection
            </summary>
        </member>
        <member name="T:TreeLib.EntryRange2Map`1">
            <summary>
            A type defining the struct returned for each item in a tree by an enumerator. The struct contains properties
            for all relevant per-item data, including one or more of key, value, rank/count, and/or range start/length, as
            appropriate for the type of collection.
            </summary>
        </member>
        <member name="P:TreeLib.EntryRange2Map`1.Value">
            <summary>
            Returns the value associated with a key-value pair mapping.
            </summary>
        </member>
        <member name="P:TreeLib.EntryRange2Map`1.XStart">
            <summary>
            Returns the rank of an item in a rank collection, or the start of a range in a range collection
            (for range-to-range mapping, returns the X side start)
            </summary>
        </member>
        <member name="P:TreeLib.EntryRange2Map`1.XLength">
            <summary>
            Returns the count of an item in a multi-rank collection, or the length of a range in a range collection
            (for range-to-range mapping, returns the X side length)
            </summary>
        </member>
        <member name="P:TreeLib.EntryRange2Map`1.YStart">
            <summary>
            Returns the Y side start of a range in a range-to-range mapping collection
            </summary>
        </member>
        <member name="P:TreeLib.EntryRange2Map`1.YLength">
            <summary>
            Returns the Y side length of a range in a range-to-range mapping collection
            </summary>
        </member>
        <member name="T:TreeLib.EntryRange2MapLong`1">
            <summary>
            A type defining the struct returned for each item in a tree by an enumerator. The struct contains properties
            for all relevant per-item data, including one or more of key, value, rank/count, and/or range start/length, as
            appropriate for the type of collection.
            </summary>
        </member>
        <member name="P:TreeLib.EntryRange2MapLong`1.Value">
            <summary>
            Returns the value associated with a key-value pair mapping.
            </summary>
        </member>
        <member name="P:TreeLib.EntryRange2MapLong`1.XStart">
            <summary>
            Returns the rank of an item in a rank collection, or the start of a range in a range collection
            (for range-to-range mapping, returns the X side start)
            </summary>
        </member>
        <member name="P:TreeLib.EntryRange2MapLong`1.XLength">
            <summary>
            Returns the count of an item in a multi-rank collection, or the length of a range in a range collection
            (for range-to-range mapping, returns the X side length)
            </summary>
        </member>
        <member name="P:TreeLib.EntryRange2MapLong`1.YStart">
            <summary>
            Returns the Y side start of a range in a range-to-range mapping collection
            </summary>
        </member>
        <member name="P:TreeLib.EntryRange2MapLong`1.YLength">
            <summary>
            Returns the Y side length of a range in a range-to-range mapping collection
            </summary>
        </member>
        <member name="T:TreeLib.EntryRangeList">
            <summary>
            A type defining the struct returned for each item in a tree by an enumerator. The struct contains properties
            for all relevant per-item data, including one or more of key, value, rank/count, and/or range start/length, as
            appropriate for the type of collection.
            </summary>
        </member>
        <member name="P:TreeLib.EntryRangeList.Start">
            <summary>
            Returns the rank of an item in a rank collection, or the start of a range in a range collection
            (for range-to-range mapping, returns the X side start)
            </summary>
        </member>
        <member name="P:TreeLib.EntryRangeList.Length">
            <summary>
            Returns the count of an item in a multi-rank collection, or the length of a range in a range collection
            (for range-to-range mapping, returns the X side length)
            </summary>
        </member>
        <member name="T:TreeLib.EntryRangeListLong">
            <summary>
            A type defining the struct returned for each item in a tree by an enumerator. The struct contains properties
            for all relevant per-item data, including one or more of key, value, rank/count, and/or range start/length, as
            appropriate for the type of collection.
            </summary>
        </member>
        <member name="P:TreeLib.EntryRangeListLong.Start">
            <summary>
            Returns the rank of an item in a rank collection, or the start of a range in a range collection
            (for range-to-range mapping, returns the X side start)
            </summary>
        </member>
        <member name="P:TreeLib.EntryRangeListLong.Length">
            <summary>
            Returns the count of an item in a multi-rank collection, or the length of a range in a range collection
            (for range-to-range mapping, returns the X side length)
            </summary>
        </member>
        <member name="T:TreeLib.EntryRangeMap`1">
            <summary>
            A type defining the struct returned for each item in a tree by an enumerator. The struct contains properties
            for all relevant per-item data, including one or more of key, value, rank/count, and/or range start/length, as
            appropriate for the type of collection.
            </summary>
        </member>
        <member name="P:TreeLib.EntryRangeMap`1.Value">
            <summary>
            Returns the value associated with a key-value pair mapping.
            </summary>
        </member>
        <member name="P:TreeLib.EntryRangeMap`1.Start">
            <summary>
            Returns the rank of an item in a rank collection, or the start of a range in a range collection
            (for range-to-range mapping, returns the X side start)
            </summary>
        </member>
        <member name="P:TreeLib.EntryRangeMap`1.Length">
            <summary>
            Returns the count of an item in a multi-rank collection, or the length of a range in a range collection
            (for range-to-range mapping, returns the X side length)
            </summary>
        </member>
        <member name="T:TreeLib.EntryRangeMapLong`1">
            <summary>
            A type defining the struct returned for each item in a tree by an enumerator. The struct contains properties
            for all relevant per-item data, including one or more of key, value, rank/count, and/or range start/length, as
            appropriate for the type of collection.
            </summary>
        </member>
        <member name="P:TreeLib.EntryRangeMapLong`1.Value">
            <summary>
            Returns the value associated with a key-value pair mapping.
            </summary>
        </member>
        <member name="P:TreeLib.EntryRangeMapLong`1.Start">
            <summary>
            Returns the rank of an item in a rank collection, or the start of a range in a range collection
            (for range-to-range mapping, returns the X side start)
            </summary>
        </member>
        <member name="P:TreeLib.EntryRangeMapLong`1.Length">
            <summary>
            Returns the count of an item in a multi-rank collection, or the length of a range in a range collection
            (for range-to-range mapping, returns the X side length)
            </summary>
        </member>
        <member name="T:TreeLib.EntryRankList`1">
            <summary>
            A type defining the struct returned for each item in a tree by an enumerator. The struct contains properties
            for all relevant per-item data, including one or more of key, value, rank/count, and/or range start/length, as
            appropriate for the type of collection.
            </summary>
        </member>
        <member name="P:TreeLib.EntryRankList`1.Key">
            <summary>
            Returns the key associated with a key-value pair mapping, or the key associated with a key-only collection.
            </summary>
        </member>
        <member name="P:TreeLib.EntryRankList`1.Rank">
            <summary>
            Returns the rank of an item in a rank collection, or the start of a range in a range collection
            (for range-to-range mapping, returns the X side start)
            </summary>
        </member>
        <member name="T:TreeLib.EntryRankListLong`1">
            <summary>
            A type defining the struct returned for each item in a tree by an enumerator. The struct contains properties
            for all relevant per-item data, including one or more of key, value, rank/count, and/or range start/length, as
            appropriate for the type of collection.
            </summary>
        </member>
        <member name="P:TreeLib.EntryRankListLong`1.Key">
            <summary>
            Returns the key associated with a key-value pair mapping, or the key associated with a key-only collection.
            </summary>
        </member>
        <member name="P:TreeLib.EntryRankListLong`1.Rank">
            <summary>
            Returns the rank of an item in a rank collection, or the start of a range in a range collection
            (for range-to-range mapping, returns the X side start)
            </summary>
        </member>
        <member name="T:TreeLib.EntryRankMap`2">
            <summary>
            A type defining the struct returned for each item in a tree by an enumerator. The struct contains properties
            for all relevant per-item data, including one or more of key, value, rank/count, and/or range start/length, as
            appropriate for the type of collection.
            </summary>
        </member>
        <member name="P:TreeLib.EntryRankMap`2.Key">
            <summary>
            Returns the key associated with a key-value pair mapping, or the key associated with a key-only collection.
            </summary>
        </member>
        <member name="P:TreeLib.EntryRankMap`2.Value">
            <summary>
            Returns the value associated with a key-value pair mapping.
            </summary>
        </member>
        <member name="P:TreeLib.EntryRankMap`2.Rank">
            <summary>
            Returns the rank of an item in a rank collection, or the start of a range in a range collection
            (for range-to-range mapping, returns the X side start)
            </summary>
        </member>
        <member name="T:TreeLib.EntryRankMapLong`2">
            <summary>
            A type defining the struct returned for each item in a tree by an enumerator. The struct contains properties
            for all relevant per-item data, including one or more of key, value, rank/count, and/or range start/length, as
            appropriate for the type of collection.
            </summary>
        </member>
        <member name="P:TreeLib.EntryRankMapLong`2.Key">
            <summary>
            Returns the key associated with a key-value pair mapping, or the key associated with a key-only collection.
            </summary>
        </member>
        <member name="P:TreeLib.EntryRankMapLong`2.Value">
            <summary>
            Returns the value associated with a key-value pair mapping.
            </summary>
        </member>
        <member name="P:TreeLib.EntryRankMapLong`2.Rank">
            <summary>
            Returns the rank of an item in a rank collection, or the start of a range in a range collection
            (for range-to-range mapping, returns the X side start)
            </summary>
        </member>
        <member name="T:TreeLib.AllocationMode">
            <summary>
            Specifies the manner in which nodes within the tree are allocated and freed.
            </summary>
        </member>
        <member name="F:TreeLib.AllocationMode.DynamicDiscard">
            <summary>
            Nodes are allocated from the heap as need and discarded when removed from the tree. The garbage
            collector can reclaim the memory as soon as the node is removed.
            </summary>
        </member>
        <member name="F:TreeLib.AllocationMode.DynamicRetainFreelist">
            <summary>
            Nodes are allocated either from a free list of existing nodes, or from the heap as need. When removed from
            the tree, the storage for the node is returned to the free list.
            </summary>
        </member>
        <member name="F:TreeLib.AllocationMode.PreallocatedFixed">
            <summary>
            Nodes are allocated from a free list as needed and returned to the free list when removed from the tree.
            The free list is initialized with a fixed number of entries (specified to the constructor of the tree).
            An OutOfMemory exception will be thrown if there is an attempt to add more nodes to the tree than were
            initially allocated to the free list.
            </summary>
        </member>
        <member name="T:TreeLib.UpdatePredicate`2">
            <summary>
            Action for updating the key-value pair in a map.
            </summary>
            <typeparam name="KeyType">The type of the key</typeparam>
            <typeparam name="ValueType">The type of the value</typeparam>
            <param name="key">The key for the item to update</param>
            <param name="value">The value to optionally update</param>
            <param name="resident">True if the item is in the collection when the predicate is invoked</param>
            <returns>True to add the item to the collection; otherwise false. If the item is already in the collection, it will remain
            in the collection. In all cases, the value upon return will be applied to the item if it is in the collection.</returns>
        </member>
        <member name="T:TreeLib.UpdatePredicate`1">
            <summary>
            Action for updating the key in a list.
            </summary>
            <typeparam name="KeyType">The type of the key</typeparam>
            <param name="key">The key to update</param>
            <param name="resident">True if the item is in the collection when the predicate is invoked</param>
            <returns>True to add the key to the collection; otherwise false. If the key is already in the collection, it will remain
            in the collection. In all cases, the new key data upon return will be applied if it is in the collection.</returns>
        </member>
        <member name="T:TreeLib.IOrderedMap`2">
            <summary>
            Represents an ordered key-value mapping.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
            <typeparam name="ValueType">Type of value associated with each entry.</typeparam>
        </member>
        <member name="P:TreeLib.IOrderedMap`2.Count">
            <summary>
            Returns the number of key-value pairs in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue key-value pairs.</exception>
        </member>
        <member name="P:TreeLib.IOrderedMap`2.LongCount">
            <summary>
            Returns the number of key-value pairs in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IOrderedMap`2.Clear">
            <summary>
            Removes all key-value pairs from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IOrderedMap`2.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.IOrderedMap`2.SetOrAddValue(`0,`1)">
            <summary>
            Either set the value associated with a key (if the key is already present in the collection)
            or insert a new key-value pair into the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="value">value to associate with the key</param>
            <returns>true if key was not present and key-value pair was added; false if key-value pair was already present and value was updated</returns>
        </member>
        <member name="M:TreeLib.IOrderedMap`2.TryAdd(`0,`1)">
            <summary>
            Attempts to add a key-value pair to the collection. If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="value">value to associate with the key</param>
            <returns>true if the key-value pair was added; false if the key was already present</returns>
        </member>
        <member name="M:TreeLib.IOrderedMap`2.TryRemove(`0)">
            <summary>
            Attempts to remove a key-value pair from the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key-value pair was found and removed</returns>
        </member>
        <member name="M:TreeLib.IOrderedMap`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to get the value associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.IOrderedMap`2.TrySetValue(`0,`1)">
            <summary>
            Attempts to set the value associated with a key in the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <returns>true if the key-value pair was found and the value was updated</returns>
        </member>
        <member name="M:TreeLib.IOrderedMap`2.Add(`0,`1)">
            <summary>
            Adds a key-value pair to the collection.
            </summary>
            <param name="key">key to insert</param>
            <param name="value">value to associate with the key</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
        </member>
        <member name="M:TreeLib.IOrderedMap`2.Remove(`0)">
            <summary>
            Removes a key-value pair from the collection.
            </summary>
            <param name="key">key of the key-value pair to remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IOrderedMap`2.GetValue(`0)">
            <summary>
            Retrieves the value associated with a key in the collection
            </summary>
            <param name="key">key to search for</param>
            <returns>the value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IOrderedMap`2.SetValue(`0,`1)">
            <summary>
            Updates the value associated with a key in the collection
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IOrderedMap`2.ConditionalSetOrAdd(`0,TreeLib.UpdatePredicate{`0,`1})">
            <summary>
            Conditionally update or add an item, based on the return value from the predicate.
            ConditionalSetOrAdd is more efficient when the decision to add or update depends on the value of the item.
            </summary>
            <param name="key">The key of the item to update or add</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the item will be added to the
            collection if it is not already in the collection. Whether true or false, if the item is in the collection, the
            ref value upon return will be used to update the item.</param>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.IOrderedMap`2.ConditionalSetOrRemove(`0,TreeLib.UpdatePredicate{`0,`1})">
            <summary>
            Conditionally update or add an item, based on the return value from the predicate.
            ConditionalSetOrRemove is more efficient when the decision to remove or update depends on the value of the item.
            </summary>
            <param name="key">The key of the item to update or remove</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the item will be removed from the
            collection if it is in the collection. If the item remains in the collection, the ref value upon return will be used
            to update the item.</param>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.IOrderedMap`2.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.IOrderedMap`2.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.IOrderedMap`2.Least(`0@,`1@)">
            <summary>
            Retrieves the lowest key-value pair in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.IOrderedMap`2.Greatest(`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.IOrderedMap`2.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IOrderedMap`2.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.IOrderedMap`2.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IOrderedMap`2.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.IOrderedMap`2.NearestLessOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IOrderedMap`2.NearestLess(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.IOrderedMap`2.NearestGreaterOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IOrderedMap`2.NearestGreater(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="T:TreeLib.IOrderedList`1">
            <summary>
            Represents an ordered key collection.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
        </member>
        <member name="P:TreeLib.IOrderedList`1.Count">
            <summary>
            Returns the number of keys in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue keys.</exception>
        </member>
        <member name="P:TreeLib.IOrderedList`1.LongCount">
            <summary>
            Returns the number of keys in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IOrderedList`1.Clear">
            <summary>
            Removes all keys from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IOrderedList`1.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.IOrderedList`1.TryAdd(`0)">
            <summary>
            Attempts to add a key to the collection. If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <returns>true if the key was added; false if the key was already present</returns>
        </member>
        <member name="M:TreeLib.IOrderedList`1.TryRemove(`0)">
            <summary>
            Attempts to remove a key from the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key was found and removed</returns>
        </member>
        <member name="M:TreeLib.IOrderedList`1.TryGetKey(`0,`0@)">
            <summary>
            Attempts to get the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">the actual key contained in the collection</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.IOrderedList`1.TrySetKey(`0)">
            <summary>
            Attempts to update the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.IOrderedList`1.Add(`0)">
            <summary>
            Adds a key to the collection.
            </summary>
            <param name="key">key to insert</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
        </member>
        <member name="M:TreeLib.IOrderedList`1.Remove(`0)">
            <summary>
            Removes a key from the collection.
            </summary>
            <param name="key">key to remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IOrderedList`1.GetKey(`0)">
            <summary>
            Retrieves the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <returns>the value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IOrderedList`1.SetKey(`0)">
            <summary>
            Updates the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.IOrderedList`1.ConditionalSetOrAdd(`0,TreeLib.UpdatePredicate{`0})">
            <summary>
            Conditionally update or add a key, based on the return value from the predicate.
            ConditionalSetOrAdd is more efficient when the decision to add or update depends on the value of the item.
            </summary>
            <param name="key">The key to update or add</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the key will be added to the
            collection if it is not already in the collection. Whether true or false, if the key is in the collection, the
            ref key upon return will be used to update the key data.</param>
            <exception cref="T:System.ArgumentException">The sort order of the key was changed by the predicate</exception>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.IOrderedList`1.ConditionalSetOrRemove(`0,TreeLib.UpdatePredicate{`0})">
            <summary>
            Conditionally update or add a key, based on the return value from the predicate.
            ConditionalSetOrRemove is more efficient when the decision to remove or update depends on the value of the item.
            </summary>
            <param name="key">The key to update or remove</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the key will be removed from the
            collection if it is in the collection. If the key remains in the collection, the ref key upon return will be used
            to update the key data.</param>
            <exception cref="T:System.ArgumentException">The sort order of the key was changed by the predicate</exception>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.IOrderedList`1.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key)</returns>
        </member>
        <member name="M:TreeLib.IOrderedList`1.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key)</returns>
        </member>
        <member name="M:TreeLib.IOrderedList`1.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IOrderedList`1.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.IOrderedList`1.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IOrderedList`1.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="T:TreeLib.IRankMap`2">
            <summary>
            Represents an ordered key-value mapping, augmented with rank information. The rank of a key-value pair is the index it would
            be located in if all the key-value pairs in the tree were placed into a sorted array.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
            <typeparam name="ValueType">Type of value associated with each entry.</typeparam>
        </member>
        <member name="P:TreeLib.IRankMap`2.Count">
            <summary>
            Returns the number of key-value pairs in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue key-value pairs.</exception>
        </member>
        <member name="P:TreeLib.IRankMap`2.LongCount">
            <summary>
            Returns the number of key-value pairs in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IRankMap`2.Clear">
            <summary>
            Removes all key-value pairs from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IRankMap`2.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.IRankMap`2.TryAdd(`0,`1)">
            <summary>
            Attempts to add a key-value pair to the collection. If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="value">value to associate with the key</param>
            <returns>true if the key-value pair was added; false if the key was already present</returns>
        </member>
        <member name="M:TreeLib.IRankMap`2.TryRemove(`0)">
            <summary>
            Attempts to remove a key-value pair from the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key-value pair was found and removed</returns>
        </member>
        <member name="M:TreeLib.IRankMap`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to get the value associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.IRankMap`2.TrySetValue(`0,`1)">
            <summary>
            Attempts to set the value associated with a key in the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <returns>true if the key-value pair was found and the value was updated</returns>
        </member>
        <member name="M:TreeLib.IRankMap`2.TryGet(`0,`1@,System.Int32@)">
            <summary>
            Attempts to get the value and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.IRankMap`2.TryGetKeyByRank(System.Int32,`0@)">
            <summary>
            Attempts to return the key of a key-value pair at the specified rank index.
            If all key-value pairs in the collection were converted to a sorted array, this would be the equivalent of array[rank].Key.
            </summary>
            <param name="rank">the rank index to query</param>
            <param name="key">the key located at that index</param>
            <returns>true if there is an element at the the specified index</returns>
        </member>
        <member name="M:TreeLib.IRankMap`2.Add(`0,`1)">
            <summary>
            Adds a key-value pair to the collection.
            </summary>
            <param name="key">key to insert</param>
            <param name="value">value to associate with the key</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
        </member>
        <member name="M:TreeLib.IRankMap`2.Remove(`0)">
            <summary>
            Removes a key-value pair from the collection.
            </summary>
            <param name="key">key of the key-value pair to remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IRankMap`2.GetValue(`0)">
            <summary>
            Retrieves the value associated with a key in the collection
            </summary>
            <param name="key">key to search for</param>
            <returns>the value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IRankMap`2.SetValue(`0,`1)">
            <summary>
            Updates the value associated with a key in the collection
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IRankMap`2.Get(`0,`1@,System.Int32@)">
            <summary>
            Retrieves the value and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IRankMap`2.GetKeyByRank(System.Int32)">
            <summary>
            Retrieves the key of a key-value pair at the specified rank index.
            If all key-value pairs in the collection were converted to a sorted array, this would be the equivalent of array[rank].Key.
            </summary>
            <param name="rank">the rank index to query</param>
            <returns>the key located at that index</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IRankMap`2.ConditionalSetOrAdd(`0,TreeLib.UpdatePredicate{`0,`1})">
            <summary>
            Conditionally update or add an item, based on the return value from the predicate.
            ConditionalSetOrAdd is more efficient when the decision to add or update depends on the value of the item.
            </summary>
            <param name="key">The key of the item to update or add</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the item will be added to the
            collection if it is not already in the collection. Whether true or false, if the item is in the collection, the
            ref value upon return will be used to update the item.</param>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.IRankMap`2.ConditionalSetOrRemove(`0,TreeLib.UpdatePredicate{`0,`1})">
            <summary>
            Conditionally update or add an item, based on the return value from the predicate.
            ConditionalSetOrRemove is more efficient when the decision to remove or update depends on the value of the item.
            </summary>
            <param name="key">The key of the item to update or remove</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the item will be removed from the
            collection if it is in the collection. If the item remains in the collection, the ref value upon return will be used
            to update the item.</param>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.IRankMap`2.AdjustCount(`0,System.Int32)">
            <summary>
            Adjusts the rank count associated with the key-value pair. The countAdjust added to the existing count.
            For a RankMap, the only valid values are 0 (which does nothing) and -1 (which removes the key-value pair).
            </summary>
            <param name="key">key identifying the key-value pair to update</param>
            <param name="countAdjust">adjustment that is added to the count</param>
            <returns>The adjusted count</returns>
            <exception cref="T:System.ArgumentException">if the count is an invalid value or the key does not exist in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRankMap`2.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.IRankMap`2.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.IRankMap`2.Least(`0@,`1@)">
            <summary>
            Retrieves the lowest in the collection (in sort order) and the value associated with it.
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.IRankMap`2.Greatest(`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection (in sort order) and the value associated with it.
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.IRankMap`2.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankMap`2.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankMap`2.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankMap`2.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankMap`2.NearestLessOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankMap`2.NearestLess(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankMap`2.NearestGreaterOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankMap`2.NearestGreater(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankMap`2.NearestLessOrEqual(`0,`0@,`1@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key and
            the value and rank associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankMap`2.NearestLess(`0,`0@,`1@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key and
            the value and rank  associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankMap`2.NearestGreaterOrEqual(`0,`0@,`1@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key and
            the value and rank  associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankMap`2.NearestGreater(`0,`0@,`1@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key and
            the value and rank  associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="T:TreeLib.IRankList`1">
            <summary>
            Represents an ordered key collection, augmented with rank information. The rank of a key is the index it would
            be located in if all the keys in the tree were placed into a sorted array.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
        </member>
        <member name="P:TreeLib.IRankList`1.Count">
            <summary>
            Returns the number of keys in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue keys.</exception>
        </member>
        <member name="P:TreeLib.IRankList`1.LongCount">
            <summary>
            Returns the number of keys in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IRankList`1.Clear">
            <summary>
            Removes all keys from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IRankList`1.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.IRankList`1.TryAdd(`0)">
            <summary>
            Attempts to add a key to the collection. If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <returns>true if the key was added; false if the key was already present</returns>
        </member>
        <member name="M:TreeLib.IRankList`1.TryRemove(`0)">
            <summary>
            Attempts to remove a key from the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key was found and removed</returns>
        </member>
        <member name="M:TreeLib.IRankList`1.TryGetKey(`0,`0@)">
            <summary>
            Attempts to get the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">the actual key contained in the collection</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.IRankList`1.TrySetKey(`0)">
            <summary>
            Attempts to update the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.IRankList`1.TryGet(`0,`0@,System.Int32@)">
            <summary>
            Attempts to get the actual key data and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">the actual key contained in the collection</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.IRankList`1.TryGetKeyByRank(System.Int32,`0@)">
            <summary>
            Retrieves the key at the specified rank index.
            If all keys in the collection were converted to a sorted array, this would be the equivalent of array[rank].
            </summary>
            <param name="rank">the rank index to query</param>
            <param name="key">an out paramter receiving the key at the specified rank index</param>
            <returns>the key located at that index</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IRankList`1.Add(`0)">
            <summary>
            Adds a key to the collection.
            </summary>
            <param name="key">key to insert</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
        </member>
        <member name="M:TreeLib.IRankList`1.Remove(`0)">
            <summary>
            Removes a key from the collection.
            </summary>
            <param name="key">key to remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IRankList`1.GetKey(`0)">
            <summary>
            Retrieves the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <returns>the value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IRankList`1.SetKey(`0)">
            <summary>
            Updates the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.IRankList`1.Get(`0,`0@,System.Int32@)">
            <summary>
            Retrieves the actual key data and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">the actual key contained in the collection</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.IRankList`1.GetKeyByRank(System.Int32)">
            <summary>
            Retrieves the key at the specified rank index.
            If all keys in the collection were converted to a sorted array, this would be the equivalent of array[rank].
            </summary>
            <param name="rank">the rank index to query</param>
            <returns>the key located at that index</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IRankList`1.ConditionalSetOrAdd(`0,TreeLib.UpdatePredicate{`0})">
            <summary>
            Conditionally update or add a key, based on the return value from the predicate.
            ConditionalSetOrAdd is more efficient when the decision to add or update depends on the value of the item.
            </summary>
            <param name="key">The key to update or add</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the key will be added to the
            collection if it is not already in the collection. Whether true or false, if the key is in the collection, the
            ref key upon return will be used to update the key data.</param>
            <exception cref="T:System.ArgumentException">The sort order of the key was changed by the predicate</exception>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.IRankList`1.ConditionalSetOrRemove(`0,TreeLib.UpdatePredicate{`0})">
            <summary>
            Conditionally update or add a key, based on the return value from the predicate.
            ConditionalSetOrRemove is more efficient when the decision to remove or update depends on the value of the item.
            </summary>
            <param name="key">The key to update or remove</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the key will be removed from the
            collection if it is in the collection. If the key remains in the collection, the ref key upon return will be used
            to update the key data.</param>
            <exception cref="T:System.ArgumentException">The sort order of the key was changed by the predicate</exception>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.IRankList`1.AdjustCount(`0,System.Int32)">
            <summary>
            Adjusts the rank count associated with the key-value pair. The countAdjust added to the existing count.
            For a RankMap, the only valid values are 0 (which does nothing) and -1 (which removes the key-value pair).
            </summary>
            <param name="key">key identifying the key-value pair to update</param>
            <param name="countAdjust">adjustment that is added to the count</param>
            <returns>The adjusted count</returns>
            <exception cref="T:System.ArgumentException">if the count is an invalid value or the key does not exist in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRankList`1.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key)</returns>
        </member>
        <member name="M:TreeLib.IRankList`1.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key)</returns>
        </member>
        <member name="M:TreeLib.IRankList`1.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankList`1.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankList`1.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankList`1.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankList`1.NearestLessOrEqual(`0,`0@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankList`1.NearestLess(`0,`0@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankList`1.NearestGreaterOrEqual(`0,`0@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankList`1.NearestGreater(`0,`0@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="T:TreeLib.IRankMapLong`2">
            <summary>
            Represents an ordered key-value mapping, augmented with rank information. The rank of a key-value pair is the index it would
            be located in if all the key-value pairs in the tree were placed into a sorted array.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
            <typeparam name="ValueType">Type of value associated with each entry.</typeparam>
        </member>
        <member name="P:TreeLib.IRankMapLong`2.Count">
            <summary>
            Returns the number of key-value pairs in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue key-value pairs.</exception>
        </member>
        <member name="P:TreeLib.IRankMapLong`2.LongCount">
            <summary>
            Returns the number of key-value pairs in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.Clear">
            <summary>
            Removes all key-value pairs from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.TryAdd(`0,`1)">
            <summary>
            Attempts to add a key-value pair to the collection. If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="value">value to associate with the key</param>
            <returns>true if the key-value pair was added; false if the key was already present</returns>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.TryRemove(`0)">
            <summary>
            Attempts to remove a key-value pair from the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key-value pair was found and removed</returns>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to get the value associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.TrySetValue(`0,`1)">
            <summary>
            Attempts to set the value associated with a key in the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <returns>true if the key-value pair was found and the value was updated</returns>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.TryGet(`0,`1@,System.Int64@)">
            <summary>
            Attempts to get the value and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.TryGetKeyByRank(System.Int64,`0@)">
            <summary>
            Attempts to return the key of a key-value pair at the specified rank index.
            If all key-value pairs in the collection were converted to a sorted array, this would be the equivalent of array[rank].Key.
            </summary>
            <param name="rank">the rank index to query</param>
            <param name="key">the key located at that index</param>
            <returns>true if there is an element at the the specified index</returns>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.Add(`0,`1)">
            <summary>
            Adds a key-value pair to the collection.
            </summary>
            <param name="key">key to insert</param>
            <param name="value">value to associate with the key</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.Remove(`0)">
            <summary>
            Removes a key-value pair from the collection.
            </summary>
            <param name="key">key of the key-value pair to remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.GetValue(`0)">
            <summary>
            Retrieves the value associated with a key in the collection
            </summary>
            <param name="key">key to search for</param>
            <returns>the value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.SetValue(`0,`1)">
            <summary>
            Updates the value associated with a key in the collection
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.Get(`0,`1@,System.Int64@)">
            <summary>
            Retrieves the value and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.GetKeyByRank(System.Int64)">
            <summary>
            Retrieves the key of a key-value pair at the specified rank index.
            If all key-value pairs in the collection were converted to a sorted array, this would be the equivalent of array[rank].Key.
            </summary>
            <param name="rank">the rank index to query</param>
            <returns>the key located at that index</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.ConditionalSetOrAdd(`0,TreeLib.UpdatePredicate{`0,`1})">
            <summary>
            Conditionally update or add an item, based on the return value from the predicate.
            ConditionalSetOrAdd is more efficient when the decision to add or update depends on the value of the item.
            </summary>
            <param name="key">The key of the item to update or add</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the item will be added to the
            collection if it is not already in the collection. Whether true or false, if the item is in the collection, the
            ref value upon return will be used to update the item.</param>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.ConditionalSetOrRemove(`0,TreeLib.UpdatePredicate{`0,`1})">
            <summary>
            Conditionally update or add an item, based on the return value from the predicate.
            ConditionalSetOrRemove is more efficient when the decision to remove or update depends on the value of the item.
            </summary>
            <param name="key">The key of the item to update or remove</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the item will be removed from the
            collection if it is in the collection. If the item remains in the collection, the ref value upon return will be used
            to update the item.</param>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.AdjustCount(`0,System.Int64)">
            <summary>
            Adjusts the rank count associated with the key-value pair. The countAdjust added to the existing count.
            For a RankMap, the only valid values are 0 (which does nothing) and -1 (which removes the key-value pair).
            </summary>
            <param name="key">key identifying the key-value pair to update</param>
            <param name="countAdjust">adjustment that is added to the count</param>
            <returns>The adjusted count</returns>
            <exception cref="T:System.ArgumentException">if the count is an invalid value or the key does not exist in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.Least(`0@,`1@)">
            <summary>
            Retrieves the lowest in the collection (in sort order) and the value associated with it.
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.Greatest(`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection (in sort order) and the value associated with it.
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.NearestLessOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.NearestLess(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.NearestGreaterOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.NearestGreater(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.NearestLessOrEqual(`0,`0@,`1@,System.Int64@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key and
            the value and rank associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.NearestLess(`0,`0@,`1@,System.Int64@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key and
            the value and rank  associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.NearestGreaterOrEqual(`0,`0@,`1@,System.Int64@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key and
            the value and rank  associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankMapLong`2.NearestGreater(`0,`0@,`1@,System.Int64@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key and
            the value and rank  associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="T:TreeLib.IRankListLong`1">
            <summary>
            Represents an ordered key collection, augmented with rank information. The rank of a key is the index it would
            be located in if all the keys in the tree were placed into a sorted array.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
        </member>
        <member name="P:TreeLib.IRankListLong`1.Count">
            <summary>
            Returns the number of keys in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue keys.</exception>
        </member>
        <member name="P:TreeLib.IRankListLong`1.LongCount">
            <summary>
            Returns the number of keys in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IRankListLong`1.Clear">
            <summary>
            Removes all keys from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IRankListLong`1.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.IRankListLong`1.TryAdd(`0)">
            <summary>
            Attempts to add a key to the collection. If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <returns>true if the key was added; false if the key was already present</returns>
        </member>
        <member name="M:TreeLib.IRankListLong`1.TryRemove(`0)">
            <summary>
            Attempts to remove a key from the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key was found and removed</returns>
        </member>
        <member name="M:TreeLib.IRankListLong`1.TryGetKey(`0,`0@)">
            <summary>
            Attempts to get the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">the actual key contained in the collection</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.IRankListLong`1.TrySetKey(`0)">
            <summary>
            Attempts to update the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.IRankListLong`1.TryGet(`0,`0@,System.Int64@)">
            <summary>
            Attempts to get the actual key data and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">the actual key contained in the collection</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.IRankListLong`1.TryGetKeyByRank(System.Int64,`0@)">
            <summary>
            Retrieves the key at the specified rank index.
            If all keys in the collection were converted to a sorted array, this would be the equivalent of array[rank].
            </summary>
            <param name="rank">the rank index to query</param>
            <param name="key">the key located at the specified rank index</param>
            <returns>the key located at that index</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IRankListLong`1.Add(`0)">
            <summary>
            Adds a key to the collection.
            </summary>
            <param name="key">key to insert</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
        </member>
        <member name="M:TreeLib.IRankListLong`1.Remove(`0)">
            <summary>
            Removes a key from the collection.
            </summary>
            <param name="key">key to remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IRankListLong`1.GetKey(`0)">
            <summary>
            Retrieves the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <returns>the value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IRankListLong`1.SetKey(`0)">
            <summary>
            Updates the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.IRankListLong`1.Get(`0,`0@,System.Int64@)">
            <summary>
            Retrieves the actual key data and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">the actual key contained in the collection</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.IRankListLong`1.GetKeyByRank(System.Int64)">
            <summary>
            Retrieves the key at the specified rank index.
            If all keys in the collection were converted to a sorted array, this would be the equivalent of array[rank].
            </summary>
            <param name="rank">the rank index to query</param>
            <returns>the key located at that index</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IRankListLong`1.ConditionalSetOrAdd(`0,TreeLib.UpdatePredicate{`0})">
            <summary>
            Conditionally update or add a key, based on the return value from the predicate.
            ConditionalSetOrAdd is more efficient when the decision to add or update depends on the value of the item.
            </summary>
            <param name="key">The key to update or add</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the key will be added to the
            collection if it is not already in the collection. Whether true or false, if the key is in the collection, the
            ref key upon return will be used to update the key data.</param>
            <exception cref="T:System.ArgumentException">The sort order of the key was changed by the predicate</exception>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.IRankListLong`1.ConditionalSetOrRemove(`0,TreeLib.UpdatePredicate{`0})">
            <summary>
            Conditionally update or add a key, based on the return value from the predicate.
            ConditionalSetOrRemove is more efficient when the decision to remove or update depends on the value of the item.
            </summary>
            <param name="key">The key to update or remove</param>
            <param name="predicate">The predicate to invoke. If the predicate returns true, the key will be removed from the
            collection if it is in the collection. If the key remains in the collection, the ref key upon return will be used
            to update the key data.</param>
            <exception cref="T:System.ArgumentException">The sort order of the key was changed by the predicate</exception>
            <exception cref="T:System.InvalidOperationException">The tree was modified while the predicate was invoked. If this happens,
            the tree may be left in an unstable state.</exception>
        </member>
        <member name="M:TreeLib.IRankListLong`1.AdjustCount(`0,System.Int64)">
            <summary>
            Adjusts the rank count associated with the key-value pair. The countAdjust added to the existing count.
            For a RankMap, the only valid values are 0 (which does nothing) and -1 (which removes the key-value pair).
            </summary>
            <param name="key">key identifying the key-value pair to update</param>
            <param name="countAdjust">adjustment that is added to the count</param>
            <returns>The adjusted count</returns>
            <exception cref="T:System.ArgumentException">if the count is an invalid value or the key does not exist in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRankListLong`1.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key)</returns>
        </member>
        <member name="M:TreeLib.IRankListLong`1.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key)</returns>
        </member>
        <member name="M:TreeLib.IRankListLong`1.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankListLong`1.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankListLong`1.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankListLong`1.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankListLong`1.NearestLessOrEqual(`0,`0@,System.Int64@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankListLong`1.NearestLess(`0,`0@,System.Int64@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankListLong`1.NearestGreaterOrEqual(`0,`0@,System.Int64@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IRankListLong`1.NearestGreater(`0,`0@,System.Int64@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="rank">the rank of the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="T:TreeLib.IMultiRankMap`2">
            <summary>
            Represents an ordered key-value mapping, augmented with multi-rank information. The rank of a key-value pair is the index it would
            be located in if all the key-value pairs in the tree were placed into a sorted array. Each key-value pair also has a count
            associated with it, which models sorted arrays containing multiple instances of a key. It is equivalent to the number of times
            the key-value pair appears in the array. Rank index values account for such multiple occurrences. In this case, the rank
            index is the index at which the first instance of a particular key would occur in a sorted array containing all keys.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
            <typeparam name="ValueType">Type of value associated with each entry.</typeparam>
        </member>
        <member name="P:TreeLib.IMultiRankMap`2.Count">
            <summary>
            Returns the number of key-value pairs in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue key-value pairs.</exception>
        </member>
        <member name="P:TreeLib.IMultiRankMap`2.LongCount">
            <summary>
            Returns the number of key-value pairs in the collection.
            </summary>
        </member>
        <member name="P:TreeLib.IMultiRankMap`2.RankCount">
            <summary>
            Returns the total size of an array containing all key-value pairs, where each key occurs one or more times, determined by
            the 'count' associated with each key-value pair.
            </summary>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.Clear">
            <summary>
            Removes all key-value pairs from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.TryAdd(`0,`1,System.Int32)">
            <summary>
            Attempts to add a key to the collection with an associated value and count.
            If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="value">value to associate with the key</param>
            <param name="count">number of instances to repeat this key-value pair if the collection were converted to a sorted array</param>
            <returns>true if key was not present and key-value pair was added; false if key-value pair was already present and value was updated</returns>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.TryRemove(`0)">
            <summary>
            Attempts to remove a key-value pair from the collection. If the key is not present, no change is made to the collection.
            The entire key-value pair is removed, regardless of the rank count for it.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key-value pair was found and removed</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to get the value associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.TrySetValue(`0,`1)">
            <summary>
            Attempts to set the value associated with a key in the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <returns>true if the key-value pair was found and the value was updated</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.TryGet(`0,`1@,System.Int32@,System.Int32@)">
            <summary>
            Attempts to get the value, rank index, and count associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <param name="count">out parameter that returns the count, where count is the number of instances to repeat
            this key-value pair if the collection were converted to a sorted array</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.TrySet(`0,`1,System.Int32)">
            <summary>
            Attempts to update the value and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">the new value to set</param>
            <param name="rank">the new rank count</param>
            <returns>true if they key was found and the rank was a valid value or false if the rank count was not at least 1
            or the sum of counts would have exceeded Int32.MaxValue</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.TryGetKeyByRank(System.Int32,`0@)">
            <summary>
            Attempts to return the key of a key-value pair at the specified rank index. If all key-value pairs in the collection were
            converted to a sorted array of key-value pairs, this would be the equivalent of array[rank].Key, subject to the
            constraint that only the first occurrence of each key can be indexed.
            </summary>
            <param name="rank">the rank index to query; the rank must be of the first occurrence of the key in a virtual
            sorted array where each key occurs 'count' times.</param>
            <param name="key">the key located at that index</param>
            <returns>true if there is an element at the the specified index and it corresponds to the first in the virtual
            ordered sequence of multiple instances in an equivalent sorted array</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.Add(`0,`1,System.Int32)">
            <summary>
            Adds a key to the collection with an associated value and count.
            If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="value">value to associate with the key</param>
            <param name="count">number of instances to repeat this key-value pair if the collection were converted to a sorted array</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.Remove(`0)">
            <summary>
            Removes a key-value pair from the collection. If the key is not present, no change is made to the collection.
            The entire key-value pair is removed, regardless of the rank count for it.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.GetValue(`0)">
            <summary>
            Retrieves the value associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <returns>value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.SetValue(`0,`1)">
            <summary>
            Updates the value associated with a key in the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.Get(`0,`1@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the value, rank index, and count associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <param name="count">out parameter that returns the count, where count is the number of instances to repeat
            this key-value pair if the collection were converted to a sorted array</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.Set(`0,`1,System.Int32)">
            <summary>
            Updates the value and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">the new value to set</param>
            <param name="rank">the new rank count</param>
            <exception cref="T:System.ArgumentException">the rank count was not at least 1</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.GetKeyByRank(System.Int32)">
            <summary>
            Retrieves the key of a key-value pair at the specified rank index. If all key-value pairs in the collection were
            converted to a sorted array of key-value pairs, this would be the equivalent of array[rank].Key, subject to the
            constraint that only the first occurrence of each key can be indexed.
            </summary>
            <param name="rank">the rank index to query; the rank must be of the first occurrence of the key in a virtual
            sorted array where each key occurs 'count' times.</param>
            <returns>the key located at that index</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.AdjustCount(`0,System.Int32)">
            <summary>
            Adjusts the rank count associated with the key-value pair. The countAdjust added to the existing count.
            If the countAdjust is equal to the negative value of the current count, the key-value pair will be removed.
            </summary>
            <param name="key">key identifying the key-value pair to update</param>
            <param name="countAdjust">adjustment that is added to the count</param>
            <returns>The adjusted count</returns>
            <exception cref="T:System.ArgumentException">if the count is an invalid value or the key does not exist in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.Least(`0@,`1@)">
            <summary>
            Retrieves the lowest key-value pair in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.Greatest(`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.NearestLess(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.NearestLessOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.NearestGreaterOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.NearestGreater(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.NearestLessOrEqual(`0,`0@,`1@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key and
            the value, rank and count associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.NearestLess(`0,`0@,`1@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key and
            the value, rank and count  associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.NearestGreaterOrEqual(`0,`0@,`1@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key and
            the value, rank and count  associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.NearestGreater(`0,`0@,`1@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key and
            the value, rank and count  associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.NearestLessOrEqualByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a key's range into the start index of a key's range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the specified index is greater than or equal to the extent it will return the last key's start index.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <returns>true if a key was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.NearestLessByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a key's range, the start of the previous key's range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.NearestGreaterOrEqualByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range, that index will be returned.
            If the index refers to the interior index for a key's range, the start of the next key's range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than the start of the last key's range, no index will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.NearestGreaterByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range or is an interior index for a range, the next key's range will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than or equal to the start of the last key's range, no index will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.NearestLessOrEqualByRank(System.Int32,`0@,System.Int32@,System.Int32@,`1@)">
            <summary>
            Search for the nearest key's index that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a key's range into the start index of a key's range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the specified index is greater than or equal to the extent it will return the last key's start index.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <param name="value">the value associated with the key</param>
            <returns>true if a key was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.NearestLessByRank(System.Int32,`0@,System.Int32@,System.Int32@,`1@)">
            <summary>
            Search for the nearest key's index that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a key's range, the start of the previous key's range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <param name="value">the value associated with the key</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.NearestGreaterOrEqualByRank(System.Int32,`0@,System.Int32@,System.Int32@,`1@)">
            <summary>
            Search for the nearest key's index that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range, that index will be returned.
            If the index refers to the interior index for a key's range, the start of the next key's range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than the start of the last key's range, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <param name="value">the value associated with the key</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMap`2.NearestGreaterByRank(System.Int32,`0@,System.Int32@,System.Int32@,`1@)">
            <summary>
            Search for the nearest key's range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range or is an interior index for a range, the next key's range will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than or equal to the start of the last key's range, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <param name="value">the value associated with the key</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="T:TreeLib.IMultiRankList`1">
            <summary>
            Represents an ordered key collection, augmented with multi-rank information. The rank of a key is the index it would
            be located in if all the keys in the tree were placed into a sorted array. Each key also has a count
            associated with it, which models sorted arrays containing multiple instances of a key. It is equivalent to the number of times
            the key appears in the array. Rank index values account for such multiple occurrences. In this case, the rank
            index is the index at which the first instance of a particular key would occur in a sorted array containing all keys.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
        </member>
        <member name="P:TreeLib.IMultiRankList`1.Count">
            <summary>
            Returns the number of keys in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue keys.</exception>
        </member>
        <member name="P:TreeLib.IMultiRankList`1.LongCount">
            <summary>
            Returns the number of keys in the collection.
            </summary>
        </member>
        <member name="P:TreeLib.IMultiRankList`1.RankCount">
            <summary>
            Returns the total size of an array containing all keys, where each key occurs one or more times, determined by
            the 'count' associated with each key.
            </summary>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.Clear">
            <summary>
            Removes all keys from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.TryAdd(`0,System.Int32)">
            <summary>
            Attempts to add a key to the collection.
            If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="count">number of instances to repeat this key if the collection were converted to a sorted array</param>
            <returns>true if key was not present and key was added; false if key was already present</returns>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.TryRemove(`0)">
            <summary>
            Attempts to remove a key from the collection. If the key is not present, no change is made to the collection.
            The entire key is removed, regardless of the rank count for it.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key was found and removed</returns>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.TryGetKey(`0,`0@)">
            <summary>
            Attempts to get the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">the actual key contained in the collection</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.TrySetKey(`0)">
            <summary>
            Attempts to update the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.TryGet(`0,`0@,System.Int32@,System.Int32@)">
            <summary>
            Attempts to get the actual key, rank index, and count associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">out parameter that returns the actual key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key</param>
            <param name="count">out parameter that returns the count, where count is the number of instances to repeat
            this key if the collection were converted to a sorted array</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.TrySet(`0,System.Int32)">
            <summary>
            Attempts to update the key data and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for and also update</param>
            <param name="rank">the new rank count</param>
            <returns>true if they key was found and the rank was a valid value or false if the rank count was not at least 1
            or the sum of counts would have exceeded Int32.MaxValue</returns>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.TryGetKeyByRank(System.Int32,`0@)">
            <summary>
            Attempts to return the key at the specified rank index. If all keys in the collection were
            converted to a sorted array of keys, this would be the equivalent of array[rank]s, subject to the
            constraint that only the first occurrence of each key can be indexed.
            </summary>
            <param name="rank">the rank index to query; the rank must be of the first occurrence of the key in a virtual
            sorted array where each key occurs 'count' times.</param>
            <param name="key">the key located at that index</param>
            <returns>true if there is an element at the the specified index and it corresponds to the first in the virtual
            ordered sequence of multiple instances in an equivalent sorted array</returns>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.Add(`0,System.Int32)">
            <summary>
            Adds a key to the collection with an associated count.
            If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="count">number of instances to repeat this key if the collection were converted to a sorted array</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.Remove(`0)">
            <summary>
            Removes a key from the collection. If the key is not present, no change is made to the collection.
            The entire key is removed, regardless of the rank count for it.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.GetKey(`0)">
            <summary>
            Retrieves the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <returns>the value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.SetKey(`0)">
            <summary>
            Updates the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.Get(`0,`0@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the actual key, rank index, and count associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">out parameter that returns the actual key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key</param>
            <param name="count">out parameter that returns the count, where count is the number of instances to repeat
            this key if the collection were converted to a sorted array</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.Set(`0,System.Int32)">
            <summary>
            Updates the key and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for and also update</param>
            <param name="rank">the new rank count</param>
            <exception cref="T:System.ArgumentException">the rank count was not at least 1</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.GetKeyByRank(System.Int32)">
            <summary>
            Retrieves the key at the specified rank index. If all keys in the collection were
            converted to a sorted array of keys, this would be the equivalent of array[rank], subject to the
            constraint that only the first occurrence of each key can be indexed.
            </summary>
            <param name="rank">the rank index to query; the rank must be of the first occurrence of the key in a virtual
            sorted array where each key occurs 'count' times.</param>
            <returns>the key located at that index</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.AdjustCount(`0,System.Int32)">
            <summary>
            Adjusts the rank count associated with the key. The countAdjust added to the existing count.
            If the countAdjust is equal to the negative value of the current count, the key will be removed.
            </summary>
            <param name="key">key identifying the key to update</param>
            <param name="countAdjust">adjustment that is added to the count</param>
            <returns>The adjusted count</returns>
            <exception cref="T:System.ArgumentException">if the count is an invalid value or the key does not exist in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.NearestLessOrEqual(`0,`0@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.NearestLess(`0,`0@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.NearestGreaterOrEqual(`0,`0@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.NearestGreater(`0,`0@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.NearestLessOrEqualByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a key's range into the start index of a key's range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the specified index is greater than or equal to the extent it will return the last key's start index.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <returns>true if a key was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.NearestLessByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a key's range, the start of the previous key's range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.NearestGreaterOrEqualByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range, that index will be returned.
            If the index refers to the interior index for a key's range, the start of the next key's range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than the start of the last key's range, no index will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.NearestGreaterByRank(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest key's range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range or is an interior index for a range, the next key's range will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than or equal to the start of the last key's range, no index will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.NearestLessOrEqualByRank(System.Int32,`0@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a key's range into the start index of a key's range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the specified index is greater than or equal to the extent it will return the last key's start index.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <returns>true if a key was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.NearestLessByRank(System.Int32,`0@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a key's range, the start of the previous key's range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.NearestGreaterOrEqualByRank(System.Int32,`0@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest key's index that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range, that index will be returned.
            If the index refers to the interior index for a key's range, the start of the next key's range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than the start of the last key's range, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankList`1.NearestGreaterByRank(System.Int32,`0@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest key's range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range or is an interior index for a range, the next key's range will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than or equal to the start of the last key's range, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="T:TreeLib.IMultiRankMapLong`2">
            <summary>
            Represents an ordered key-value mapping, augmented with multi-rank information. The rank of a key-value pair is the index it would
            be located in if all the key-value pairs in the tree were placed into a sorted array. Each key-value pair also has a count
            associated with it, which models sorted arrays containing multiple instances of a key. It is equivalent to the number of times
            the key-value pair appears in the array. Rank index values account for such multiple occurrences. In this case, the rank
            index is the index at which the first instance of a particular key would occur in a sorted array containing all keys.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
            <typeparam name="ValueType">Type of value associated with each entry.</typeparam>
        </member>
        <member name="P:TreeLib.IMultiRankMapLong`2.Count">
            <summary>
            Returns the number of key-value pairs in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue key-value pairs.</exception>
        </member>
        <member name="P:TreeLib.IMultiRankMapLong`2.LongCount">
            <summary>
            Returns the number of key-value pairs in the collection.
            </summary>
        </member>
        <member name="P:TreeLib.IMultiRankMapLong`2.RankCount">
            <summary>
            Returns the total size of an array containing all key-value pairs, where each key occurs one or more times, determined by
            the 'count' associated with each key-value pair.
            </summary>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.Clear">
            <summary>
            Removes all key-value pairs from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.TryAdd(`0,`1,System.Int64)">
            <summary>
            Attempts to add a key to the collection with an associated value and count.
            If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="value">value to associate with the key</param>
            <param name="count">number of instances to repeat this key-value pair if the collection were converted to a sorted array</param>
            <returns>true if key was not present and key-value pair was added; false if key-value pair was already present and value was updated</returns>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int64.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.TryRemove(`0)">
            <summary>
            Attempts to remove a key-value pair from the collection. If the key is not present, no change is made to the collection.
            The entire key-value pair is removed, regardless of the rank count for it.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key-value pair was found and removed</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to get the value associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.TrySetValue(`0,`1)">
            <summary>
            Attempts to set the value associated with a key in the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <returns>true if the key-value pair was found and the value was updated</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.TryGet(`0,`1@,System.Int64@,System.Int64@)">
            <summary>
            Attempts to get the value, rank index, and count associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <param name="count">out parameter that returns the count, where count is the number of instances to repeat
            this key-value pair if the collection were converted to a sorted array</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.TrySet(`0,`1,System.Int64)">
            <summary>
            Attempts to update the value and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">the new value to set</param>
            <param name="rank">the new rank count</param>
            <returns>true if they key was found and the rank was a valid value or false if the rank count was not at least 1
            or the sum of counts would have exceeded Int64.MaxValue</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.TryGetKeyByRank(System.Int64,`0@)">
            <summary>
            Attempts to return the key of a key-value pair at the specified rank index. If all key-value pairs in the collection were
            converted to a sorted array of key-value pairs, this would be the equivalent of array[rank].Key, subject to the
            constraint that only the first occurrence of each key can be indexed.
            </summary>
            <param name="rank">the rank index to query; the rank must be of the first occurrence of the key in a virtual
            sorted array where each key occurs 'count' times.</param>
            <param name="key">the key located at that index</param>
            <returns>true if there is an element at the the specified index and it corresponds to the first in the virtual
            ordered sequence of multiple instances in an equivalent sorted array</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.Add(`0,`1,System.Int64)">
            <summary>
            Adds a key to the collection with an associated value and count.
            If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="value">value to associate with the key</param>
            <param name="count">number of instances to repeat this key-value pair if the collection were converted to a sorted array</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int64.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.Remove(`0)">
            <summary>
            Removes a key-value pair from the collection. If the key is not present, no change is made to the collection.
            The entire key-value pair is removed, regardless of the rank count for it.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.GetValue(`0)">
            <summary>
            Retrieves the value associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <returns>value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.SetValue(`0,`1)">
            <summary>
            Updates the value associated with a key in the collection. If the key is not present, no change is made to the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">replacement value to associate with the key</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.Get(`0,`1@,System.Int64@,System.Int64@)">
            <summary>
            Retrieves the value, rank index, and count associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">out parameter that returns the value associated with the key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key-value pair</param>
            <param name="count">out parameter that returns the count, where count is the number of instances to repeat
            this key-value pair if the collection were converted to a sorted array</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.Set(`0,`1,System.Int64)">
            <summary>
            Updates the value and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="value">the new value to set</param>
            <param name="rank">the new rank count</param>
            <exception cref="T:System.ArgumentException">the rank count was not at least 1</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int64.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.GetKeyByRank(System.Int64)">
            <summary>
            Retrieves the key of a key-value pair at the specified rank index. If all key-value pairs in the collection were
            converted to a sorted array of key-value pairs, this would be the equivalent of array[rank].Key, subject to the
            constraint that only the first occurrence of each key can be indexed.
            </summary>
            <param name="rank">the rank index to query; the rank must be of the first occurrence of the key in a virtual
            sorted array where each key occurs 'count' times.</param>
            <returns>the key located at that index</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int64.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.AdjustCount(`0,System.Int64)">
            <summary>
            Adjusts the rank count associated with the key-value pair. The countAdjust added to the existing count.
            If the countAdjust is equal to the negative value of the current count, the key-value pair will be removed.
            </summary>
            <param name="key">key identifying the key-value pair to update</param>
            <param name="countAdjust">adjustment that is added to the count</param>
            <returns>The adjusted count</returns>
            <exception cref="T:System.ArgumentException">if the count is an invalid value or the key does not exist in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int64.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.Least(`0@,`1@)">
            <summary>
            Retrieves the lowest key-value pair in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.Greatest(`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <param name="value">out parameter receiving the value associated with the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.NearestLessOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.NearestLess(`0,`0@,`1@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.NearestGreaterOrEqual(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.NearestGreater(`0,`0@,`1@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key and
            the value associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.NearestLessOrEqual(`0,`0@,`1@,System.Int64@,System.Int64@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key and
            the value, rank and count associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.NearestLess(`0,`0@,`1@,System.Int64@,System.Int64@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key and
            the value, rank and count  associated with it.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.NearestGreaterOrEqual(`0,`0@,`1@,System.Int64@,System.Int64@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key and
            the value, rank and count  associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.NearestGreater(`0,`0@,`1@,System.Int64@,System.Int64@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key and
            the value, rank and count  associated with it.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="value">out parameter receiving the value associated with the returned key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.NearestLessOrEqualByRank(System.Int64,System.Int64@)">
            <summary>
            Search for the nearest key's index that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a key's range into the start index of a key's range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the specified index is greater than or equal to the extent it will return the last key's start index.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <returns>true if a key was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.NearestLessByRank(System.Int64,System.Int64@)">
            <summary>
            Search for the nearest key's index that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a key's range, the start of the previous key's range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.NearestGreaterOrEqualByRank(System.Int64,System.Int64@)">
            <summary>
            Search for the nearest key's index that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range, that index will be returned.
            If the index refers to the interior index for a key's range, the start of the next key's range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than the start of the last key's range, no index will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.NearestGreaterByRank(System.Int64,System.Int64@)">
            <summary>
            Search for the nearest key's range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range or is an interior index for a range, the next key's range will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than or equal to the start of the last key's range, no index will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.NearestLessOrEqualByRank(System.Int64,`0@,System.Int64@,System.Int64@,`1@)">
            <summary>
            Search for the nearest key's index that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a key's range into the start index of a key's range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the specified index is greater than or equal to the extent it will return the last key's start index.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <param name="value">the value associated with the key</param>
            <returns>true if a key was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.NearestLessByRank(System.Int64,`0@,System.Int64@,System.Int64@,`1@)">
            <summary>
            Search for the nearest key's index that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a key's range, the start of the previous key's range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <param name="value">the value associated with the key</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.NearestGreaterOrEqualByRank(System.Int64,`0@,System.Int64@,System.Int64@,`1@)">
            <summary>
            Search for the nearest key's index that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range, that index will be returned.
            If the index refers to the interior index for a key's range, the start of the next key's range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than the start of the last key's range, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <param name="value">the value associated with the key</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankMapLong`2.NearestGreaterByRank(System.Int64,`0@,System.Int64@,System.Int64@,`1@)">
            <summary>
            Search for the nearest key's range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range or is an interior index for a range, the next key's range will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than or equal to the start of the last key's range, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <param name="value">the value associated with the key</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="T:TreeLib.IMultiRankListLong`1">
            <summary>
            Represents an ordered key collection, augmented with multi-rank information. The rank of a key is the index it would
            be located in if all the keys in the tree were placed into a sorted array. Each key also has a count
            associated with it, which models sorted arrays containing multiple instances of a key. It is equivalent to the number of times
            the key appears in the array. Rank index values account for such multiple occurrences. In this case, the rank
            index is the index at which the first instance of a particular key would occur in a sorted array containing all keys.
            </summary>
            <typeparam name="KeyType">Type of key used to index collection. Must be comparable.</typeparam>
        </member>
        <member name="P:TreeLib.IMultiRankListLong`1.Count">
            <summary>
            Returns the number of keys in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue keys.</exception>
        </member>
        <member name="P:TreeLib.IMultiRankListLong`1.LongCount">
            <summary>
            Returns the number of keys in the collection.
            </summary>
        </member>
        <member name="P:TreeLib.IMultiRankListLong`1.RankCount">
            <summary>
            Returns the total size of an array containing all keys, where each key occurs one or more times, determined by
            the 'count' associated with each key.
            </summary>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.Clear">
            <summary>
            Removes all keys from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.ContainsKey(`0)">
            <summary>
            Determines whether the key is present in the collection.
            </summary>
            <param name="key">Key to search for</param>
            <returns>true if the key is present in the collection</returns>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.TryAdd(`0,System.Int64)">
            <summary>
            Attempts to add a key to the collection.
            If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="count">number of instances to repeat this key if the collection were converted to a sorted array</param>
            <returns>true if key was not present and key was added; false if key was already present</returns>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int64.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.TryRemove(`0)">
            <summary>
            Attempts to remove a key from the collection. If the key is not present, no change is made to the collection.
            The entire key is removed, regardless of the rank count for it.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <returns>true if the key was found and removed</returns>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.TryGetKey(`0,`0@)">
            <summary>
            Attempts to get the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">the actual key contained in the collection</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.TrySetKey(`0)">
            <summary>
            Attempts to update the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.TryGet(`0,`0@,System.Int64@,System.Int64@)">
            <summary>
            Attempts to get the actual key, rank index, and count associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">out parameter that returns the actual key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key</param>
            <param name="count">out parameter that returns the count, where count is the number of instances to repeat
            this key if the collection were converted to a sorted array</param>
            <returns>true if they key was found</returns>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.TrySet(`0,System.Int64)">
            <summary>
            Attempts to update the key data and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for and also update</param>
            <param name="rank">the new rank count</param>
            <returns>true if they key was found and the rank was a valid value or false if the rank count was not at least 1
            or the sum of counts would have exceeded Int64.MaxValue</returns>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.TryGetKeyByRank(System.Int64,`0@)">
            <summary>
            Attempts to return the key at the specified rank index. If all keys in the collection were
            converted to a sorted array of keys, this would be the equivalent of array[rank]s, subject to the
            constraint that only the first occurrence of each key can be indexed.
            </summary>
            <param name="rank">the rank index to query; the rank must be of the first occurrence of the key in a virtual
            sorted array where each key occurs 'count' times.</param>
            <param name="key">the key located at that index</param>
            <returns>true if there is an element at the the specified index and it corresponds to the first in the virtual
            ordered sequence of multiple instances in an equivalent sorted array</returns>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.Add(`0,System.Int64)">
            <summary>
            Adds a key to the collection with an associated count.
            If the key is already present, no change is made to the collection.
            </summary>
            <param name="key">key to search for and possibly insert</param>
            <param name="count">number of instances to repeat this key if the collection were converted to a sorted array</param>
            <exception cref="T:System.ArgumentException">key is already present in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int64.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.Remove(`0)">
            <summary>
            Removes a key from the collection. If the key is not present, no change is made to the collection.
            The entire key is removed, regardless of the rank count for it.
            </summary>
            <param name="key">the key to search for and possibly remove</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int64.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.GetKey(`0)">
            <summary>
            Retrieves the key stored in the collection that matches the provided key.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for</param>
            <returns>the value associated with the key</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.SetKey(`0)">
            <summary>
            Updates the key data for a key in the collection. If the key is not present, no change is made to the collection.
            (This would be used if the KeyType is a compound type, with one portion being used as the comparable key and the
            remainder being a payload that does not participate in the comparison.)
            </summary>
            <param name="key">key to search for and possibly replace the existing key</param>
            <returns>true if the key was found and updated</returns>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.Get(`0,`0@,System.Int64@,System.Int64@)">
            <summary>
            Retrieves the actual key, rank index, and count associated with a key in the collection.
            </summary>
            <param name="key">key to search for</param>
            <param name="keyOut">out parameter that returns the actual key</param>
            <param name="rank">out pararmeter that returns the rank index associated with the key</param>
            <param name="count">out parameter that returns the count, where count is the number of instances to repeat
            this key if the collection were converted to a sorted array</param>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.Set(`0,System.Int64)">
            <summary>
            Updates the key and rank index associated with a key in the collection.
            </summary>
            <param name="key">key to search for and also update</param>
            <param name="rank">the new rank count</param>
            <exception cref="T:System.ArgumentException">the rank count was not at least 1</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int64.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.GetKeyByRank(System.Int64)">
            <summary>
            Retrieves the key at the specified rank index. If all keys in the collection were
            converted to a sorted array of keys, this would be the equivalent of array[rank], subject to the
            constraint that only the first occurrence of each key can be indexed.
            </summary>
            <param name="rank">the rank index to query; the rank must be of the first occurrence of the key in a virtual
            sorted array where each key occurs 'count' times.</param>
            <returns>the key located at that index</returns>
            <exception cref="T:System.ArgumentException">the key is not present in the collection</exception>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.AdjustCount(`0,System.Int64)">
            <summary>
            Adjusts the rank count associated with the key. The countAdjust added to the existing count.
            If the countAdjust is equal to the negative value of the current count, the key will be removed.
            </summary>
            <param name="key">key identifying the key to update</param>
            <param name="countAdjust">adjustment that is added to the count</param>
            <returns>The adjusted count</returns>
            <exception cref="T:System.ArgumentException">if the count is an invalid value or the key does not exist in the collection</exception>
            <exception cref="T:System.OverflowException">the sum of counts would have exceeded Int64.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.Least(`0@)">
            <summary>
            Retrieves the lowest key in the collection (in sort order)
            </summary>
            <param name="leastOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.Greatest(`0@)">
            <summary>
            Retrieves the highest key in the collection (in sort order)
            </summary>
            <param name="greatestOut">out parameter receiving the key</param>
            <returns>true if a key was found (i.e. collection contains at least 1 key-value pair)</returns>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.NearestLessOrEqual(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.NearestLess(`0,`0@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.NearestGreaterOrEqual(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.NearestGreater(`0,`0@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.NearestLessOrEqual(`0,`0@,System.Int64@,System.Int64@)">
            <summary>
            Retrieves the highest key in the collection that is less than or equal to the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than or equal to provided key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key less than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.NearestLess(`0,`0@,System.Int64@,System.Int64@)">
            <summary>
            Retrieves the highest key in the collection that is less than the provided key.
            </summary>
            <param name="key">key to search below</param>
            <param name="nearestKey">highest key less than the provided key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key less than the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.NearestGreaterOrEqual(`0,`0@,System.Int64@,System.Int64@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than or equal to the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than or equal to provided key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key greater than or equal to the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.NearestGreater(`0,`0@,System.Int64@,System.Int64@)">
            <summary>
            Retrieves the lowest key in the collection that is greater than the provided key.
            </summary>
            <param name="key">key to search above</param>
            <param name="nearestKey">lowest key greater than the provided key</param>
            <param name="rank">the rank of the returned key</param>
            <param name="count">the count of the returned key</param>
            <returns>true if there was a key greater than the provided key</returns>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.NearestLessOrEqualByRank(System.Int64,System.Int64@)">
            <summary>
            Search for the nearest key's index that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a key's range into the start index of a key's range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the specified index is greater than or equal to the extent it will return the last key's start index.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <returns>true if a key was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.NearestLessByRank(System.Int64,System.Int64@)">
            <summary>
            Search for the nearest key's index that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a key's range, the start of the previous key's range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.NearestGreaterOrEqualByRank(System.Int64,System.Int64@)">
            <summary>
            Search for the nearest key's index that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range, that index will be returned.
            If the index refers to the interior index for a key's range, the start of the next key's range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than the start of the last key's range, no index will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.NearestGreaterByRank(System.Int64,System.Int64@)">
            <summary>
            Search for the nearest key's range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range or is an interior index for a range, the next key's range will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than or equal to the start of the last key's range, no index will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.NearestLessOrEqualByRank(System.Int64,`0@,System.Int64@,System.Int64@)">
            <summary>
            Search for the nearest key's index that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a key's range into the start index of a key's range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the specified index is greater than or equal to the extent it will return the last key's start index.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <returns>true if a key was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.NearestLessByRank(System.Int64,`0@,System.Int64@,System.Int64@)">
            <summary>
            Search for the nearest key's index that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a key's range, the start of the previous key's range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no keys in the collection or position is less than or equal to 0, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.NearestGreaterOrEqualByRank(System.Int64,`0@,System.Int64@,System.Int64@)">
            <summary>
            Search for the nearest key's index that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range, that index will be returned.
            If the index refers to the interior index for a key's range, the start of the next key's range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than the start of the last key's range, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IMultiRankListLong`1.NearestGreaterByRank(System.Int64,`0@,System.Int64@,System.Int64@)">
            <summary>
            Search for the nearest key's range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index that was found.
            If the index refers to the start of a key's range or is an interior index for a range, the next key's range will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first key's range.
            If the index is greater than or equal to the start of the last key's range, no index will be found.
            </param>
            <param name="nearestKey">the key that was found</param>
            <param name="count">the count for the key (i.e. the length of the key's range)</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="T:TreeLib.IRangeMap`1">
            <summary>
            Represents an sequenced collection of ranges with associated values. Each range is defined by it's length, and occupies
            a particular position in the sequence, determined by the location where it was inserted (and any insertions/deletions that
            have occurred before or after it in the sequence). The start indices of each range are determined as follows:
            The first range in the sequence starts at 0 and each subsequent range starts at the starting index of the previous range
            plus the length of the previous range. The 'extent' of the range collection is the sum of all lengths.
            All ranges must have a length of at least 1.
            </summary>
            <typeparam name="ValueType">type of the value associated with each range</typeparam>
        </member>
        <member name="P:TreeLib.IRangeMap`1.Count">
            <summary>
            Returns the number of ranges in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue ranges.</exception>
        </member>
        <member name="P:TreeLib.IRangeMap`1.LongCount">
            <summary>
            Returns the number of ranges in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IRangeMap`1.Clear">
            <summary>
            Removes all ranges from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IRangeMap`1.Contains(System.Int32)">
            <summary>
            Determines if there is a range in the collection starting at the specified index.
            </summary>
            <param name="start">index to look for the start of a range at</param>
            <returns>true if there is a range starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeMap`1.TryInsert(System.Int32,System.Int32,`0)">
            <summary>
            Attempt to insert a range of a given length at the specified start index and with an associated value.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            </summary>
            <param name="start">starting index to attempt to insert the new range at</param>
            <param name="length">length of the new range. The length must be at least 1.</param>
            <param name="value">value to associate with the range</param>
            <returns>true if the range was successfully inserted</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRangeMap`1.TryDelete(System.Int32)">
            <summary>
            Attempt to delete the range starting at the specified index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of a range to attempt to delete</param>
            <returns>true if a range was successfully deleted</returns>
        </member>
        <member name="M:TreeLib.IRangeMap`1.TryGetLength(System.Int32,System.Int32@)">
            <summary>
            Attempt to query the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">out parameter receiving the length of the range</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeMap`1.TrySetLength(System.Int32,System.Int32)">
            <summary>
            Attempt to change the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRangeMap`1.TryGetValue(System.Int32,`0@)">
            <summary>
            Attempt to query the value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="value">value associated with the range</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeMap`1.TrySetValue(System.Int32,`0)">
            <summary>
            Attempt to update the value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="value">new value that replaces the old value associated with the range</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeMap`1.TryGet(System.Int32,System.Int32@,`0@)">
            <summary>
            Attempt to get the value and length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">out parameter receiving the length of the range</param>
            <param name="value">out parameter receiving the value associated with the range</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeMap`1.TrySet(System.Int32,System.Int32,`0)">
            <summary>
            Attempt to change the length and value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <param name="value">the value to replace the old value associated with the range</param>
            <returns>true if a range was found starting at the specified index and updated; false if the
            start was not found or the sum of lengths would have exceeded Int32.MaxValue</returns>
        </member>
        <member name="M:TreeLib.IRangeMap`1.Insert(System.Int32,System.Int32,`0)">
            <summary>
            Inserts a range of a given length at the specified start index and with an associated value.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            </summary>
            <param name="start">starting index to attempt to insert the new range at</param>
            <param name="length">length of the new range. The length must be at least 1.</param>
            <param name="value">value to associate with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRangeMap`1.Delete(System.Int32)">
            <summary>
            Attempt to delete the range starting at the specified index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of a range to attempt to delete</param>
            <returns>true if a range was successfully deleted</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.IRangeMap`1.GetLength(System.Int32)">
            <summary>
            Retrieves the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <returns>the length of the range found at the specified start index</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.IRangeMap`1.SetLength(System.Int32,System.Int32)">
            <summary>
            Changes the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRangeMap`1.GetValue(System.Int32)">
            <summary>
            Retrieves the value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <returns>the value associated with the range</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.IRangeMap`1.SetValue(System.Int32,`0)">
            <summary>
            Updates the value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="value">new value that replaces the old value associated with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.IRangeMap`1.Get(System.Int32,System.Int32@,`0@)">
            <summary>
            Retrieves the value and length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">out parameter receiving the length of the range</param>
            <param name="value">out parameter receiving the value associated with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.IRangeMap`1.Set(System.Int32,System.Int32,`0)">
            <summary>
            Changes the length and value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <param name="value">the value to replace the old value associated with the range</param>
            <exception cref="T:System.ArgumentException">the start was not the beginning of a range</exception>
            <exception cref="T:System.OverflowException">sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRangeMap`1.AdjustLength(System.Int32,System.Int32)">
            <summary>
            Adjust the length of the range starting at 'start' by adding 'adjust' to the current length of the
            range. If the length would become 0, the range is removed.
            </summary>
            <param name="start">the start index of the range to adjust</param>
            <param name="adjust">the amount to adjust the length by. Value may be negative to shrink the length</param>
            <returns>The adjusted length</returns>
            <exception cref="T:System.ArgumentException">There is no range starting at the index specified by 'start'.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">the length would become negative</exception>
            <exception cref="T:System.OverflowException">the extent would become larger than Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRangeMap`1.GetExtent">
            <summary>
            Retrieves the extent of the sequence of ranges. The extent is the sum of the lengths of all the ranges.
            </summary>
            <returns>the extent of the ranges</returns>
        </member>
        <member name="M:TreeLib.IRangeMap`1.NearestLessOrEqual(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeMap`1.NearestLess(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeMap`1.NearestGreaterOrEqual(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeMap`1.NearestGreater(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeMap`1.NearestLessOrEqual(System.Int32,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeMap`1.NearestLess(System.Int32,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeMap`1.NearestGreaterOrEqual(System.Int32,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeMap`1.NearestGreater(System.Int32,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="T:TreeLib.IRangeList">
            <summary>
            Represents an sequenced collection of ranges (without associated values). Each range is defined by it's length, and occupies
            a particular position in the sequence, determined by the location where it was inserted (and any insertions/deletions that
            have occurred before or after it in the sequence). The start indices of each range are determined as follows:
            The first range in the sequence starts at 0 and each subsequent range starts at the starting index of the previous range
            plus the length of the previous range. The 'extent' of the range collection is the sum of all lengths.
            All ranges must have a length of at least 1.
            </summary>
        </member>
        <member name="P:TreeLib.IRangeList.Count">
            <summary>
            Returns the number of ranges in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue ranges.</exception>
        </member>
        <member name="P:TreeLib.IRangeList.LongCount">
            <summary>
            Returns the number of ranges in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IRangeList.Clear">
            <summary>
            Removes all ranges from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IRangeList.Contains(System.Int32)">
            <summary>
            Determines if there is a range in the collection starting at the specified index.
            </summary>
            <param name="start">index to look for the start of a range at</param>
            <returns>true if there is a range starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeList.TryInsert(System.Int32,System.Int32)">
            <summary>
            Attempt to insert a range of a given length at the specified start index.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            </summary>
            <param name="start">starting index to attempt to insert the new range at</param>
            <param name="length">length of the new range. The length must be at least 1.</param>
            <returns>true if the range was successfully inserted</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRangeList.TryDelete(System.Int32)">
            <summary>
            Attempt to delete the range starting at the specified index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of a range to attempt to delete</param>
            <returns>true if a range was successfully deleted</returns>
        </member>
        <member name="M:TreeLib.IRangeList.TryGetLength(System.Int32,System.Int32@)">
            <summary>
            Attempt to query the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">out parameter receiving the length of the range</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeList.TrySetLength(System.Int32,System.Int32)">
            <summary>
            Attempt to change the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRangeList.Insert(System.Int32,System.Int32)">
            <summary>
            Inserts a range of a given length at the specified start index.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            </summary>
            <param name="start">starting index to attempt to insert the new range at</param>
            <param name="length">length of the new range. The length must be at least 1.</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRangeList.Delete(System.Int32)">
            <summary>
            Attempt to delete the range starting at the specified index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of a range to attempt to delete</param>
            <returns>true if a range was successfully deleted</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.IRangeList.GetLength(System.Int32)">
            <summary>
            Retrieves the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <returns>the length of the range found at the specified start index</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.IRangeList.SetLength(System.Int32,System.Int32)">
            <summary>
            Changes the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRangeList.AdjustLength(System.Int32,System.Int32)">
            <summary>
            Adjust the length of the range starting at 'start' by adding 'adjust' to the current length of the
            range. If the length would become 0, the range is removed.
            </summary>
            <param name="start">the start index of the range to adjust</param>
            <param name="adjust">the amount to adjust the length by. Value may be negative to shrink the length</param>
            <returns>The adjusted length</returns>
            <exception cref="T:System.ArgumentException">There is no range starting at the index specified by 'start'.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">the length would become negative</exception>
            <exception cref="T:System.OverflowException">the extent would become larger than Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRangeList.GetExtent">
            <summary>
            Retrieves the extent of the sequence of ranges. The extent is the sum of the lengths of all the ranges.
            </summary>
            <returns>the extent of the ranges</returns>
        </member>
        <member name="M:TreeLib.IRangeList.NearestLessOrEqual(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeList.NearestLess(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeList.NearestGreaterOrEqual(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeList.NearestGreater(System.Int32,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeList.NearestLessOrEqual(System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeList.NearestLess(System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeList.NearestGreaterOrEqual(System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeList.NearestGreater(System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="T:TreeLib.IRangeMapLong`1">
            <summary>
            Represents an sequenced collection of ranges with associated values. Each range is defined by it's length, and occupies
            a particular position in the sequence, determined by the location where it was inserted (and any insertions/deletions that
            have occurred before or after it in the sequence). The start indices of each range are determined as follows:
            The first range in the sequence starts at 0 and each subsequent range starts at the starting index of the previous range
            plus the length of the previous range. The 'extent' of the range collection is the sum of all lengths.
            All ranges must have a length of at least 1.
            </summary>
            <typeparam name="ValueType">type of the value associated with each range</typeparam>
        </member>
        <member name="P:TreeLib.IRangeMapLong`1.Count">
            <summary>
            Returns the number of ranges in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue ranges.</exception>
        </member>
        <member name="P:TreeLib.IRangeMapLong`1.LongCount">
            <summary>
            Returns the number of ranges in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.Clear">
            <summary>
            Removes all ranges from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.Contains(System.Int64)">
            <summary>
            Determines if there is a range in the collection starting at the specified index.
            </summary>
            <param name="start">index to look for the start of a range at</param>
            <returns>true if there is a range starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.TryInsert(System.Int64,System.Int64,`0)">
            <summary>
            Attempt to insert a range of a given length at the specified start index and with an associated value.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            </summary>
            <param name="start">starting index to attempt to insert the new range at</param>
            <param name="length">length of the new range. The length must be at least 1.</param>
            <param name="value">value to associate with the range</param>
            <returns>true if the range was successfully inserted</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int64.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.TryDelete(System.Int64)">
            <summary>
            Attempt to delete the range starting at the specified index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of a range to attempt to delete</param>
            <returns>true if a range was successfully deleted</returns>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.TryGetLength(System.Int64,System.Int64@)">
            <summary>
            Attempt to query the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">out parameter receiving the length of the range</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.TrySetLength(System.Int64,System.Int64)">
            <summary>
            Attempt to change the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int64.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.TryGetValue(System.Int64,`0@)">
            <summary>
            Attempt to query the value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="value">value associated with the range</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.TrySetValue(System.Int64,`0)">
            <summary>
            Attempt to update the value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="value">new value that replaces the old value associated with the range</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.TryGet(System.Int64,System.Int64@,`0@)">
            <summary>
            Attempt to get the value and length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">out parameter receiving the length of the range</param>
            <param name="value">out parameter receiving the value associated with the range</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.TrySet(System.Int64,System.Int64,`0)">
            <summary>
            Attempt to change the length and value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <param name="value">the value to replace the old value associated with the range</param>
            <returns>true if a range was found starting at the specified index and updated; false if the
            start was not found or the sum of lengths would have exceeded Int64.MaxValue</returns>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.Insert(System.Int64,System.Int64,`0)">
            <summary>
            Inserts a range of a given length at the specified start index and with an associated value.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            </summary>
            <param name="start">starting index to attempt to insert the new range at</param>
            <param name="length">length of the new range. The length must be at least 1.</param>
            <param name="value">value to associate with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int64.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.Delete(System.Int64)">
            <summary>
            Attempt to delete the range starting at the specified index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of a range to attempt to delete</param>
            <returns>true if a range was successfully deleted</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.GetLength(System.Int64)">
            <summary>
            Retrieves the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <returns>the length of the range found at the specified start index</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.SetLength(System.Int64,System.Int64)">
            <summary>
            Changes the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int64.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.GetValue(System.Int64)">
            <summary>
            Retrieves the value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <returns>the value associated with the range</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.SetValue(System.Int64,`0)">
            <summary>
            Updates the value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="value">new value that replaces the old value associated with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.Get(System.Int64,System.Int64@,`0@)">
            <summary>
            Retrieves the value and length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">out parameter receiving the length of the range</param>
            <param name="value">out parameter receiving the value associated with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.Set(System.Int64,System.Int64,`0)">
            <summary>
            Changes the length and value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <param name="value">the value to replace the old value associated with the range</param>
            <exception cref="T:System.ArgumentException">the start was not the beginning of a range</exception>
            <exception cref="T:System.OverflowException">sum of lengths would have exceeded Int64.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.AdjustLength(System.Int64,System.Int64)">
            <summary>
            Adjust the length of the range starting at 'start' by adding 'adjust' to the current length of the
            range. If the length would become 0, the range is removed.
            </summary>
            <param name="start">the start index of the range to adjust</param>
            <param name="adjust">the amount to adjust the length by. Value may be negative to shrink the length</param>
            <returns>The adjusted length</returns>
            <exception cref="T:System.ArgumentException">There is no range starting at the index specified by 'start'.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">the length would become negative</exception>
            <exception cref="T:System.OverflowException">the extent would become larger than Int64.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.GetExtent">
            <summary>
            Retrieves the extent of the sequence of ranges. The extent is the sum of the lengths of all the ranges.
            </summary>
            <returns>the extent of the ranges</returns>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.NearestLessOrEqual(System.Int64,System.Int64@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.NearestLess(System.Int64,System.Int64@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.NearestGreaterOrEqual(System.Int64,System.Int64@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.NearestGreater(System.Int64,System.Int64@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.NearestLessOrEqual(System.Int64,System.Int64@,System.Int64@,`0@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.NearestLess(System.Int64,System.Int64@,System.Int64@,`0@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.NearestGreaterOrEqual(System.Int64,System.Int64@,System.Int64@,`0@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeMapLong`1.NearestGreater(System.Int64,System.Int64@,System.Int64@,`0@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="T:TreeLib.IRangeListLong">
            <summary>
            Represents an sequenced collection of ranges (without associated values). Each range is defined by it's length, and occupies
            a particular position in the sequence, determined by the location where it was inserted (and any insertions/deletions that
            have occurred before or after it in the sequence). The start indices of each range are determined as follows:
            The first range in the sequence starts at 0 and each subsequent range starts at the starting index of the previous range
            plus the length of the previous range. The 'extent' of the range collection is the sum of all lengths.
            All ranges must have a length of at least 1.
            </summary>
        </member>
        <member name="P:TreeLib.IRangeListLong.Count">
            <summary>
            Returns the number of ranges in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue ranges.</exception>
        </member>
        <member name="P:TreeLib.IRangeListLong.LongCount">
            <summary>
            Returns the number of ranges in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IRangeListLong.Clear">
            <summary>
            Removes all ranges from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IRangeListLong.Contains(System.Int64)">
            <summary>
            Determines if there is a range in the collection starting at the specified index.
            </summary>
            <param name="start">index to look for the start of a range at</param>
            <returns>true if there is a range starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeListLong.TryInsert(System.Int64,System.Int64)">
            <summary>
            Attempt to insert a range of a given length at the specified start index.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            </summary>
            <param name="start">starting index to attempt to insert the new range at</param>
            <param name="length">length of the new range. The length must be at least 1.</param>
            <returns>true if the range was successfully inserted</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int64.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRangeListLong.TryDelete(System.Int64)">
            <summary>
            Attempt to delete the range starting at the specified index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of a range to attempt to delete</param>
            <returns>true if a range was successfully deleted</returns>
        </member>
        <member name="M:TreeLib.IRangeListLong.TryGetLength(System.Int64,System.Int64@)">
            <summary>
            Attempt to query the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">out parameter receiving the length of the range</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeListLong.TrySetLength(System.Int64,System.Int64)">
            <summary>
            Attempt to change the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int64.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRangeListLong.Insert(System.Int64,System.Int64)">
            <summary>
            Inserts a range of a given length at the specified start index.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            </summary>
            <param name="start">starting index to attempt to insert the new range at</param>
            <param name="length">length of the new range. The length must be at least 1.</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int64.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRangeListLong.Delete(System.Int64)">
            <summary>
            Attempt to delete the range starting at the specified index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of a range to attempt to delete</param>
            <returns>true if a range was successfully deleted</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.IRangeListLong.GetLength(System.Int64)">
            <summary>
            Retrieves the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <returns>the length of the range found at the specified start index</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
        </member>
        <member name="M:TreeLib.IRangeListLong.SetLength(System.Int64,System.Int64)">
            <summary>
            Changes the length associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to query</param>
            <param name="length">new length for the range. The length must be at least 1.</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int64.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRangeListLong.AdjustLength(System.Int64,System.Int64)">
            <summary>
            Adjust the length of the range starting at 'start' by adding 'adjust' to the current length of the
            range. If the length would become 0, the range is removed.
            </summary>
            <param name="start">the start index of the range to adjust</param>
            <param name="adjust">the amount to adjust the length by. Value may be negative to shrink the length</param>
            <returns>The adjusted length</returns>
            <exception cref="T:System.ArgumentException">There is no range starting at the index specified by 'start'.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">the length would become negative</exception>
            <exception cref="T:System.OverflowException">the extent would become larger than Int64.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRangeListLong.GetExtent">
            <summary>
            Retrieves the extent of the sequence of ranges. The extent is the sum of the lengths of all the ranges.
            </summary>
            <returns>the extent of the ranges</returns>
        </member>
        <member name="M:TreeLib.IRangeListLong.NearestLessOrEqual(System.Int64,System.Int64@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeListLong.NearestLess(System.Int64,System.Int64@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeListLong.NearestGreaterOrEqual(System.Int64,System.Int64@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeListLong.NearestGreater(System.Int64,System.Int64@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeListLong.NearestLessOrEqual(System.Int64,System.Int64@,System.Int64@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeListLong.NearestLess(System.Int64,System.Int64@,System.Int64@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeListLong.NearestGreaterOrEqual(System.Int64,System.Int64@,System.Int64@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRangeListLong.NearestGreater(System.Int64,System.Int64@,System.Int64@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <param name="length">an out parameter receiving the length of the range that was found</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="T:TreeLib.Side">
            <summary>
            Identifies which side of a Range2 mapping an index refers to.
            </summary>
        </member>
        <member name="F:TreeLib.Side.X">
            <summary>
            The index applies to the first (left side) range sequence
            </summary>
        </member>
        <member name="F:TreeLib.Side.Y">
            <summary>
            The index applies to the second (right side) range sequence
            </summary>
        </member>
        <member name="T:TreeLib.IRange2Map`1">
            <summary>
            Represents an sequenced collection of range-to-range pairs with associated values. Each range pair is defined by two lengths,
            one for the X sequence and one for the Y sequence.
            With regard to a particular sequence, each range occupies a particular position in the sequence, determined by the location
            where it was inserted (and any insertions/deletions that have occurred before or after it in the sequence).
            Within the sequence, the start indices of each range are determined as follows:
            The first range in the sequence starts at 0 and each subsequent range starts at the starting index of the previous range
            plus the length of the previous range. The 'extent' of the range collection is the sum of all lengths.
            The above applies separately to both the X side sequence and the Y side sequence.
            All ranges must have a lengths of at least 1, on both sides.
            </summary>
            <typeparam name="ValueType">type of the value associated with each range pair</typeparam>
        </member>
        <member name="P:TreeLib.IRange2Map`1.Count">
            <summary>
            Returns the number of range pairs in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue range pairs.</exception>
        </member>
        <member name="P:TreeLib.IRange2Map`1.LongCount">
            <summary>
            Returns the number of ranges in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IRange2Map`1.Clear">
            <summary>
            Removes all range pairs from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IRange2Map`1.Contains(System.Int32,TreeLib.Side)">
            <summary>
            Determines if there is a range pair in the collection starting at the index specified, with respect to the side specified.
            </summary>
            <param name="start">index to look for the start of a range at</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <returns>true if there is a range starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2Map`1.TryInsert(System.Int32,TreeLib.Side,System.Int32,System.Int32,`0)">
            <summary>
            Attempt to insert a range pair defined by the given pair of lengths at the specified start index with respect to
            the specified side and with an associated value.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            The sequence of the non-specified side is also updated, by inserting the other length of the pair at the same
            rank in the sequence as on the specified side.
            </summary>
            <param name="start">the specified start index to insert before</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <param name="xLength">the length of the X side of the range pair. the length must be at least 1.</param>
            <param name="yLength">the length of the Y side of the range pair. the length must be at least 1.</param>
            <param name="value">the value to associate with the range pair</param>
            <returns>true if the range was successfully inserted</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue on either side</exception>
        </member>
        <member name="M:TreeLib.IRange2Map`1.TryDelete(System.Int32,TreeLib.Side)">
            <summary>
            Attempt to delete the range pair starting at the specified index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to delete</param>
            <param name="side">the side (X or Y) to which the start index applies</param>
            <returns>true if a range pair was successfully deleted</returns>
        </member>
        <member name="M:TreeLib.IRange2Map`1.TryGetLength(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Attempt to query the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies. The side also determines which length is returned</param>
            <param name="length">the length of the range from the specified side (X or Y)</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2Map`1.TrySetLength(System.Int32,TreeLib.Side,System.Int32)">
            <summary>
            Attempt to change the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to modify</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="length">the new length to apply on the specified side (X or Y) of the range pair. The new length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.OverflowException">the sum of lengths on the specified side would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRange2Map`1.TryGetValue(System.Int32,TreeLib.Side,`0@)">
            <summary>
            Attempt to query the value associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="value">value associated with the range</param>
            <returns>true if a range was found starting at the specified index on the specified side</returns>
        </member>
        <member name="M:TreeLib.IRange2Map`1.TrySetValue(System.Int32,TreeLib.Side,`0)">
            <summary>
            Attempt to update the value associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to update</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="value">new value that replaces the old value associated with the range</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
        </member>
        <member name="M:TreeLib.IRange2Map`1.TryGet(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,`0@)">
            <summary>
            Attempt to get the value and lengths associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="otherStart">out parameter receiving the start index of the range from the opposite side of that specified</param>
            <param name="xLength">out parameter receiving the length of the range on the X side</param>
            <param name="yLength">out parameter receiving the length f the range on the Y side</param>
            <param name="value">out parameter receiving the value associated with the range</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
        </member>
        <member name="M:TreeLib.IRange2Map`1.TrySet(System.Int32,TreeLib.Side,System.Int32,System.Int32,`0)">
            <summary>
            Attempt to change the lengths and value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="side">the side with which the start parameter applies</param>
            <param name="xLength">new X-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="yLength">new Y-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="value">the value to replace the old value associated with the range</param>
            <returns>true if a range was found starting at the specified index and updated; false if the
            start was not found or the sum of lengths would have exceeded Int32.MaxValue</returns>
        </member>
        <member name="M:TreeLib.IRange2Map`1.Insert(System.Int32,TreeLib.Side,System.Int32,System.Int32,`0)">
            <summary>
            Insert a range pair defined by the given pair of lengths at the specified start index with respect to
            the specified side and with an associated value.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            The sequence of the non-specified side is also updated, by inserting the other length of the pair at the same
            rank in the sequence as on the specified side.
            </summary>
            <param name="start">the specified start index to insert before</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <param name="xLength">the length of the X side of the range pair. the length must be at least 1.</param>
            <param name="yLength">the length of the Y side of the range pair. the length must be at least 1.</param>
            <param name="value">the value to associate with the range pair</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue on either side</exception>
        </member>
        <member name="M:TreeLib.IRange2Map`1.Delete(System.Int32,TreeLib.Side)">
            <summary>
            Deletes the range pair starting at the specified index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to delete</param>
            <param name="side">the side (X or Y) to which the start index applies</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.IRange2Map`1.GetLength(System.Int32,TreeLib.Side)">
            <summary>
            Retrieves the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies. The side also determines which length is returned</param>
            <returns>the length of the range from the specified side (X or Y)</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.IRange2Map`1.SetLength(System.Int32,TreeLib.Side,System.Int32)">
            <summary>
            Changes the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to modify</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="length">the new length to apply on the specified side (X or Y) of the range pair. The new length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
            <exception cref="T:System.OverflowException">the sum of lengths on the specified side would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRange2Map`1.GetValue(System.Int32,TreeLib.Side)">
            <summary>
            Retrieves the value associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <returns>the value associated with the range</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.IRange2Map`1.SetValue(System.Int32,TreeLib.Side,`0)">
            <summary>
            Updates the value associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to update</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="value">new value that replaces the old value associated with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.IRange2Map`1.Get(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,`0@)">
            <summary>
            Attempt to get the value and lengths associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="otherStart">out parameter receiving the start index of the range from the opposite side of that specified</param>
            <param name="xLength">out parameter receiving the length of the range on the X side</param>
            <param name="yLength">out parameter receiving the length f the range on the Y side</param>
            <param name="value">out parameter receiving the value associated with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.IRange2Map`1.Set(System.Int32,TreeLib.Side,System.Int32,System.Int32,`0)">
            <summary>
            Changes the lengths and value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="side">the side with which the start parameter applies</param>
            <param name="xLength">new X-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="yLength">new Y-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="value">the value to replace the old value associated with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
            <exception cref="T:System.OverflowException">sum of lengths would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRange2Map`1.AdjustLength(System.Int32,TreeLib.Side,System.Int32,System.Int32)">
            <summary>
            Adjust the lengths of the range starting at 'start' by adding xAdjust and yAdjust to the current lengths of the
            range. If the lengths would become 0, the range is removed.
            </summary>
            <param name="start">the start index of the range to adjust</param>
            <param name="side">which side (X or Y) the start parameter applies</param>
            <param name="xAdjust">the amount to adjust the X length by. Value may be negative to shrink the length</param>
            <param name="yAdjust">the amount to adjust the Y length by. Value may be negative to shrink the length</param>
            <returns>The adjusted length</returns>
            <exception cref="T:System.ArgumentException">There is no range starting at the index specified by 'start', or the length on
            one side would become 0 while the length on the other side would not be 0.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">one or both of the lengths would become negative</exception>
            <exception cref="T:System.OverflowException">the X or Y extent would become larger than Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRange2Map`1.GetExtent(TreeLib.Side)">
            <summary>
            Retrieves the extent of the sequence of ranges on the specified side. The extent is the sum of the lengths of all the ranges.
            </summary>
            <param name="side">the side (X or Y) to which the query applies.</param>
            <returns>the extent of the ranges on the specified side</returns>
        </member>
        <member name="M:TreeLib.IRange2Map`1.NearestLessOrEqual(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index with respect to the specified side.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2Map`1.NearestLess(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2Map`1.NearestGreaterOrEqual(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2Map`1.NearestGreater(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2Map`1.NearestLessOrEqual(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index with respect to the specified side.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2Map`1.NearestLess(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2Map`1.NearestGreaterOrEqual(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2Map`1.NearestGreater(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@,`0@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="T:TreeLib.IRange2List">
            <summary>
            Represents an sequenced collection of range-to-range pairs (without associated values). Each range pair is defined by two lengths,
            one for the X sequence and one for the Y sequence.
            With regard to a particular sequence, each range occupies a particular position in the sequence, determined by the location
            where it was inserted (and any insertions/deletions that have occurred before or after it in the sequence).
            Within the sequence, the start indices of each range are determined as follows:
            The first range in the sequence starts at 0 and each subsequent range starts at the starting index of the previous range
            plus the length of the previous range. The 'extent' of the range collection is the sum of all lengths.
            The above applies separately to both the X side sequence and the Y side sequence.
            All ranges must have a lengths of at least 1, on both sides.
            </summary>
        </member>
        <member name="P:TreeLib.IRange2List.Count">
            <summary>
            Returns the number of range pairs in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue range pairs.</exception>
        </member>
        <member name="P:TreeLib.IRange2List.LongCount">
            <summary>
            Returns the number of ranges in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IRange2List.Clear">
            <summary>
            Removes all range pairs from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IRange2List.Contains(System.Int32,TreeLib.Side)">
            <summary>
            Determines if there is a range pair in the collection starting at the index specified, with respect to the side specified.
            </summary>
            <param name="start">index to look for the start of a range at</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <returns>true if there is a range starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2List.TryInsert(System.Int32,TreeLib.Side,System.Int32,System.Int32)">
            <summary>
            Attempt to insert a range pair defined by the given pair of lengths at the specified start index with respect to
            the specified side.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            The sequence of the non-specified side is also updated, by inserting the other length of the pair at the same
            rank in the sequence as on the specified side.
            </summary>
            <param name="start">the specified start index to insert before</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <param name="xLength">the length of the X side of the range pair. the length must be at least 1.</param>
            <param name="yLength">the length of the Y side of the range pair. the length must be at least 1.</param>
            <returns>true if the range was successfully inserted</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue on either side</exception>
        </member>
        <member name="M:TreeLib.IRange2List.TryDelete(System.Int32,TreeLib.Side)">
            <summary>
            Attempt to delete the range pair starting at the specified index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to delete</param>
            <param name="side">the side (X or Y) to which the start index applies</param>
            <returns>true if a range pair was successfully deleted</returns>
        </member>
        <member name="M:TreeLib.IRange2List.TryGetLength(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Attempt to query the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies. The side also determines which length is returned</param>
            <param name="length">the length of the range from the specified side (X or Y)</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2List.TrySetLength(System.Int32,TreeLib.Side,System.Int32)">
            <summary>
            Attempt to change the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to modify</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="length">the new length to apply on the specified side (X or Y) of the range pair. The new length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.OverflowException">the sum of lengths on the specified side would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRange2List.TryGet(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Attempt to get the lengths associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="otherStart">out parameter receiving the start index of the range from the opposite side of that specified</param>
            <param name="xLength">out parameter receiving the length of the range on the X side</param>
            <param name="yLength">out parameter receiving the length f the range on the Y side</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
        </member>
        <member name="M:TreeLib.IRange2List.TrySet(System.Int32,TreeLib.Side,System.Int32,System.Int32)">
            <summary>
            Attempt to change the lengths associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="side">the side with which the start parameter applies</param>
            <param name="xLength">new X-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="yLength">new Y-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <returns>true if a range was found starting at the specified index and updated; false if the
            start was not found or the sum of lengths would have exceeded Int32.MaxValue</returns>
        </member>
        <member name="M:TreeLib.IRange2List.Insert(System.Int32,TreeLib.Side,System.Int32,System.Int32)">
            <summary>
            Insert a range pair defined by the given pair of lengths at the specified start index with respect to
            the specified side.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            The sequence of the non-specified side is also updated, by inserting the other length of the pair at the same
            rank in the sequence as on the specified side.
            </summary>
            <param name="start">the specified start index to insert before</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <param name="xLength">the length of the X side of the range pair. the length must be at least 1.</param>
            <param name="yLength">the length of the Y side of the range pair. the length must be at least 1.</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int32.MaxValue on either side</exception>
        </member>
        <member name="M:TreeLib.IRange2List.Delete(System.Int32,TreeLib.Side)">
            <summary>
            Deletes the range pair starting at the specified index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to delete</param>
            <param name="side">the side (X or Y) to which the start index applies</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.IRange2List.GetLength(System.Int32,TreeLib.Side)">
            <summary>
            Retrieves the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies. The side also determines which length is returned</param>
            <returns>the length of the range from the specified side (X or Y)</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.IRange2List.SetLength(System.Int32,TreeLib.Side,System.Int32)">
            <summary>
            Changes the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to modify</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="length">the new length to apply on the specified side (X or Y) of the range pair. The new length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
            <exception cref="T:System.OverflowException">the sum of lengths on the specified side would have exceeded Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRange2List.Get(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Attempt to get the lengths associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="otherStart">out parameter receiving the start index of the range from the opposite side of that specified</param>
            <param name="xLength">out parameter receiving the length of the range on the X side</param>
            <param name="yLength">out parameter receiving the length f the range on the Y side</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.IRange2List.Set(System.Int32,TreeLib.Side,System.Int32,System.Int32)">
            <summary>
            Changes the lengths associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="side">the side with which the start parameter applies</param>
            <param name="xLength">new X-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="yLength">new Y-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <returns>true if a range was found starting at the specified index and updated; false if the
            start was not found or the sum of lengths would have exceeded Int32.MaxValue</returns>
        </member>
        <member name="M:TreeLib.IRange2List.AdjustLength(System.Int32,TreeLib.Side,System.Int32,System.Int32)">
            <summary>
            Adjust the lengths of the range starting at 'start' by adding xAdjust and yAdjust to the current lengths of the
            range. If the lengths would become 0, the range is removed.
            </summary>
            <param name="start">the start index of the range to adjust</param>
            <param name="side">which side (X or Y) the start parameter applies</param>
            <param name="xAdjust">the amount to adjust the X length by. Value may be negative to shrink the length</param>
            <param name="yAdjust">the amount to adjust the Y length by. Value may be negative to shrink the length</param>
            <returns>The adjusted length</returns>
            <exception cref="T:System.ArgumentException">There is no range starting at the index specified by 'start', or the length on
            one side would become 0 while the length on the other side would not be 0.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">one or both of the lengths would become negative</exception>
            <exception cref="T:System.OverflowException">the X or Y extent would become larger than Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRange2List.GetExtent(TreeLib.Side)">
            <summary>
            Retrieves the extent of the sequence of ranges on the specified side. The extent is the sum of the lengths of all the ranges.
            </summary>
            <param name="side">the side (X or Y) to which the query applies.</param>
            <returns>the extent of the ranges on the specified side</returns>
        </member>
        <member name="M:TreeLib.IRange2List.NearestLessOrEqual(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index with respect to the specified side.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2List.NearestLess(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2List.NearestGreaterOrEqual(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2List.NearestGreater(System.Int32,TreeLib.Side,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2List.NearestLessOrEqual(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index with respect to the specified side.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2List.NearestLess(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2List.NearestGreaterOrEqual(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2List.NearestGreater(System.Int32,TreeLib.Side,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="T:TreeLib.IRange2MapLong`1">
            <summary>
            Represents an sequenced collection of range-to-range pairs with associated values. Each range pair is defined by two lengths,
            one for the X sequence and one for the Y sequence.
            With regard to a particular sequence, each range occupies a particular position in the sequence, determined by the location
            where it was inserted (and any insertions/deletions that have occurred before or after it in the sequence).
            Within the sequence, the start indices of each range are determined as follows:
            The first range in the sequence starts at 0 and each subsequent range starts at the starting index of the previous range
            plus the length of the previous range. The 'extent' of the range collection is the sum of all lengths.
            The above applies separately to both the X side sequence and the Y side sequence.
            All ranges must have a lengths of at least 1, on both sides.
            </summary>
            <typeparam name="ValueType">type of the value associated with each range pair</typeparam>
        </member>
        <member name="P:TreeLib.IRange2MapLong`1.Count">
            <summary>
            Returns the number of range pairs in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue range pairs.</exception>
        </member>
        <member name="P:TreeLib.IRange2MapLong`1.LongCount">
            <summary>
            Returns the number of ranges in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.Clear">
            <summary>
            Removes all range pairs from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.Contains(System.Int64,TreeLib.Side)">
            <summary>
            Determines if there is a range pair in the collection starting at the index specified, with respect to the side specified.
            </summary>
            <param name="start">index to look for the start of a range at</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <returns>true if there is a range starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.TryInsert(System.Int64,TreeLib.Side,System.Int64,System.Int64,`0)">
            <summary>
            Attempt to insert a range pair defined by the given pair of lengths at the specified start index with respect to
            the specified side and with an associated value.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            The sequence of the non-specified side is also updated, by inserting the other length of the pair at the same
            rank in the sequence as on the specified side.
            </summary>
            <param name="start">the specified start index to insert before</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <param name="xLength">the length of the X side of the range pair. the length must be at least 1.</param>
            <param name="yLength">the length of the Y side of the range pair. the length must be at least 1.</param>
            <param name="value">the value to associate with the range pair</param>
            <returns>true if the range was successfully inserted</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int64.MaxValue on either side</exception>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.TryDelete(System.Int64,TreeLib.Side)">
            <summary>
            Attempt to delete the range pair starting at the specified index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to delete</param>
            <param name="side">the side (X or Y) to which the start index applies</param>
            <returns>true if a range pair was successfully deleted</returns>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.TryGetLength(System.Int64,TreeLib.Side,System.Int64@)">
            <summary>
            Attempt to query the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies. The side also determines which length is returned</param>
            <param name="length">the length of the range from the specified side (X or Y)</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.TrySetLength(System.Int64,TreeLib.Side,System.Int64)">
            <summary>
            Attempt to change the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to modify</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="length">the new length to apply on the specified side (X or Y) of the range pair. The new length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.OverflowException">the sum of lengths on the specified side would have exceeded Int64.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.TryGetValue(System.Int64,TreeLib.Side,`0@)">
            <summary>
            Attempt to query the value associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="value">value associated with the range</param>
            <returns>true if a range was found starting at the specified index on the specified side</returns>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.TrySetValue(System.Int64,TreeLib.Side,`0)">
            <summary>
            Attempt to update the value associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to update</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="value">new value that replaces the old value associated with the range</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.TryGet(System.Int64,TreeLib.Side,System.Int64@,System.Int64@,System.Int64@,`0@)">
            <summary>
            Attempt to get the value and lengths associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="otherStart">out parameter receiving the start index of the range from the opposite side of that specified</param>
            <param name="xLength">out parameter receiving the length of the range on the X side</param>
            <param name="yLength">out parameter receiving the length f the range on the Y side</param>
            <param name="value">out parameter receiving the value associated with the range</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.TrySet(System.Int64,TreeLib.Side,System.Int64,System.Int64,`0)">
            <summary>
            Attempt to change the lengths and value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="side">the side with which the start parameter applies</param>
            <param name="xLength">new X-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="yLength">new Y-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="value">the value to replace the old value associated with the range</param>
            <returns>true if a range was found starting at the specified index and updated; false if the
            start was not found or the sum of lengths would have exceeded Int64.MaxValue</returns>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.Insert(System.Int64,TreeLib.Side,System.Int64,System.Int64,`0)">
            <summary>
            Insert a range pair defined by the given pair of lengths at the specified start index with respect to
            the specified side and with an associated value.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            The sequence of the non-specified side is also updated, by inserting the other length of the pair at the same
            rank in the sequence as on the specified side.
            </summary>
            <param name="start">the specified start index to insert before</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <param name="xLength">the length of the X side of the range pair. the length must be at least 1.</param>
            <param name="yLength">the length of the Y side of the range pair. the length must be at least 1.</param>
            <param name="value">the value to associate with the range pair</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int64.MaxValue on either side</exception>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.Delete(System.Int64,TreeLib.Side)">
            <summary>
            Deletes the range pair starting at the specified index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to delete</param>
            <param name="side">the side (X or Y) to which the start index applies</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.GetLength(System.Int64,TreeLib.Side)">
            <summary>
            Retrieves the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies. The side also determines which length is returned</param>
            <returns>the length of the range from the specified side (X or Y)</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.SetLength(System.Int64,TreeLib.Side,System.Int64)">
            <summary>
            Changes the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to modify</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="length">the new length to apply on the specified side (X or Y) of the range pair. The new length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
            <exception cref="T:System.OverflowException">the sum of lengths on the specified side would have exceeded Int64.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.GetValue(System.Int64,TreeLib.Side)">
            <summary>
            Retrieves the value associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <returns>the value associated with the range</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.SetValue(System.Int64,TreeLib.Side,`0)">
            <summary>
            Updates the value associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to update</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="value">new value that replaces the old value associated with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.Get(System.Int64,TreeLib.Side,System.Int64@,System.Int64@,System.Int64@,`0@)">
            <summary>
            Attempt to get the value and lengths associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="otherStart">out parameter receiving the start index of the range from the opposite side of that specified</param>
            <param name="xLength">out parameter receiving the length of the range on the X side</param>
            <param name="yLength">out parameter receiving the length f the range on the Y side</param>
            <param name="value">out parameter receiving the value associated with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.Set(System.Int64,TreeLib.Side,System.Int64,System.Int64,`0)">
            <summary>
            Changes the lengths and value associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="side">the side with which the start parameter applies</param>
            <param name="xLength">new X-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="yLength">new Y-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="value">the value to replace the old value associated with the range</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
            <exception cref="T:System.OverflowException">sum of lengths would have exceeded Int64.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.AdjustLength(System.Int64,TreeLib.Side,System.Int64,System.Int64)">
            <summary>
            Adjust the lengths of the range starting at 'start' by adding xAdjust and yAdjust to the current lengths of the
            range. If the lengths would become 0, the range is removed.
            </summary>
            <param name="start">the start index of the range to adjust</param>
            <param name="side">which side (X or Y) the start parameter applies</param>
            <param name="xAdjust">the amount to adjust the X length by. Value may be negative to shrink the length</param>
            <param name="yAdjust">the amount to adjust the Y length by. Value may be negative to shrink the length</param>
            <returns>The adjusted length</returns>
            <exception cref="T:System.ArgumentException">There is no range starting at the index specified by 'start', or the length on
            one side would become 0 while the length on the other side would not be 0.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">one or both of the lengths would become negative</exception>
            <exception cref="T:System.OverflowException">the X or Y extent would become larger than Int64.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.GetExtent(TreeLib.Side)">
            <summary>
            Retrieves the extent of the sequence of ranges on the specified side. The extent is the sum of the lengths of all the ranges.
            </summary>
            <param name="side">the side (X or Y) to which the query applies.</param>
            <returns>the extent of the ranges on the specified side</returns>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.NearestLessOrEqual(System.Int64,TreeLib.Side,System.Int64@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index with respect to the specified side.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.NearestLess(System.Int64,TreeLib.Side,System.Int64@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.NearestGreaterOrEqual(System.Int64,TreeLib.Side,System.Int64@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.NearestGreater(System.Int64,TreeLib.Side,System.Int64@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.NearestLessOrEqual(System.Int64,TreeLib.Side,System.Int64@,System.Int64@,System.Int64@,System.Int64@,`0@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index with respect to the specified side.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.NearestLess(System.Int64,TreeLib.Side,System.Int64@,System.Int64@,System.Int64@,System.Int64@,`0@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.NearestGreaterOrEqual(System.Int64,TreeLib.Side,System.Int64@,System.Int64@,System.Int64@,System.Int64@,`0@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2MapLong`1.NearestGreater(System.Int64,TreeLib.Side,System.Int64@,System.Int64@,System.Int64@,System.Int64@,`0@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <param name="value">an out parameter receiving the value associated with the range that was found</param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="T:TreeLib.IRange2ListLong">
            <summary>
            Represents an sequenced collection of range-to-range pairs (without associated values). Each range pair is defined by two lengths,
            one for the X sequence and one for the Y sequence.
            With regard to a particular sequence, each range occupies a particular position in the sequence, determined by the location
            where it was inserted (and any insertions/deletions that have occurred before or after it in the sequence).
            Within the sequence, the start indices of each range are determined as follows:
            The first range in the sequence starts at 0 and each subsequent range starts at the starting index of the previous range
            plus the length of the previous range. The 'extent' of the range collection is the sum of all lengths.
            The above applies separately to both the X side sequence and the Y side sequence.
            All ranges must have a lengths of at least 1, on both sides.
            </summary>
        </member>
        <member name="P:TreeLib.IRange2ListLong.Count">
            <summary>
            Returns the number of range pairs in the collection as an unsigned int.
            </summary>
            <exception cref="T:System.OverflowException">The collection contains more than UInt32.MaxValue range pairs.</exception>
        </member>
        <member name="P:TreeLib.IRange2ListLong.LongCount">
            <summary>
            Returns the number of ranges in the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IRange2ListLong.Clear">
            <summary>
            Removes all range pairs from the collection.
            </summary>
        </member>
        <member name="M:TreeLib.IRange2ListLong.Contains(System.Int64,TreeLib.Side)">
            <summary>
            Determines if there is a range pair in the collection starting at the index specified, with respect to the side specified.
            </summary>
            <param name="start">index to look for the start of a range at</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <returns>true if there is a range starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2ListLong.TryInsert(System.Int64,TreeLib.Side,System.Int64,System.Int64)">
            <summary>
            Attempt to insert a range pair defined by the given pair of lengths at the specified start index with respect to
            the specified side.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            The sequence of the non-specified side is also updated, by inserting the other length of the pair at the same
            rank in the sequence as on the specified side.
            </summary>
            <param name="start">the specified start index to insert before</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <param name="xLength">the length of the X side of the range pair. the length must be at least 1.</param>
            <param name="yLength">the length of the Y side of the range pair. the length must be at least 1.</param>
            <returns>true if the range was successfully inserted</returns>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int64.MaxValue on either side</exception>
        </member>
        <member name="M:TreeLib.IRange2ListLong.TryDelete(System.Int64,TreeLib.Side)">
            <summary>
            Attempt to delete the range pair starting at the specified index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to delete</param>
            <param name="side">the side (X or Y) to which the start index applies</param>
            <returns>true if a range pair was successfully deleted</returns>
        </member>
        <member name="M:TreeLib.IRange2ListLong.TryGetLength(System.Int64,TreeLib.Side,System.Int64@)">
            <summary>
            Attempt to query the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies. The side also determines which length is returned</param>
            <param name="length">the length of the range from the specified side (X or Y)</param>
            <returns>true if a range was found starting at the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2ListLong.TrySetLength(System.Int64,TreeLib.Side,System.Int64)">
            <summary>
            Attempt to change the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to modify</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="length">the new length to apply on the specified side (X or Y) of the range pair. The new length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.OverflowException">the sum of lengths on the specified side would have exceeded Int64.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRange2ListLong.TryGet(System.Int64,TreeLib.Side,System.Int64@,System.Int64@,System.Int64@)">
            <summary>
            Attempt to get the lengths associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="otherStart">out parameter receiving the start index of the range from the opposite side of that specified</param>
            <param name="xLength">out parameter receiving the length of the range on the X side</param>
            <param name="yLength">out parameter receiving the length f the range on the Y side</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
        </member>
        <member name="M:TreeLib.IRange2ListLong.TrySet(System.Int64,TreeLib.Side,System.Int64,System.Int64)">
            <summary>
            Attempt to change the lengths associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="side">the side with which the start parameter applies</param>
            <param name="xLength">new X-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="yLength">new Y-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <returns>true if a range was found starting at the specified index and updated; false if the
            start was not found or the sum of lengths would have exceeded Int32.MaxValue</returns>
        </member>
        <member name="M:TreeLib.IRange2ListLong.Insert(System.Int64,TreeLib.Side,System.Int64,System.Int64)">
            <summary>
            Insert a range pair defined by the given pair of lengths at the specified start index with respect to
            the specified side.
            If the range can't be inserted, the collection is left unchanged. In order to insert at the specified start
            index, there must be an existing range starting at that index (where the new range will be inserted immediately
            before the existing range at that start index), or the index must be equal to the extent of
            the collection (wherein the range will be added at the end of the sequence).
            The sequence of the non-specified side is also updated, by inserting the other length of the pair at the same
            rank in the sequence as on the specified side.
            </summary>
            <param name="start">the specified start index to insert before</param>
            <param name="side">the side (X or Y) to which the specified index applies</param>
            <param name="xLength">the length of the X side of the range pair. the length must be at least 1.</param>
            <param name="yLength">the length of the Y side of the range pair. the length must be at least 1.</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
            <exception cref="T:System.OverflowException">the sum of lengths would have exceeded Int64.MaxValue on either side</exception>
        </member>
        <member name="M:TreeLib.IRange2ListLong.Delete(System.Int64,TreeLib.Side)">
            <summary>
            Deletes the range pair starting at the specified index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to delete</param>
            <param name="side">the side (X or Y) to which the start index applies</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.IRange2ListLong.GetLength(System.Int64,TreeLib.Side)">
            <summary>
            Retrieves the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies. The side also determines which length is returned</param>
            <returns>the length of the range from the specified side (X or Y)</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.IRange2ListLong.SetLength(System.Int64,TreeLib.Side,System.Int64)">
            <summary>
            Changes the length associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to modify</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="length">the new length to apply on the specified side (X or Y) of the range pair. The new length must be at least 1.</param>
            <returns>true if a range was found starting at the specified index and updated</returns>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
            <exception cref="T:System.OverflowException">the sum of lengths on the specified side would have exceeded Int64.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRange2ListLong.Get(System.Int64,TreeLib.Side,System.Int64@,System.Int64@,System.Int64@)">
            <summary>
            Attempt to get the lengths associated with the range pair starting at the specified start index with respect to the specified side.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">the start index of the range to query</param>
            <param name="side">the side (X or Y) to which the start index applies.</param>
            <param name="otherStart">out parameter receiving the start index of the range from the opposite side of that specified</param>
            <param name="xLength">out parameter receiving the length of the range on the X side</param>
            <param name="yLength">out parameter receiving the length f the range on the Y side</param>
            <exception cref="T:System.ArgumentException">there is no range starting at the specified index on the specified side</exception>
        </member>
        <member name="M:TreeLib.IRange2ListLong.Set(System.Int64,TreeLib.Side,System.Int64,System.Int64)">
            <summary>
            Changes the lengths associated with the range starting at the specified start index.
            The index must refer to the start of a range; an index to the interior of a range is not permitted.
            </summary>
            <param name="start">start of the range to update</param>
            <param name="side">the side with which the start parameter applies</param>
            <param name="xLength">new X-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <param name="yLength">new Y-side length for the range. The length must be at least 0. If equal to 0, no change is made
            to this side.</param>
            <returns>true if a range was found starting at the specified index and updated; false if the
            start was not found or the sum of lengths would have exceeded Int32.MaxValue</returns>
        </member>
        <member name="M:TreeLib.IRange2ListLong.AdjustLength(System.Int64,TreeLib.Side,System.Int64,System.Int64)">
            <summary>
            Adjust the lengths of the range starting at 'start' by adding xAdjust and yAdjust to the current lengths of the
            range. If the lengths would become 0, the range is removed.
            </summary>
            <param name="start">the start index of the range to adjust</param>
            <param name="side">which side (X or Y) the start parameter applies</param>
            <param name="xAdjust">the amount to adjust the X length by. Value may be negative to shrink the length</param>
            <param name="yAdjust">the amount to adjust the Y length by. Value may be negative to shrink the length</param>
            <returns>The adjusted length</returns>
            <exception cref="T:System.ArgumentException">There is no range starting at the index specified by 'start', or the length on
            one side would become 0 while the length on the other side would not be 0.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">one or both of the lengths would become negative</exception>
            <exception cref="T:System.OverflowException">the X or Y extent would become larger than Int32.MaxValue</exception>
        </member>
        <member name="M:TreeLib.IRange2ListLong.GetExtent(TreeLib.Side)">
            <summary>
            Retrieves the extent of the sequence of ranges on the specified side. The extent is the sum of the lengths of all the ranges.
            </summary>
            <param name="side">the side (X or Y) to which the query applies.</param>
            <returns>the extent of the ranges on the specified side</returns>
        </member>
        <member name="M:TreeLib.IRange2ListLong.NearestLessOrEqual(System.Int64,TreeLib.Side,System.Int64@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index with respect to the specified side.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2ListLong.NearestLess(System.Int64,TreeLib.Side,System.Int64@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2ListLong.NearestGreaterOrEqual(System.Int64,TreeLib.Side,System.Int64@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2ListLong.NearestGreater(System.Int64,TreeLib.Side,System.Int64@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2ListLong.NearestLessOrEqual(System.Int64,TreeLib.Side,System.Int64@,System.Int64@,System.Int64@,System.Int64@)">
            <summary>
            Search for the nearest range that starts at an index less than or equal to the specified index with respect to the specified side.
            Use this method to convert an index to the interior of a range into the start index of a range.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            This may be a range starting at the specified index or the range containing the index if the index refers
            to the interior of a range.
            If the value is greater than or equal to the extent it will return the start of the last range of the collection.
            If there are no ranges in the collection or position is less than 0, no range will be found.
            </param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index less than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2ListLong.NearestLess(System.Int64,TreeLib.Side,System.Int64@,System.Int64@,System.Int64@,System.Int64@)">
            <summary>
            Search for the nearest range that starts at an index less than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the specified index is an interior index, the start of the containing range will be returned.
            If the index is at the start of a range, the start of the previous range will be returned.
            If the value is greater than or equal to the extent it will return the start of last range of the collection.
            If there are no ranges in the collection or position is less than or equal to 0, no range will be found.
            </param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index less than the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2ListLong.NearestGreaterOrEqual(System.Int64,TreeLib.Side,System.Int64@,System.Int64@,System.Int64@,System.Int64@)">
            <summary>
            Search for the nearest range that starts at an index greater than or equal to the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range, that index will be returned.
            If the index refers to the interior index for a range, the start of the next range in the sequence will be returned.
            If the index is less than or equal to 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than the start of the last range, no range will be found.
            </param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index greater than or equal to the specified index</returns>
        </member>
        <member name="M:TreeLib.IRange2ListLong.NearestGreater(System.Int64,TreeLib.Side,System.Int64@,System.Int64@,System.Int64@,System.Int64@)">
            <summary>
            Search for the nearest range that starts at an index greater than the specified index with respect to the specified side.
            </summary>
            <param name="position">the index to begin searching at</param>
            <param name="side">the side (X or Y) to which the specified index applies.</param>
            <param name="nearestStart">an out parameter receiving the start index of the range that was found.
            If the index refers to the start of a range or is an interior index for a range, the next range in the
            sequence will be returned.
            If the index is less than 0, the index 0 will be returned, which is the start of the first range.
            If the index is greater than or equal to the start of the last range, no range will be found.
            </param>
            <param name="otherStart">an out parameter receiving start of the range pair on the other side of the mapping</param>
            <param name="xLength">an out parameter receiving the length of the range on side X</param>
            <param name="yLength">an out parameter receiving the length of the range on side Y</param>
            <returns>true if a range was found with a starting index greater than the specified index</returns>
        </member>
        <member name="T:TreeLib.ITreeEnumerable`1">
            <summary>
            Provides access to multiple types of enumerators with initialization parameters, beyond what the standard
            IEnumerable&lt;&gt; interface provides.
            </summary>
            <typeparam name="T">The entry record type of the enumeration</typeparam>
        </member>
        <member name="M:TreeLib.ITreeEnumerable`1.GetEnumerable">
            <summary>
            Create a new instance of the default enumerator. Equivalent to IEnumerable&lt;&gt;.GetEnumerator()
            </summary>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.ITreeEnumerable`1.GetEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the default enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.ITreeEnumerable`1.GetFastEnumerable">
            <summary>
            Create a new instance of the fast enumerator.
            </summary>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.ITreeEnumerable`1.GetFastEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.ITreeEnumerable`1.GetRobustEnumerable">
            <summary>
            Create a new instance of the robust enumerator.
            </summary>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.ITreeEnumerable`1.GetRobustEnumerable(System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator traversing in the specified direction.
            </summary>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.IKeyedTreeEnumerable`2">
            <summary>
            Provides access to multiple types of enumerators with initialization parameters, beyond what the standard
            IEnumerable&lt;&gt; interface provides.
            </summary>
            <typeparam name="KeyType">The key type of the collection</typeparam>
            <typeparam name="T">The entry record type of the enumeration</typeparam>
        </member>
        <member name="M:TreeLib.IKeyedTreeEnumerable`2.GetEnumerable(`0)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts with the next higher key in sort order.</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.IKeyedTreeEnumerable`2.GetEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.IKeyedTreeEnumerable`2.GetFastEnumerable(`0)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts with the next higher key in sort order.</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.IKeyedTreeEnumerable`2.GetFastEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.IKeyedTreeEnumerable`2.GetRobustEnumerable(`0)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts with the next higher key in sort order.</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.IKeyedTreeEnumerable`2.GetRobustEnumerable(`0,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified key.
            </summary>
            <param name="startAt">The key to start enumeration at. If the key is not present in the collection, enumeration
            starts as follows: for forward enumeration, the next key higher in sort order; for reverse enumeration, the next lower
            (i.e. previous) key in sort order</param>
            <param name="forward">True to move from first to last in sort order; False to move backwards, from last to first, in sort order</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.IIndexedTreeEnumerable`1">
            <summary>
            Provides access to multiple types of enumerators with initialization parameters, beyond what the standard
            IEnumerable&lt;&gt; interface provides.
            </summary>
            <typeparam name="T">The entry record type of the enumeration</typeparam>
        </member>
        <member name="M:TreeLib.IIndexedTreeEnumerable`1.GetEnumerable(System.Int32)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.IIndexedTreeEnumerable`1.GetEnumerable(System.Int32,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.IIndexedTreeEnumerable`1.GetFastEnumerable(System.Int32)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.IIndexedTreeEnumerable`1.GetFastEnumerable(System.Int32,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.IIndexedTreeEnumerable`1.GetRobustEnumerable(System.Int32)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.IIndexedTreeEnumerable`1.GetRobustEnumerable(System.Int32,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.IIndexedTreeEnumerableLong`1">
            <summary>
            Provides access to multiple types of enumerators with initialization parameters, beyond what the standard
            IEnumerable&lt;&gt; interface provides.
            </summary>
            <typeparam name="T">The entry record type of the enumeration</typeparam>
        </member>
        <member name="M:TreeLib.IIndexedTreeEnumerableLong`1.GetEnumerable(System.Int64)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.IIndexedTreeEnumerableLong`1.GetEnumerable(System.Int64,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.IIndexedTreeEnumerableLong`1.GetFastEnumerable(System.Int64)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.IIndexedTreeEnumerableLong`1.GetFastEnumerable(System.Int64,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.IIndexedTreeEnumerableLong`1.GetRobustEnumerable(System.Int64)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.IIndexedTreeEnumerableLong`1.GetRobustEnumerable(System.Int64,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.IIndexed2TreeEnumerable`1">
            <summary>
            Provides access to multiple types of enumerators with initialization parameters, beyond what the standard
            IEnumerable&lt;&gt; interface provides.
            </summary>
            <typeparam name="T">The entry record type of the enumeration</typeparam>
        </member>
        <member name="M:TreeLib.IIndexed2TreeEnumerable`1.GetEnumerable(System.Int32,TreeLib.Side)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.IIndexed2TreeEnumerable`1.GetEnumerable(System.Int32,TreeLib.Side,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.IIndexed2TreeEnumerable`1.GetFastEnumerable(System.Int32,TreeLib.Side)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.IIndexed2TreeEnumerable`1.GetFastEnumerable(System.Int32,TreeLib.Side,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.IIndexed2TreeEnumerable`1.GetRobustEnumerable(System.Int32,TreeLib.Side)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.IIndexed2TreeEnumerable`1.GetRobustEnumerable(System.Int32,TreeLib.Side,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="T:TreeLib.IIndexed2TreeEnumerableLong`1">
            <summary>
            Provides access to multiple types of enumerators with initialization parameters, beyond what the standard
            IEnumerable&lt;&gt; interface provides.
            </summary>
            <typeparam name="T">The entry record type of the enumeration</typeparam>
        </member>
        <member name="M:TreeLib.IIndexed2TreeEnumerableLong`1.GetEnumerable(System.Int64,TreeLib.Side)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.IIndexed2TreeEnumerableLong`1.GetEnumerable(System.Int64,TreeLib.Side,System.Boolean)">
            <summary>
            Create a new instance of the default enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the default enumerator</returns>
        </member>
        <member name="M:TreeLib.IIndexed2TreeEnumerableLong`1.GetFastEnumerable(System.Int64,TreeLib.Side)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.IIndexed2TreeEnumerableLong`1.GetFastEnumerable(System.Int64,TreeLib.Side,System.Boolean)">
            <summary>
            Create a new instance of the fast enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the fast enumerator</returns>
        </member>
        <member name="M:TreeLib.IIndexed2TreeEnumerableLong`1.GetRobustEnumerable(System.Int64,TreeLib.Side)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration starts
            with the following range.</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
        <member name="M:TreeLib.IIndexed2TreeEnumerableLong`1.GetRobustEnumerable(System.Int64,TreeLib.Side,System.Boolean)">
            <summary>
            Create a new instance of the robust enumerator, starting the enumeration at the specified index.
            </summary>
            <param name="startAt">The index to start enumeration at. If the index is interior to a range, enumeration
            starts as follows: for forward enumeration, the range that follows; for reverse enumeration, the range containing
            the specified index</param>
            <param name="side">The side (X or Y) to which the index pertains</param>
            <param name="forward">True to move from ranges in order of increasing start indexes; False to move backwards
            from the last range through decreasing start indexes</param>
            <returns>A new instance of the robust enumerator</returns>
        </member>
    </members>
</doc>
